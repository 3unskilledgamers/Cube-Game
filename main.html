<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Cubes Game â€” Specials</title>
<style>
  @keyframes fadeOut {
  0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
  100% { opacity: 0; transform: translate(-50%, -80%) scale(1.2); }
}
@keyframes fadeOut {
  0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
  100% { opacity: 0; transform: translate(-50%, -80%) scale(1.2); }
}

@keyframes slideIn {
  from { transform: translateX(400px); opacity: 0; }
  to { transform: translateX(0); opacity: 1; }
}

@keyframes slideOut {
  from { transform: translateX(0); opacity: 1; }
  to { transform: translateX(400px); opacity: 0; }
}
  :root{
    --bg:#111;
    --panel:#0f1720;
    --text:#e6eef6;
    --muted:#9aa8b7;
    --accent:#ff3b3b;
  }
  html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,system-ui,-apple-system,Arial}
  body{background:linear-gradient(180deg,#07101a,#051017);color:var(--text);display:flex;align-items:center;justify-content:center;padding:20px}
  .wrap{width:1000px;max-width:98vw}
  .hud{display:flex;gap:16px;align-items:center;margin-bottom:8px}
  .stat{background:rgba(255,255,255,0.03);padding:8px 12px;border-radius:8px;font-weight:600;color:var(--text)}
  .muted{color:var(--muted);font-weight:400}
  .game{background:var(--panel);padding:12px;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,0.6)}
  canvas{background:linear-gradient(180deg,#0b2330,#08202a);display:block;border-radius:12px;cursor:crosshair}
  .bottom-row{display:flex;align-items:flex-start;gap:24px;margin-top:12px}
  .legend{display:flex;flex-direction:column;gap:8px}
  .legend-row{display:flex;align-items:center;gap:8px}
  .swatch{width:20px;height:20px;border-radius:4px;border:1px solid rgba(0,0,0,0.4)}
  .legend-label{min-width:150px;color:var(--muted);font-size:13px}
  .counter{background:rgba(255,255,255,0.03);padding:4px 8px;border-radius:6px;min-width:40px;text-align:center;font-weight:700}
  .controls{display:flex;flex-direction:column;gap:8px}
  button{background:#123;color:var(--text);padding:6px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);cursor:pointer;font-size:14px}
  button:active{transform:translateY(1px)}
  button:disabled{opacity:0.5;cursor:not-allowed}
  .hint{font-size:12px;color:var(--muted)}
  .topline{display:flex;gap:10px;align-items:center;margin-bottom:10px}
  .small{font-size:12px;color:var(--muted)}

  #bossDropsContainer {
    position: fixed;
    top: 20px;
    right: 20px;     /* move anywhere you want */
    z-index: 10000;

    background: rgba(15, 15, 20, 0.85);
    padding: 10px 12px;
    border-radius: 10px;
    box-shadow: 0 0 12px rgba(0,0,0,0.5);
    backdrop-filter: blur(4px);
    color: #cdeaff;
    font-family: sans-serif;
    min-width: 220px;
  }

  #bossDropsContainer summary {
  cursor: pointer;
  font-weight: bold;
  font-size: 16px;
  color: #00ccff;
  }

  #bossDropsContainer details[open] summary {
  color: #00ffff;
  }


#shopPurchasesContainer {
  position: fixed;
  top: 20px;
  left: 20px;      /* Put shop on left, boss on right */
  z-index: 10000;

  background: rgba(20, 15, 0, 0.85);
  padding: 10px 12px;
  border-radius: 10px;
  box-shadow: 0 0 12px rgba(0,0,0,0.5);
  backdrop-filter: blur(4px);
  color: #ffe9a3;
  font-family: sans-serif;
  min-width: 220px;
}

#shopPurchasesContainer summary {
  cursor: pointer;
  font-weight: bold;
  font-size: 16px;
  color: #ffcc00;
}

#shopPurchasesContainer details[open] summary {
  color: #ffe066;
}

/* Admin Panel Styles */
#adminPanel {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(20, 20, 30, 0.98);
  border: 2px solid #FFD700;
  border-radius: 15px;
  padding: 20px;
  z-index: 10000;
  color: white;
  min-width: 500px;
  max-width: 80vw;
  max-height: 80vh;
  overflow-y: auto;
  display: none;
  box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
}

#adminPanel.active {
  display: block;
}

#adminPanel h2 {
  margin: 0 0 15px 0;
  color: #FFD700;
  text-align: center;
  font-size: 24px;
}

.admin-section {
  margin: 15px 0;
  padding: 10px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
}

.admin-section h3 {
  margin: 0 0 10px 0;
  color: #00ffff;
  font-size: 16px;
}

.admin-btn {
  background: #1a4d7a;
  color: white;
  border: 1px solid #00ffff;
  padding: 8px 15px;
  margin: 5px;
  border-radius: 5px;
  cursor: pointer;
  font-size: 14px;
  transition: all 0.2s;
}

.admin-btn:hover {
  background: #2a5d8a;
  transform: translateY(-2px);
}

.admin-btn:active {
  transform: translateY(0);
}

.admin-input {
  background: #222;
  color: white;
  border: 1px solid #555;
  padding: 5px 10px;
  border-radius: 5px;
  margin: 5px;
  width: 100px;
}

.admin-close {
  position: absolute;
  top: 10px;
  right: 10px;
  background: #8B0000;
  border: none;
  color: white;
  font-size: 20px;
  width: 30px;
  height: 30px;
  border-radius: 50%;
  cursor: pointer;
}
</style>
</head>
<body>
  <!-- Admin Panel -->
<div id="adminPanel">
  <button class="admin-close" onclick="toggleAdminPanel()">Ã—</button>
  <h2>ğŸ”§ Admin Panel ğŸ”§</h2>
  
  <!-- Money Section -->
  <div class="admin-section">
    <h3>ğŸ’° Money Controls</h3>
    <button class="admin-btn" onclick="adminAddMoney(1000000000000000000000000000000000n)">+100DC</button>
    <button class="admin-btn" onclick="adminAddMoney(1000000000000000000000000n)">+1SP</button>
    <button class="admin-btn" onclick="adminAddMoney(1000000000000000000n)">+1QI</button>
    <button class="admin-btn" onclick="adminAddMoney(1000000000000n)">+1T</button>
    <button class="admin-btn" onclick="adminSetMoney(0n)">Reset to 0</button>
  </div>
  
  <!-- Day/Night Controls -->
  <div class="admin-section">
    <h3>ğŸŒ Day/Night Cycle</h3>
    <button class="admin-btn" onclick="changeDayNightCycle('day', true)">â˜€ï¸ Set Day</button>
    <button class="admin-btn" onclick="changeDayNightCycle('sunset', true)">ğŸŒ… Set Sunset</button>
    <button class="admin-btn" onclick="changeDayNightCycle('night', true)">ğŸŒ™ Set Night</button>
    <button class="admin-btn" onclick="changeDayNightCycle('sunrise', true)">ğŸŒ„ Set Sunrise</button>
  </div>
  
  <!-- Event Controls -->
  <div class="admin-section">
    <h3>ğŸ® Events</h3>
    <button class="admin-btn" onclick="adminTriggerEvent('Blackhole')">âš« Blackhole</button>
    <button class="admin-btn" onclick="adminTriggerEvent('Hurricane')">ğŸŒ€ Hurricane</button>
    <button class="admin-btn" onclick="adminTriggerEvent('Disco')">ğŸª© Disco</button>
    <button class="admin-btn" onclick="adminTriggerEvent('Volcano')">ğŸŒ‹ Volcano</button>
    <button class="admin-btn" onclick="adminTriggerEvent('Earthquake')">ğŸ«¨ Earthquake</button>
    <button class="admin-btn" onclick="adminTriggerEvent('Glitched')">âšœï¸ Glitched</button>
    <button class="admin-btn" onclick="adminTriggerEvent('Galactic')">ğŸš€ Galactic</button>
    <button class="admin-btn" onclick="triggerWeatherEvent()">ğŸŒ¦ï¸ Random Weather</button>
    <button class="admin-btn" onclick="startChristmasEvent()">ğŸ„ Christmas</button>
    <button class="admin-btn" onclick="adminTriggerEvent('Phoenix Nest')">ğŸ”¥ Phoenix Nest</button>
    <button class="admin-btn" onclick="adminTriggerEvent('Bloodmoon')">ğŸŒ• Bloodmoon</button>
    <button class="admin-btn" onclick="adminTriggerEvent('Tornado')">ğŸŒªï¸ Tornado</button>
  </div>
  
  <!-- Boss Controls -->
  <div class="admin-section">
    <h3>â˜ ï¸ Boss Controls</h3>
    <button class="admin-btn" onclick="spawnBoss()">Spawn Boss</button>
    <button class="admin-btn" onclick="adminKillBoss()">Kill Boss</button>
  </div>
  
  <!-- Advent Calendar Controls -->
  <div class="admin-section">
    <h3>ğŸ“… Advent Calendar</h3>
    <button class="admin-btn" onclick="adminAdventSkipDay()">â­ï¸ Skip +1 Day</button>
    <button class="admin-btn" onclick="adminAdventBackDay()">â®ï¸ Back -1 Day</button>
    <button class="admin-btn" onclick="adminAdventReset()">ğŸ”„ Reset to Today</button>
    <button class="admin-btn" onclick="showAdventCalendar()">ğŸ“– Open Calendar</button>
    <span style="color:#aaa; font-size:12px; margin-left:10px;">Current: Day <span id="adminAdventDay">1</span></span>
  </div>
  
  <!-- Pet Controls -->
  <div class="admin-section">
    <h3>ğŸ¾ Pet Controls</h3>
    <button class="admin-btn" onclick="adminGiveRandomEgg()">ğŸ¥š Random Egg</button>
    <button class="admin-btn" onclick="adminClearAllPets()">ğŸ—‘ï¸ Clear All Pets</button>
    <button class="admin-btn" onclick="adminMaxPetSlots()">â¬†ï¸ Max Pet Slots (10)</button>
  </div>
  <!-- NEW: Enchantment Controls -->
<div class="admin-section">
  <h3>ğŸ”® Enchantment Controls</h3>
  <button class="admin-btn" onclick="adminUnlockEnchanting()">ğŸ”“ Unlock Enchanting</button>
  <button class="admin-btn" onclick="adminAddEnchants(100)">+100 Enchants</button>
  <button class="admin-btn" onclick="adminGiveEnchantEgg()">ğŸ”® Give Enchant Egg</button>
  <button class="admin-btn" onclick="adminGiveEnchantRelic()">ğŸ€ Give Enchant Relic</button>
  <button class="admin-btn" onclick="adminClearEnchants()">ğŸ—‘ï¸ Clear All Enchantments</button>
  <span style="color:#aaa; font-size:12px; margin-left:10px;">Total: <span id="adminEnchantCount">0</span></span>
</div>
<!-- NEW: Crafting Material Controls -->
<div class="admin-section">
  <h3>ğŸ”¨ Crafting Materials</h3>
  <div style="margin-bottom: 15px; padding: 10px; background: rgba(255, 215, 0, 0.1); border-radius: 5px;">
  <button class="admin-btn" onclick="adminUnlockCrafting()" style="background:#FFD700; color:#000; font-weight:bold;">ğŸ”“ Unlock Crafting System</button>
  <button class="admin-btn" onclick="adminUnlockAllRecipes()" style="background:#FF8C00; color:#fff; font-weight:bold;">ğŸ“œ Unlock ALL Recipes</button>
  <button class="admin-btn" onclick="adminTestMaterials()" style="background:#00CED1; color:#fff;">ğŸ§ª Test Materials</button>
</div>
  <div style="margin-bottom: 10px;">
    <strong style="color: #FFD700;">Boss Materials:</strong><br>
    <button class="admin-btn" onclick="adminGiveMaterial('Phoenix Feather', 10)">+10 Phoenix Feathers</button>
    <button class="admin-btn" onclick="adminGiveMaterial('Phoenix Ember', 5)">+5 Phoenix Embers</button>
    <button class="admin-btn" onclick="adminGiveMaterial('Leviathan Scale', 10)">+10 Leviathan Scales</button>
    <button class="admin-btn" onclick="adminGiveMaterial('Leviathan Heart', 5)">+5 Leviathan Hearts</button>
    <button class="admin-btn" onclick="adminGiveMaterial('Leviathan Fang', 1)">+1 Leviathan Fang</button>
  </div>
  
  <div style="margin-bottom: 10px;">
    <strong style="color: #FFD700;">Enchanted Materials:</strong><br>
    <button class="admin-btn" onclick="adminGiveMaterial('Enchanted Leviathan Scale', 10)">+10 Enchanted Scales</button>
    <button class="admin-btn" onclick="adminGiveMaterial('Enchanted Leviathan Heart', 5)">+5 Enchanted Hearts</button>
    <button class="admin-btn" onclick="adminGiveMaterial('Enchanted Leviathan Fang', 1)">+1 Enchanted Fang</button>
  </div>
  
  <div style="margin-bottom: 10px;">
    <strong style="color: #FFD700;">Totems & Tools:</strong><br>
    <button class="admin-btn" onclick="adminGiveMaterial('Leviathan Totem', 1)">+1 Leviathan Totem</button>
    <button class="admin-btn" onclick="adminGiveMaterial('Harpoon', 1)">+1 Harpoon</button>
    <button class="admin-btn" onclick="adminGiveMaterial('Leviathan Armor', 1)">+1 Leviathan Armor</button>
  </div>
  
  <div style="margin-bottom: 10px;">
    <strong style="color: #FFD700;">Essences & Shards:</strong><br>
    <button class="admin-btn" onclick="adminGiveMaterial('Essence of Fire', 10)">+10 Fire Essence</button>
    <button class="admin-btn" onclick="adminGiveMaterial('Essence of Ice', 10)">+10 Ice Essence</button>
    <button class="admin-btn" onclick="adminGiveMaterial('Essence of Lightning', 10)">+10 Lightning</button>
    <button class="admin-btn" onclick="adminGiveMaterial('Essence of Wind', 10)">+10 Wind</button>
    <button class="admin-btn" onclick="adminGiveMaterial('Shard of Fire', 5)">+5 Fire Shards</button>
    <button class="admin-btn" onclick="adminGiveMaterial('Shard of Ice', 5)">+5 Ice Shards</button>
  </div>
  
  <div style="margin-bottom: 10px;">
    <strong style="color: #FFD700;">Scrolls:</strong><br>
    <button class="admin-btn" onclick="adminGiveMaterial('Scroll of Fire', 5)">+5 Fire Scrolls</button>
    <button class="admin-btn" onclick="adminGiveMaterial('Scroll of the Egg', 1)">+1 Egg Scroll</button>
    <button class="admin-btn" onclick="adminGiveMaterial('Scroll of Terror', 1)">+1 Terror Scroll</button>
    <button class="admin-btn" onclick="adminGiveMaterial('Scroll of the Enchanted', 1)">+1 Enchanted Scroll</button>
    <button class="admin-btn" onclick="adminGiveMaterial('Freezing Scroll', 1)">+1 Freezing Scroll</button>
  </div>
  
  <div style="margin-bottom: 10px;">
    <strong style="color: #FFD700;">Special Items:</strong><br>
    <button class="admin-btn" onclick="adminGiveMaterial('Elemental Stone', 10)">+10 Elemental Stones</button>
    <button class="admin-btn" onclick="adminGiveMaterial('Elemental Capsule', 5)">+5 Elemental Capsules</button>
    <button class="admin-btn" onclick="adminGiveMaterial('Chaotic Orb', 5)">+5 Chaotic Orbs</button>
    <button class="admin-btn" onclick="adminGiveMaterial('Phoenix Tear', 1)">+1 Phoenix Tear</button>
  </div>
  
  <div>
    <button class="admin-btn" onclick="adminMaxAllMaterials()" style="background:#8B0000;">ğŸ”¥ Max ALL Materials (999)</button>
    <button class="admin-btn" onclick="adminClearAllMaterials()" style="background:#555;">ğŸ—‘ï¸ Clear All Materials</button>
  </div>
</div>

  <!-- Rebirth Controls -->
  <div class="admin-section">
    <h3>ğŸ”„ Rebirth</h3>
    <button class="admin-btn" onclick="adminCompleteRebirth()">Complete Next Rebirth</button>
    <button class="admin-btn" onclick="adminResetRebirths()">Reset All Rebirths</button>
    <span style="color:#aaa; font-size:12px; margin-left:10px;">Current: <span id="adminRebirthCount">0</span></span>
  </div>
  
  <!-- Cube Controls -->
  <div class="admin-section">
    <h3>ğŸ² Cube Controls</h3>
    <button class="admin-btn" onclick="adminMaxAllCubes()">Max All Cubes (999)</button>
    <button class="admin-btn" onclick="adminClearAllCubes()">Clear All Cubes</button>
  </div>
  
  <!-- Shop Controls -->
  <div class="admin-section">
    <h3>ğŸ›’ Shop</h3>
    <button class="admin-btn" onclick="adminUnlockAllShop()">Unlock All Items</button>
  </div>
</div>
<div class="wrap">
  <div class="hud topline">
    <div class="stat" id="moneyDisplay">Money: 0</div>
    <div class="stat" id="incomeDisplay">Income/sec: 0</div>
    <div class="stat" id="houseDisplay">House value: 0</div>
    <div style="flex:1"></div>
<div class="small muted">Move: WASD or click to set target</div>
  </div>

  <div class="game">
    <canvas id="gameCanvas" width="960" height="540"></canvas>

    <div class="bottom-row">
      <div class="legend" id="legendContainer"></div>

<div class="controls">
  <div style="display:flex;gap:8px;align-items:center;">
    <button id="upgradeBtn" style="flex:1;">â¬†ï¸ Upgrade Cubes</button>
    <div id="eventIndicator" style="font-size:24px;width:40px;text-align:center;flex-shrink:0;" title="No active event">â€”</div>
  </div>
  <button id="downgradeBtn">â¬‡ï¸ Downgrade Cubes</button>
  <button id="adventBtn">ğŸ„ Advent Calendar</button>
  <button id="craftingBtn">ğŸ”¨ Crafting</button>
  <button id="saveBtn">ğŸ’¾ Save</button>
  <button id="loadBtn">ğŸ“‚ Load</button>
  <button id="rebirthBtn">ğŸ”„ Rebirth</button>
  <div class="hint" id="tierHint">Current Tier: 1</div>
  <div class="hint" id="rebirthHint">Rebirths: 0 (1x)</div>
    <div class="hint" id="enchantHint" style="display:none;">ğŸ”® Enchants: 0</div>
</div>
</div>

      <!-- ğŸ§­ Inventory / Drop Counter -->
    <div id="inventoryContainer" style="color:white;">
      <div class="legend-label"></div>
      <div id="inventoryList" style="margin-top:6px; line-height:1.5;"></div>
    </div>

    <!-- ğŸª SHOP AREA (hidden until inside house) -->
    <div id="shopContainer" style="display:none; color:white;">
      <div class="legend-label">ğŸª SHOP</div>
      <div id="shopItems" style="margin-top:6px; line-height:1.5;"></div>
    </div>

 </div>
 </div>
</div>

<script>
  // Global error handler to prevent crashes
window.addEventListener('error', (event) => {
  console.error('Game Error:', event.error);
  event.preventDefault(); // Prevent the error from crashing the game
  return true;
});

// Catch unhandled promise rejections
window.addEventListener('unhandledrejection', (event) => {
  console.error('Unhandled Promise Rejection:', event.reason);
  event.preventDefault();
});
  const MAX_PARTICLES = 200;
const MAX_BOSS_DROPS = 50;
const MAX_SPECIALS = 20;
const canvas = document.getElementById('gameCanvas');


// === ADMIN ABUSE EVENTS CONFIGURATION ===
const adminAbuseEvents = [
  {
    name: "Blackhole",
    key: "!",
    duration: 120000, // 2 minutes in ms
    incomeBoost: 1.30, // 30% boost
    bg: "radial-gradient(circle at center, #000000 0%, #1a0033 30%, #330066 60%, #000000 100%)",
    overlay: "rgba(0,0,0,0.3)",
    animation: "blackhole"
  },
  {
    name: "Hurricane",
    key: "@",
    duration: 60000, // 1 minute
    incomeBoost: 1.15,
    bg: "radial-gradient(circle, #334455 0%, #1a2a3a 50%, #0d1520 100%)",
    overlay: "rgba(100,120,150,0.25)",
    animation: "hurricane"
  },
  {
    name: "Disco",
    key: "#",
    duration: 95000, // 1 min 35 sec
    incomeBoost: 1.25,
    bg: "linear-gradient(45deg, #ff00ff 0%, #00ffff 25%, #ffff00 50%, #ff00ff 75%, #00ffff 100%)",
    overlay: "rgba(255,255,255,0.1)",
    animation: "disco"
  },
  {
    name: "Volcano",
    key: "$",
    duration: 45000, // 45 seconds
    incomeBoost: 1.35,
    bg: "linear-gradient(180deg, #330000 0%, #660000 30%, #ff4400 60%, #ff8800 100%)",
    overlay: "rgba(255,100,0,0.3)",
    animation: "volcano"
  },
  {
    name: "Earthquake",
    key: "%",
    duration: 15000, // 15 seconds
    incomeBoost: 1.50,
    bg: "linear-gradient(180deg, #2a2520 0%, #3a2a20 50%, #2a2520 100%)",
    overlay: "rgba(100,80,60,0.2)",
    animation: "earthquake"
  },
  {
    name: "Glitched",
    key: "^",
    duration: 60000, // 1 minute
    incomeBoost: 1.35,
    bg: "linear-gradient(90deg, #000 0%, #0f0 2%, #000 4%, #f0f 6%, #000 8%, #0ff 10%, #000 100%)",
    overlay: "rgba(0,255,0,0.15)",
    animation: "glitched"
  },
  {
    name: "Galactic",
    key: "&",
    duration: 180000, // 3 minutes
    incomeBoost: 1.20,
    bg: "radial-gradient(circle at 20% 30%, #4a0080 0%, #000033 40%, #000000 100%)",
    overlay: "rgba(80,60,150,0.2)",
    animation: "galactic"
  },
 {
    name: "Phoenix Nest",
    key: "*",
    duration: 60000, // 1 minute
    incomeBoost: 1.0, // No income boost
    bg: "radial-gradient(circle at center, #FF4500 0%, #FF8C00 30%, #FFD700 60%, #FF4500 100%)",
    overlay: "rgba(255, 69, 0, 0.3)",
    animation: "phoenix"
  },
  {
    name: "Bloodmoon",
    key: "(",
    duration: 120000, // 2 minutes
    incomeBoost: 1.30, // 30% boost
    bg: "radial-gradient(circle at 50% 20%, #8B0000 0%, #4B0000 40%, #2B0000 70%, #000000 100%)",
    overlay: "rgba(139, 0, 0, 0.4)",
    animation: "bloodmoon"
  },
  {
    name: "Tornado",
    key: ")",
    duration: 999999999, // Lasts until hit
    incomeBoost: 1.60, // 60% boost
    bg: "linear-gradient(180deg, #4a5568 0%, #2d3748 50%, #1a202c 100%)",
    overlay: "rgba(100, 100, 100, 0.3)",
    animation: "tornado"
  }
];

// === CHRISTMAS EVENT CONFIGURATION ===
const christmasEvent = {
  active: false,
  lastTrigger: 0,
  interval: 60 * 60 * 1000, // 1 hour in ms
  duration: 10 * 60 * 1000, // 10 minutes active
  incomeBoost: 1.20, // 20% boost
  snowflakes: [],
  snowCollected: 0
};

// === ADVENT CALENDAR CONFIGURATION ===
const adventCalendar = {
  currentDay: 1, // Tracks which day we're on (1-25)
  year: new Date().getFullYear(),
  claimedDays: [], // Array of claimed day numbers
    debugOffset: 0, // NEW: For debug day skipping
  rewards: {
    1: { type: "pet", name: "Snowflake Cube", icon: "â„ï¸", color: "#B0E0E6", ability: "passive_income", value: 1.10, description: "+10% income" },
    2: { type: "sword", name: "Candy Cane Sword", icon: "ğŸ­", special: 3, price: 0 },
    3: { type: "pet", name: "Gingerbread Cube", icon: "ğŸª", color: "#8B4513", ability: "speed_boost", value: 1.15, description: "+15% speed" },
    4: { type: "snow", amount: 50 },
    5: { type: "pet", name: "Holly Cube", icon: "ğŸ„", color: "#228B22", ability: "money_doubler", value: 0.20, description: "Double money (5min)" },
    6: { type: "skin", name: "Santa Skin", icon: "ğŸ…", special: 8, color: "#DC143C" },
    7: { type: "money", amount: 1_000_000_000_000_000n }, // 1QA
    8: { type: "pet", name: "Star Cube", icon: "â­", color: "#FFD700", ability: "shooting_star", value: 0.50, description: "Shooting star (10min)" },
    9: { type: "relic", name: "Christmas Relic", icon: "ğŸ", special: 1.45 },
    10: { type: "snow", amount: 100 },
    11: { type: "pet", name: "Bell Cube", icon: "ğŸ””", color: "#C0C0C0", ability: "entity_spawner", value: 1, description: "Spawns entities (10min)" },
    12: { type: "sword", name: "Frost Blade", icon: "â„ï¸ğŸ—¡ï¸", special: 5, price: 0 },
    13: { type: "pet", name: "Ornament Cube", icon: "ğŸ€", color: "#FF69B4", ability: "passive_income", value: 1.15, description: "+15% income" },
    14: { type: "money", amount: 10_000_000_000_000_000n }, // 10QA
    15: { type: "skin", name: "Elf Skin", icon: "ğŸ§", special: 9, color: "#32CD32" },
    16: { type: "snow", amount: 150 },
    17: { type: "pet", name: "Wreath Cube", icon: "ğŸŠ", color: "#006400", ability: "cycle_changer", value: 0.80, description: "Change day/night (2min)" },
    18: { type: "money", amount: 100_000_000_000_000_000n }, // 100QA
    19: { type: "snow", amount: 200 },
    20: { type: "money", amount: 1_000_000_000_000_000_000n }, // 1QI
    21: { type: "pet", name: "Reindeer Cube", icon: "ğŸ¦Œ", color: "#8B4513", ability: "double_damage", value: 2, description: "2x sword damage" },
    22: { type: "snow", amount: 250 },
    23: { type: "money", amount: 10_000_000_000_000_000_000n }, // 10QI
    24: { type: "money", amount: 100_000_000_000_000_000_000n }, // 100QI
    25: { type: "money", amount: 1_000_000_000_000_000_000_000n } // 1SX - Christmas Day Grand Prize!
  }
};
const craftingBtn = document.getElementById('craftingBtn');
if (craftingBtn) {
  craftingBtn.addEventListener('click', () => {
    showCraftingMenu();
  });
}
// Christmas pet database
const christmasPets = {
  "Snowflake Cube": { name: "Snowflake Cube", color: "#B0E0E6", icon: "â„ï¸", ability: "passive_income", value: 1.10, description: "+10% income" },
  "Gingerbread Cube": { name: "Gingerbread Cube", color: "#8B4513", icon: "ğŸª", ability: "speed_boost", value: 1.15, description: "+15% speed" },
  "Holly Cube": { name: "Holly Cube", color: "#228B22", icon: "ğŸ„", ability: "money_doubler", value: 0.20, description: "Double money (5min)" },
  "Star Cube": { name: "Star Cube", color: "#FFD700", icon: "â­", ability: "shooting_star", value: 0.50, description: "Shooting star (10min)" },
  "Bell Cube": { name: "Bell Cube", color: "#C0C0C0", icon: "ğŸ””", ability: "entity_spawner", value: 1, description: "Spawns entities (10min)" },
  "Ornament Cube": { name: "Ornament Cube", color: "#FF69B4", icon: "ğŸ€", ability: "passive_income", value: 1.15, description: "+15% income" },
  "Wreath Cube": { name: "Wreath Cube", color: "#006400", icon: "ğŸŠ", ability: "cycle_changer", value: 0.80, description: "Change day/night (2min)" },
  "Reindeer Cube": { name: "Reindeer Cube", color: "#8B4513", icon: "ğŸ¦Œ", ability: "double_damage", value: 2, description: "2x sword damage" }
};

// Christmas Shop Items
const christmasShopItems = {
  Swords: [
    { icon: "ğŸ…ğŸ—¡ï¸", price: 1_000_000_000_000_000_000n, name: "Santa's Blade", limit: 1, special: 4 }
  ],
  Relics: [
    { icon: "ğŸ””", price: 100_000_000_000_000_000_000_000n, name: "Jingle Bell Relic", limit: 1, special: 1.52 }
  ],
  Eggs: [
    { icon: "ğŸ", price: 100_000_000_000_000_000_000_000_000_000n, name: "Gift Egg", limit: 999, special: 1 }
  ],
  Skins: [
    { icon: "ğŸ„", price: 10_000_000_000_000_000_000_000n, name: "Christmas Tree Skin", limit: 1, special: 10, color: "#228B22" }
  ],
  Potions: [
    { icon: "ğŸ…ğŸ§ª", price: 100_000_000_000_000_000_000n, name: "Santa's Potion", limit: 999, special: 5.2 }
  ]
};


// === DAY/NIGHT CYCLE CONFIGURATION ===
// === DAY/NIGHT CYCLE CONFIGURATION ===
const dayNightCycle = {
  current: "day", // "day", "night", "sunrise", "sunset"
  duration: 15 * 60 * 1000, // 15 minutes in milliseconds
  transitionDuration: 5 * 60 * 1000, // 5 minutes for sunrise/sunset
  nextChange: Date.now() + 10 * 60 * 1000, // 10 min until sunset starts
  transitioning: false,
  transitionProgress: 0,
  
  day: {
    background: "linear-gradient(180deg, #87CEEB 0%, #E0F6FF 50%, #87CEEB 100%)",
    canvasGradient: ["#B0E0FF", "#D0F0FF", "#B0E0FF"],
    overlay: "rgba(255, 255, 150, 0.1)",
    emoji: "â˜€ï¸",
    name: "Day",
    celestialBody: "â˜€ï¸",
    celestialY: 80
  },
  
  sunset: {
    background: "linear-gradient(180deg, #FF6B35 0%, #FF8C42 30%, #FFA756 60%, #87CEEB 100%)",
    canvasGradient: ["#FF6B35", "#FF8C42", "#FFA756"],
    overlay: "rgba(255, 100, 50, 0.2)",
    emoji: "ğŸŒ…",
    name: "Sunset",
    celestialBody: "ğŸŒ‡",
    celestialY: 200
  },
  
  night: {
    background: "linear-gradient(180deg, #0A1128 0%, #1A2238 50%, #0A1128 100%)",
    canvasGradient: ["#0b2330", "#08202a", "#0b2330"],
    overlay: "rgba(0, 0, 50, 0.4)",
    emoji: "ğŸŒ™",
    name: "Night",
    celestialBody: "ğŸŒ™",
    celestialY: 80
  },
  
  sunrise: {
    background: "linear-gradient(180deg, #1A2238 0%, #FF6B35 40%, #FFB347 70%, #87CEEB 100%)",
    canvasGradient: ["#1A2238", "#FF6B35", "#FFB347"],
    overlay: "rgba(255, 150, 100, 0.2)",
    emoji: "ğŸŒ„",
    name: "Sunrise",
    celestialBody: "ğŸŒ…",
    celestialY: 200
  }
};

let dayNightStars = []; // for night time stars
let sunsetClouds = []; // for sunset/sunrise clouds

// Generate stars for night time
function generateStars() {
  dayNightStars = [];
  for (let i = 0; i < 100; i++) {
    dayNightStars.push({
      x: Math.random() * W,
      y: Math.random() * H * 0.6, // only in top 60% of screen
      size: 1 + Math.random() * 2,
      twinkle: Math.random(),
      twinkleSpeed: 0.5 + Math.random() * 1.5
    });
  }
}

// Generate clouds for sunset/sunrise
function generateClouds() {
  sunsetClouds = [];
  for (let i = 0; i < 8; i++) {
    sunsetClouds.push({
      x: Math.random() * W,
      y: 100 + Math.random() * 150,
      width: 60 + Math.random() * 80,
      height: 30 + Math.random() * 20,
      speed: 10 + Math.random() * 20,
      opacity: 0.3 + Math.random() * 0.4
    });
  }
}

// Change day/night cycle
// Change day/night cycle
function changeDayNightCycle(newCycle, isManual = false) {
  if (dayNightCycle.current === newCycle && !isManual) return;
  
  const oldCycle = dayNightCycle.current;
  dayNightCycle.current = newCycle;
  
  // Set next change time based on cycle
  if (isManual) {
    // Manual trigger - set appropriate next auto change
    if (newCycle === "day") {
      dayNightCycle.nextChange = Date.now() + 10 * 60 * 1000; // 10 min until sunset
    } else if (newCycle === "sunset") {
      dayNightCycle.nextChange = Date.now() + 5 * 60 * 1000; // 5 min until night
    } else if (newCycle === "night") {
      dayNightCycle.nextChange = Date.now() + 10 * 60 * 1000; // 10 min until sunrise
    } else if (newCycle === "sunrise") {
      dayNightCycle.nextChange = Date.now() + 5 * 60 * 1000; // 5 min until day
    }
  } else {
    // Auto progression
    if (newCycle === "sunset") {
      dayNightCycle.nextChange = Date.now() + 5 * 60 * 1000; // 5 min until night
    } else if (newCycle === "night") {
      dayNightCycle.nextChange = Date.now() + 10 * 60 * 1000; // 10 min until sunrise
    } else if (newCycle === "sunrise") {
      dayNightCycle.nextChange = Date.now() + 5 * 60 * 1000; // 5 min until day
    } else if (newCycle === "day") {
      dayNightCycle.nextChange = Date.now() + 10 * 60 * 1000; // 10 min until sunset
    }
  }
  
  console.log(`ğŸŒ ${dayNightCycle[newCycle].name} started! Next change in ${Math.round((dayNightCycle.nextChange - Date.now()) / 60000)} minutes`);
  
  // Generate appropriate particles
  if (newCycle === "night" || newCycle === "sunrise") {
    generateStars();
  }
  if (newCycle === "sunset" || newCycle === "sunrise") {
    generateClouds();
  }
  
  updateEventIndicator();
    // Update shop display if player is in house
  if (insideHouse) {
    updateShopDisplay();
  }
}


// Auto cycle with transitions
function checkDayNightCycle() {
  if (Date.now() >= dayNightCycle.nextChange) {
    const current = dayNightCycle.current;
    
    // Progression: day -> sunset -> night -> sunrise -> day
    if (current === "day") {
      changeDayNightCycle("sunset");
    } else if (current === "sunset") {
      changeDayNightCycle("night");
    } else if (current === "night") {
      changeDayNightCycle("sunrise");
    } else if (current === "sunrise") {
      changeDayNightCycle("day");
    }
  }
}

// Check cycle every second
setInterval(checkDayNightCycle, 1000);

// Auto cycle every 15 minutes
function checkDayNightCycle() {
  if (Date.now() >= dayNightCycle.nextChange) {
    const newCycle = dayNightCycle.current === "day" ? "night" : "day";
    changeDayNightCycle(newCycle);
  }
}

// Check cycle every second
setInterval(checkDayNightCycle, 1000);
const rebirthLevels = [
  {
    level: 1,
    cost: 1_000_000_000n, // 1B
    requiredCube: "Red",
    requiredCount: 10,
    incomeMultiplier: 0.5,
    description: "Rebirth 1: +0.5x Income"
  },
  {
    level: 2,
    cost: 1_000_000_000_000n, // 1T
    requiredCube: "Light Blue",
    requiredCount: 10,
    incomeMultiplier: 0.5,
    petSlotReward: 1,
    description: "Rebirth 2: +0.5x Income, +1 Pet Slot"
  },
  {
    level: 3,
    cost: 1_000_000_000_000_000n, // 1QA
    requiredCube: "Light Orange",
    requiredCount: 10,
    incomeMultiplier: 0.5,
    description: "Rebirth 3: +0.5x Income"
  },
  {
    level: 4,
    cost: 1_000_000_000_000_000_000n, // 1QI
    requiredCube: "Light Gray",
    requiredCount: 10,
    incomeMultiplier: 0.5,
    petSlotReward: 1,
    description: "Rebirth 4: +0.5x Income, +1 Pet Slot"
  },
  {
    level: 5,
    cost: 1_000_000_000_000_000_000_000n, // 1SX
    requiredCube: "Indigo",
    requiredCount: 10,
    incomeMultiplier: 0.5,
    description: "Rebirth 5: +0.5x Income"
  },
  {
    level: 6,
    cost: 1_000_000_000_000_000_000_000_000n, // 1SP
    requiredCube: "Dark Purple",
    requiredCount: 10,
    incomeMultiplier: 0.5,
    description: "Rebirth 6: +0.5x Income"
  },
  {
    level: 7,
    cost: 1_000_000_000_000_000_000_000_000_000n, // 1OC
    requiredCube: "Neon Green",
    requiredCount: 10,
    incomeMultiplier: 0.5,
    petSlotReward: 1,
    description: "Rebirth 7: +0.5x Income, +1 Pet Slot"
  },
  {
    level: 8,
    cost: 100_000_000_000_000_000_000_000_000_000n, // 100OC (1NO)
    requiredCube: "Bright Orange",
    requiredCount: 10,
    incomeMultiplier: 0.5,
    description: "Rebirth 8: +0.5x Income"
  },
  {
    level: 9,
    cost: 100_000_000_000_000_000_000_000_000_000_000n, // 1DC
    requiredCube: "Dark Brown",
    requiredCount: 10,
    incomeMultiplier: 0.5,
    petSlotReward: 2,
    goldenSwordReward: true,
    description: "Rebirth 9: +0.5x Income, +2 Pet Slots, Golden Sword (MAX)"
  }
];

let rebirthCount = 0;
let rebirthMultiplier = 1.0;
let maxPetSlots = 3; // NEW: Track max pet slots

const rebirthBtn = document.getElementById('rebirthBtn');
const rebirthHint = document.getElementById('rebirthHint');
// === ASCENSION SYSTEM ===
const ascensionLevels = [
  {
    level: 1,
    cost: 100_000_000_000_000_000_000_000_000_000_000n, // 100DC
    rewards: {
      eggs: 5,
      totem: 1
    },
    description: "Ascension 1: 5 Ascension Eggs + Heavenly Totem"
  },
  {
    level: 2,
    cost: 1_000_000_000_000_000_000_000_000_000_000_000n, // 1UD
    rewards: {
      eggs: 10,
      totem: 1
    },
    description: "Ascension 2: 10 Ascension Eggs + Heavenly Totem"
  },
  {
    level: 3,
    cost: 10_000_000_000_000_000_000_000_000_000_000_000n, // 10UD
    rewards: {
      eggs: 20,
      totem: 1,
      skin: true
    },
    description: "Ascension 3: 20 Ascension Eggs + Heavenly Totem + Heavenly Skin"
  }
];

let ascensionCount = 0;

// Heavenly Event Configuration
const heavenlyEvent = {
  active: false,
  duration: 15 * 60 * 1000, // 15 minutes
  incomeBoost: 1.35, // 35% boost
  lastTrigger: 0
};
// === ENCHANTMENT SYSTEM ===
const enchantmentSystem = {
  unlocked: false,
  totalEnchants: 0,
  enchantCost: 1_000_000_000_000_000_000n, // 1QI
  hasEnchantRelic: false, // Temporary luck boost
  
  // Milestone rewards
  milestones: {
    50: { claimed: false, reward: "egg" },
    100: { claimed: false, reward: "relic" },
    100: { claimed: false, reward: "sword" }, // Enchanted Sword
    200: { claimed: false, reward: "relic_item" }, // Enchanted Relic
    400: { claimed: false, reward: "skin" },
    500: { claimed: false, reward: "potion" },
    1000: { claimed: false, reward: "rare_sword" }
  }
};

// Enchantment types and tiers
const enchantmentTypes = {
  "Money Income": {
    icon: "ğŸ’°",
    tiers: {
      I: { boost: 1.05, chance: 0.40, description: "+5% money" },
      II: { boost: 1.10, chance: 0.30, description: "+10% money" },
      III: { boost: 1.15, chance: 0.20, description: "+15% money" },
      IV: { boost: 1.20, chance: 0.05, description: "+20% money" },
      V: { boost: 1.25, chance: 0.049, description: "+25% money" }
    }
  },
  "Luck": {
    icon: "ğŸ€",
    tiers: {
      I: { boost: 1.05, chance: 0.40, description: "+5% pet luck" },
      II: { boost: 1.10, chance: 0.30, description: "+10% pet luck" },
      III: { boost: 1.15, chance: 0.20, description: "+15% pet luck" },
      IV: { boost: 1.20, chance: 0.091, description: "+20% pet luck" },
      V: { boost: 1.25, chance: 0.009, description: "+25% pet luck" }
    }
  },
  "Speed": {
    icon: "âš¡",
    tiers: {
      I: { boost: 1.05, chance: 0.40, description: "+5% speed" },
      II: { boost: 1.10, chance: 0.30, description: "+10% speed" },
      III: { boost: 1.15, chance: 0.20, description: "+15% speed" },
      IV: { boost: 1.20, chance: 0.091, description: "+20% speed" },
      V: { boost: 1.25, chance: 0.009, description: "+25% speed" }
    }
  },
  "Sword Damage": {
    icon: "âš”ï¸",
    tiers: {
      I: { boost: 2.0, chance: 0.40, description: "2x sword damage" },
      II: { boost: 3.0, chance: 0.30, description: "3x sword damage" },
      III: { boost: 4.0, chance: 0.20, description: "4x sword damage" },
      IV: { boost: 5.0, chance: 0.091, description: "5x sword damage" },
      V: { boost: 6.0, chance: 0.009, description: "6x sword damage" }
    }
  },
  "Ultimate": {
    icon: "âœ¨",
    tiers: {
      V: { boost: 2.0, chance: 0.001, description: "2x ALL stats" }
    }
  }
};
// === CRAFTING SYSTEM ===
const craftingSystem = {
  unlocked: false,
  unlockedRecipes: [],
  materials: {}, // Tracks material counts
  
  // Crafting recipes
  recipes: {
    // === SWORDS ===
    "Phoenix Sword": {
      type: "Swords",
      icon: "ğŸ”¥âš”ï¸",
      special: 6,
      unlockItem: "Phoenix Tear",
      materials: {
        "Phoenix Feather": 5,
        "Phoenix Ember": 1,
        "Scroll of Fire": 1
      },
      moneyCost: 100_000_000_000_000_000_000_000_000n // 100SP
    },
    "Elemental Sword": {
      type: "Swords",
      icon: "ğŸŒŸâš”ï¸",
      special: 8,
      unlockItem: "Elemental Stone",
      materials: {
        "Elemental Stone": 10,
        "Elemental Capsule": 1,
        "Scroll of Elements": 1
      },
      moneyCost: 10_000_000_000_000_000_000_000_000_000_000n // 10DC
    },
    "Leviathan Sword": {
      type: "Swords",
      icon: "ğŸŒŠâš”ï¸",
      special: 8,
      unlockItem: "Enchanted Leviathan Skin",
      materials: {
        "Leviathan Heart": 1,
        "Enchanted Leviathan Heart": 1,
        "Leviathan Fang": 1,
        "Enchanted Leviathan Fang": 1,
        "King Leviathan": 1 // Pet
      },
      moneyCost: 0n
    },
  // === ULTIMATE SWORDS (Step 4.3 REVISED) ===
"Void Blade": {
  type: "Swords",
  icon: "ğŸŒŒâš”ï¸",
  special: 10,
  unlockItem: "Void Essence",
  materials: {
    "Void Essence": 5,
    "Void Shard": 3,
    "Obsidian Shard": 10,
    "Mythril Ingot": 2
  },
  moneyCost: 100_000_000_000_000_000_000_000_000n // 100SP
},

"Dragon Slayer": {
  type: "Swords",
  icon: "ğŸ‰âš”ï¸",
  special: 12,
  unlockItem: "Dragon Essence",
  materials: {
    "Dragon Essence": 5,
    "Dragon Scale": 10,
    "Mythril Ingot": 5,
    "Celestial Core": 2
  },
  moneyCost: 1_000_000_000_000_000_000_000_000_000n // 1OC
},

"Celestial Blade": {
  type: "Swords",
  icon: "âœ¨âš”ï¸",
  special: 15,
  unlockItem: "Celestial Core",
  materials: {
    "Celestial Core": 3,
    "Celestial Dust": 20,
    "Ancient Tablet": 5,
    "Dragon Essence": 3,
    "Void Essence": 3
  },
  moneyCost: 10_000_000_000_000_000_000_000_000_000n // 10OC
},

"Mythril Greatsword": {
  type: "Swords",
  icon: "â›ï¸âš”ï¸",
  special: 18,
  unlockItem: "Mythril Ingot",
  materials: {
    "Mythril Ingot": 10,
    "Dragon Scale": 20,
    "Void Shard": 5,
    "Celestial Core": 5,
    "Ancient Tablet": 3
  },
  moneyCost: 100_000_000_000_000_000_000_000_000_000n // 100OC
},

"Infinity Blade": {
  type: "Swords",
  icon: "â™¾ï¸âš”ï¸",
  special: 20,
  unlockItem: "Ancient Tablet",
  materials: {
    "Ancient Tablet": 10,
    "Celestial Core": 10,
    "Mythril Ingot": 10,
    "Dragon Essence": 10,
    "Void Essence": 10
  },
  moneyCost: 1_000_000_000_000_000_000_000_000_000_000n // 1NO
},

"Enchanted Leviathan Blade": {
  type: "Swords",
  icon: "âœ¨ğŸŒŠâš”ï¸",
  special: 30,
  unlockItem: "Enchanted Leviathan King", // Changed from "Infinity Blade"
  materials: {
    "Infinity Blade": 1,
    "Enchanted Leviathan Heart": 5,
    "Enchanted Leviathan Fang": 3,
    "Enchanted Leviathan Scale": 10,
    "Celestial Core": 10,
    "Mythril Ingot": 10,
    "Ancient Tablet": 5,
    "Enchanted Leviathan King": 1 // Consumes the pet
  },
  moneyCost: 10_000_000_000_000_000_000_000_000_000_000n // 10NO
},
    // === RELICS ===
    "Relic of Chaos": {
      type: "Relics",
      icon: "ğŸŒ€",
      special: 1.8,
      unlockItem: "Bloodmoon Egg",
      materials: {
        "Chaotic Orb": 1,
        "Chaos Scroll": 1
      },
      moneyCost: 1_000_000_000_000_000_000_000n // 1SX
    },
    // === LEGENDARY RELICS (Step 4.4) ===
"Void Relic": {
  type: "Relics",
  icon: "ğŸŒŒğŸ“¿",
  special: 2.0,
  unlockItem: "Void Essence",
  materials: {
    "Void Essence": 5,
    "Void Shard": 3,
    "Obsidian Shard": 10,
    "Ancient Rune": 5
  },
  moneyCost: 100_000_000_000_000_000_000_000_000n // 100SP
},

"Dragon Relic": {
  type: "Relics",
  icon: "ğŸ‰ğŸ“¿",
  special: 2.2,
  unlockItem: "Dragon Essence",
  materials: {
    "Dragon Essence": 5,
    "Dragon Scale": 10,
    "Mythril Ingot": 5,
    "Celestial Dust": 10
  },
  moneyCost: 1_000_000_000_000_000_000_000_000_000n // 1OC
},

"Celestial Relic": {
  type: "Relics",
  icon: "âœ¨ğŸ“¿",
  special: 2.5,
  unlockItem: "Celestial Core",
  materials: {
    "Celestial Core": 3,
    "Celestial Dust": 20,
    "Ancient Tablet": 5,
    "Dragon Essence": 3,
    "Void Essence": 3
  },
  moneyCost: 10_000_000_000_000_000_000_000_000_000n // 10OC
},

"Mythril Relic": {
  type: "Relics",
  icon: "â›ï¸ğŸ“¿",
  special: 2.8,
  unlockItem: "Mythril Ingot",
  materials: {
    "Mythril Ingot": 10,
    "Dragon Scale": 20,
    "Void Shard": 5,
    "Celestial Core": 5,
    "Ancient Tablet": 3
  },
  moneyCost: 100_000_000_000_000_000_000_000_000_000n // 100OC
},

"Infinity Relic": {
  type: "Relics",
  icon: "â™¾ï¸ğŸ“¿",
  special: 3.0,
  unlockItem: "Ancient Tablet",
  materials: {
    "Ancient Tablet": 10,
    "Celestial Core": 10,
    "Mythril Ingot": 10,
    "Dragon Essence": 10,
    "Void Essence": 10
  },
  moneyCost: 1_000_000_000_000_000_000_000_000_000_000n // 1NO
},

"Enchanted Leviathan Relic": {
  type: "Relics",
  icon: "âœ¨ğŸŒŠğŸ“¿",
  special: 4.0, // BEST RELIC (4x money multiplier!)
  unlockItem: "Infinity Relic",
  materials: {
    "Infinity Relic": 1,
    "Enchanted Leviathan Heart": 5,
    "Enchanted Leviathan Fang": 3,
    "Enchanted Leviathan Scale": 10,
    "Celestial Core": 10,
    "Mythril Ingot": 10,
    "Ancient Tablet": 5
  },
  moneyCost: 10_000_000_000_000_000_000_000_000_000_000n // 10NO
},
    
    // === EGGS ===
    "Crafters Egg": {
      type: "Eggs",
      icon: "ğŸ”¨ğŸ¥š",
      special: 1,
      unlockItem: "Enchant Relic",
      materials: {
        "Celestial Egg": 1,
        "Night Egg": 1,
        "Scroll of the Egg": 1
      },
      moneyCost: 1_000_000_000_000_000_000_000_000_000n // 1NO
    },
    "Leviathan Egg": {
      type: "Eggs",
      icon: "ğŸŒŠğŸ¥š",
      special: 1,
      unlockItem: "Leviathan Scale",
      materials: {
        "Essence of Ice": 1,
        "Leviathan Scale": 1,
        "Scroll of Terror": 1
      },
      moneyCost: 1_000_000_000_000_000_000_000_000_000_000n // 1DC
    },
    // === MYTHIC EGGS (Step 4.5) ===
"Void Egg": {
  type: "Eggs",
  icon: "ğŸŒŒğŸ¥š",
  special: 1,
  unlockItem: "Void Essence",
  materials: {
    "Void Essence": 3,
    "Obsidian Shard": 5
  },
  moneyCost: 10_000_000_000_000_000_000_000_000n // 10SP
},

"Dragon Egg": {
  type: "Eggs",
  icon: "ğŸ‰ğŸ¥š",
  special: 1,
  unlockItem: "Dragon Essence",
  materials: {
    "Dragon Essence": 3,
    "Dragon Scale": 5
  },
  moneyCost: 100_000_000_000_000_000_000_000_000n // 100SP
},

"Celestial Egg": {
  type: "Eggs",
  icon: "âœ¨ğŸ¥š",
  special: 1,
  unlockItem: "Celestial Core",
  materials: {
    "Celestial Core": 2,
    "Celestial Dust": 10
  },
  moneyCost: 1_000_000_000_000_000_000_000_000_000n // 1OC
},

"Mythril Egg": {
  type: "Eggs",
  icon: "â›ï¸ğŸ¥š",
  special: 1,
  unlockItem: "Mythril Ingot",
  materials: {
    "Mythril Ingot": 5,
    "Dragon Scale": 10
  },
  moneyCost: 10_000_000_000_000_000_000_000_000_000n // 10OC
},

"Infinity Egg": {
  type: "Eggs",
  icon: "â™¾ï¸ğŸ¥š",
  special: 1,
  unlockItem: "Ancient Tablet",
  materials: {
    "Ancient Tablet": 5,
    "Celestial Core": 5,
    "Mythril Ingot": 5
  },
  moneyCost: 100_000_000_000_000_000_000_000_000_000n // 100OC
},

"Enchanted Leviathan Egg": {
  type: "Eggs",
  icon: "âœ¨ğŸŒŠğŸ¥š",
  special: 1,
  unlockItem: "Infinity Egg",
  materials: {
    "Infinity Egg": 1,
    "Enchanted Leviathan Heart": 3,
    "Enchanted Leviathan Scale": 5
  },
  moneyCost: 1_000_000_000_000_000_000_000_000_000_000n // 1NO
},
    // === SKINS ===
    "Leviathan Skin": {
      type: "Skins",
      icon: "ğŸŒŠğŸ’",
      special: 17,
      unlockItem: "Leviathan Pet",
      materials: {
        "Leviathan Egg": 1,
        "Scroll of Terror": 1,
        "Leviathan Scale": 3
      },
      moneyCost: 10_000_000_000_000_000_000_000_000_000_000n // 10DC
    },
    "Enchanted Leviathan Skin": {
      type: "Skins",
      icon: "âœ¨ğŸŒŠğŸ’",
      special: 18,
      unlockItem: "Leviathan Skin",
      materials: {
        "Leviathan Skin": 1,
        "Leviathan Armor": 1,
        "Enchanted Leviathan Heart": 1,
        "Scroll of the Enchanted": 1
      },
      moneyCost: 100_000_000_000_000_000_000_000_000_000_000n // 100DC
    },
    
    // === POTIONS ===
    "Crafters Potion": {
      type: "Potions",
      icon: "ğŸ”¨ğŸ§ª",
      special: 8,
      unlockItem: "Crafters Egg",
      materials: {
        "Crafters Egg": 1,
        "Divine Potion": 1
      },
      moneyCost: 1_000_000_000_000_000_000_000_000_000n // 1NO
    },
    
    // === TOTEMS ===
    "Leviathan Totem": {
      type: "Totems",
      icon: "ğŸŒŠâœ¨",
      special: 1,
      unlockItem: "Essence of Ice",
      materials: {
        "Essence of Ice": 1,
        "Shard of Ice": 1,
        "Freezing Scroll": 1
      },
      moneyCost: 1_000_000_000_000_000_000_000_000_000_000n // 1DC
    },
    
    // === CRAFTED ITEMS (Auto-unlocked) ===
    "Elemental Stone": {
      type: "Materials",
      icon: "ğŸ’",
      autoUnlock: true,
      materials: {
        "Stone": 10,
        "Elemental Essence": 1
      },
      moneyCost: 1_000_000_000_000_000_000_000_000n // 1OC
    },
    "Elemental Capsule": {
      type: "Materials",
      icon: "âš—ï¸",
      autoUnlock: true,
      materials: {
        "Empty Capsule": 1,
        "Fire Capsule": 1,
        "Ice Capsule": 1,
        "Lightning Capsule": 1,
        "Wind Capsule": 1,
        "Elemental Essence": 1
      },
      moneyCost: 100_000_000_000_000_000_000n // 100QI
    },
    "Scroll of Elements": {
      type: "Materials",
      icon: "ğŸ“œâœ¨",
      autoUnlock: true,
      materials: {
        "Empty Scroll": 1,
        "Fire Scroll": 1,
        "Ice Scroll": 1,
        "Lightning Scroll": 1,
        "Wind Scroll": 1
      },
      moneyCost: 1_000_000_000_000_000_000_000n // 1SX
    },
    "Fire Capsule": {
      type: "Materials",
      icon: "ğŸ”¥âš—ï¸",
      autoUnlock: true,
      materials: {
        "Empty Capsule": 1,
        "Essence of Fire": 10,
        "Shard of Fire": 1
      },
      moneyCost: 0n
    },
    "Ice Capsule": {
      type: "Materials",
      icon: "â„ï¸âš—ï¸",
      autoUnlock: true,
      materials: {
        "Empty Capsule": 1,
        "Essence of Ice": 10,
        "Shard of Ice": 1
      },
      moneyCost: 0n
    },
    "Lightning Capsule": {
      type: "Materials",
      icon: "âš¡âš—ï¸",
      autoUnlock: true,
      materials: {
        "Empty Capsule": 1,
        "Essence of Lightning": 10,
        "Shard of Lightning": 1
      },
      moneyCost: 0n
    },
    "Wind Capsule": {
      type: "Materials",
      icon: "ğŸ’¨âš—ï¸",
      autoUnlock: true,
      materials: {
        "Empty Capsule": 1,
        "Essence of Wind": 10,
        "Shard of Wind": 1
      },
      moneyCost: 0n
    },
    "Essence of Fire": {
      type: "Materials",
      icon: "ğŸ”¥",
      autoUnlock: true,
      materials: {
        "Empty Essence": 1,
        "Fire Scroll": 10
      },
      moneyCost: 0n
    },
    "Essence of Ice": {
      type: "Materials",
      icon: "â„ï¸",
      autoUnlock: true,
      materials: {
        "Empty Essence": 1,
        "Ice Scroll": 10
      },
      moneyCost: 0n
    },
    "Essence of Lightning": {
      type: "Materials",
      icon: "âš¡",
      autoUnlock: true,
      materials: {
        "Empty Essence": 1,
        "Lightning Scroll": 10
      },
      moneyCost: 0n
    },
    "Essence of Wind": {
      type: "Materials",
      icon: "ğŸ’¨",
      autoUnlock: true,
      materials: {
        "Empty Essence": 1,
        "Wind Scroll": 10
      },
      moneyCost: 0n
    },
    "Chaotic Orb": {
      type: "Materials",
      icon: "ğŸŒ€",
      autoUnlock: true,
      materials: {
        "Enchant Orb": 1,
        "Chaotic Scroll": 1
      },
      moneyCost: 100_000_000_000_000_000_000_000_000_000n // 100OC
    },
    "Chaos Scroll": {
      type: "Materials",
      icon: "ğŸ“œğŸŒ€",
      autoUnlock: true,
      materials: {
        "Chaotic Orb": 1,
        "Chaotic Scroll": 3
      },
      moneyCost: 0n
    },
    "Shard of Fire": {
      type: "Materials",
      icon: "ğŸ”¥ğŸ’",
      autoUnlock: true,
      materials: {
        "Shard": 10,
        "Essence of Fire": 10
      },
      moneyCost: 10_000_000_000_000_000_000_000_000n // 10SP
    },
    "Shard of Ice": {
      type: "Materials",
      icon: "â„ï¸ğŸ’",
      autoUnlock: true,
      materials: {
        "Shard": 10,
        "Essence of Ice": 10
      },
      moneyCost: 10_000_000_000_000_000_000_000_000n // 10SP
    },
    "Shard of Lightning": {
      type: "Materials",
      icon: "âš¡ğŸ’",
      autoUnlock: true,
      materials: {
        "Shard": 10,
        "Essence of Lightning": 10
      },
      moneyCost: 10_000_000_000_000_000_000_000_000n // 10SP
    },
    "Shard of Wind": {
      type: "Materials",
      icon: "ğŸ’¨ğŸ’",
      autoUnlock: true,
      materials: {
        "Shard": 10,
        "Essence of Wind": 10
      },
      moneyCost: 10_000_000_000_000_000_000_000_000n // 10SP
    },
    // === ADVANCED CRAFTED MATERIALS (Step 4.2) ===
"Void Essence": {
  type: "Materials",
  icon: "ğŸŒŒâœ¨",
  autoUnlock: true,
  materials: {
    "Empty Essence": 1,
    "Void Crystal": 5,
    "Obsidian Shard": 3
  },
  moneyCost: 10_000_000_000_000_000_000_000_000n // 10SP
},

"Dragon Essence": {
  type: "Materials",
  icon: "ğŸ‰âœ¨",
  autoUnlock: true,
  materials: {
    "Empty Essence": 1,
    "Dragon Scale": 5,
    "Mythril Ore": 2
  },
  moneyCost: 100_000_000_000_000_000_000_000_000_000n // 100OC
},

"Celestial Core": {
  type: "Materials",
  icon: "ğŸ’«ğŸ”®",
  autoUnlock: true,
  materials: {
    "Celestial Dust": 10,
    "Ancient Rune": 5,
    "Void Essence": 3
  },
  moneyCost: 1_000_000_000_000_000_000_000_000_000n // 1OC
},

"Mythril Ingot": {
  type: "Materials",
  icon: "â›ï¸ğŸ’",
  autoUnlock: true,
  materials: {
    "Mythril Ore": 10,
    "Dragon Scale": 5,
    "Obsidian Shard": 10
  },
  moneyCost: 10_000_000_000_000_000_000_000_000_000n // 10OC
},

"Ancient Tablet": {
  type: "Materials",
  icon: "ğŸ“¿âœ¨",
  autoUnlock: true,
  materials: {
    "Ancient Rune": 10,
    "Celestial Dust": 5,
    "Empty Scroll": 5
  },
  moneyCost: 100_000_000_000_000_000_000_000_000n // 100SP
},

"Void Shard": {
  type: "Materials",
  icon: "ğŸŒŒğŸ’",
  autoUnlock: true,
  materials: {
    "Void Crystal": 10,
    "Obsidian Shard": 20,
    "Shard": 15
  },
  moneyCost: 50_000_000_000_000_000_000_000_000n // 50SP
},
    // === MISCELLANEOUS (Auto-unlocked) ===
    "Harpoon": {
      type: "Miscellaneous",
      icon: "ğŸ”±",
      autoUnlock: true,
      materials: {
        "Stick": 10,
        "Anchor": 1,
        "Arrow": 1,
        "Essence of Ice": 1
      },
      moneyCost: 0n
    },
    "Leviathan Armor": {
      type: "Miscellaneous",
      icon: "ğŸ›¡ï¸",
      autoUnlock: true,
      materials: {
        "Leviathan Heart": 1,
        "Leviathan Scale": 10,
        "Enchanted Leviathan Scale": 1
      },
      moneyCost: 0n
    }
  }
};

const merchantShop = {
  "Stick": { icon: "ğŸªµ", price: 1_000_000n },
  "Stone": { icon: "ğŸª¨", price: 10_000_000n },
  "Anchor": { icon: "âš“", price: 100_000_000_000n },
  "Arrow": { icon: "â¤", price: 1_000_000_000n },
  "Empty Scroll": { icon: "ğŸ“œ", price: 1_000_000_000_000n },
  "Empty Capsule": { icon: "âš—ï¸", price: 10_000_000_000_000n },
  "Empty Essence": { icon: "âœ¨", price: 100_000_000_000_000n },
  "Fire Scroll": { icon: "ğŸ”¥ğŸ“œ", price: 1_000_000_000_000_000n },
  "Ice Scroll": { icon: "â„ï¸ğŸ“œ", price: 1_000_000_000_000_000n },
  "Lightning Scroll": { icon: "âš¡ğŸ“œ", price: 1_000_000_000_000_000n },
  "Wind Scroll": { icon: "ğŸ’¨ğŸ“œ", price: 1_000_000_000_000_000n },
  "Scroll of Fire": { icon: "ğŸ”¥ğŸ“œâœ¨", price: 10_000_000_000_000_000_000n },
  "Scroll of the Egg": { icon: "ğŸ¥šğŸ“œ", price: 100_000_000_000_000_000_000_000_000_000n },
  "Scroll of Terror": { icon: "ğŸ˜±ğŸ“œ", price: 100_000_000_000_000_000_000_000_000_000n },
  "Scroll of the Enchanted": { icon: "âœ¨ğŸ“œ", price: 10_000_000_000_000_000_000_000_000_000_000n },
  "Freezing Scroll": { icon: "â„ï¸ğŸ“œâœ¨", price: 100_000_000_000_000_000_000_000_000_000n },
  "Enchant Orb": { icon: "ğŸ”®", price: 10_000_000_000_000_000_000_000_000_000n },
  "Chaotic Scroll": { icon: "ğŸŒ€ğŸ“œ", price: 10_000_000_000_000_000_000_000_000_000n },
  "Shard": { icon: "ğŸ’", price: 1_000_000_000_000_000_000_000n },
  "Phoenix Tear": { icon: "ğŸ’§", price: 100_000_000_000_000_000_000_000_000n },
  "Divine Potion": { icon: "âœ¨ğŸ§ª", price: 100_000_000_000_000_000_000_000_000n },
  
  // NEW STEP 4 MATERIALS
  "Obsidian Shard": { icon: "ğŸ–¤ğŸ’", price: 1_000_000_000_000_000_000_000_000n }, // 1SP
  "Void Crystal": { icon: "ğŸŒŒğŸ’", price: 10_000_000_000_000_000_000_000_000n }, // 10SP
  "Ancient Rune": { icon: "ğŸ“¿", price: 100_000_000_000_000_000_000_000_000n }, // 100SP
  "Celestial Dust": { icon: "âœ¨ğŸ’«", price: 1_000_000_000_000_000_000_000_000_000n }, // 1OC
  "Dragon Scale": { icon: "ğŸ‰", price: 10_000_000_000_000_000_000_000_000_000n }, // 10OC
  "Mythril Ore": { icon: "â›ï¸", price: 100_000_000_000_000_000_000_000_000_000n } // 100OC
};
// Admin Abuse event state
let currentAdminEvent = null;
let adminEventTimer = null;
let adminEventParticles = [];
let adminEventOverlayAlpha = 0;
let adminEventShakeX = 0;
let adminEventShakeY = 0;

const ctx = canvas.getContext('2d');

const W = canvas.width, H = canvas.height;
// === BOSS ENTITIES (MUST BE DECLARED EARLY) ===
const boss = {
  x: 0, y: 0, w: 96, h: 96, // placeholder, will use character.w later
  color: "#3b1f00",
  emoji: "â˜ ï¸",
  visible: false,
  hitsToDie: 10,
  hitsRemaining: 10,
  playerHits: 0,
  speed: 325, // placeholder, will use character.speed later
  aoeRadius: 80,
  spawnX: 0,
  spawnY: 0,
};

const phoenixBoss = {
  x: 0, y: 0, w: 96, h: 96, // placeholder
  color: "#FF4500",
  emoji: "ğŸ”¥",
  visible: false,
  hitsToDie: 25,
  hitsRemaining: 25,
  playerHits: 0,
  speed: 275, // placeholder
  longRangeRadius: 150,
  spawnX: 0,
  spawnY: 0,
  nestX: 0,
  nestY: 0,
  ignoreMistletoe: true
};

const tornado = {
  x: 0,
  y: 0,
  w: 80,
  h: 80,
  speed: 325, // placeholder
  visible: false,
  angle: 0
};

// === LEVIATHAN BOSS CONFIGURATION ===
const leviathanBoss = {
  x: 0,
  y: 0,
  w: 120,
  h: 120,
  color: "#1E90FF",
  emoji: "ğŸŒŠ",
  visible: false,
  hitsToDie: 50,
  hitsRemaining: 50,
  playerHits: 0,
  playerMaxHP: 5,
  playerCurrentHP: 5,
  speed: 200,
  longRangeRadius: 200,
  attackCooldown: false,
  flash: false,
  enchanted: false,
  canSummonEnchanted: false,
  enchantedSummonTimer: 0
};

const enchantedLeviathanBoss = {
  x: 0,
  y: 0,
  w: 140,
  h: 140,
  color: "#9370DB",
  emoji: "âœ¨ğŸŒŠ",
  visible: false,
  hitsToDie: 100,
  hitsRemaining: 100,
  playerHits: 0,
  speed: 180,
  longRangeRadius: 220,
  attackCooldown: false,
  flash: false
};

// Forgotten Altar event
const forgottenAltar = {
  active: false,
  duration: 0,
  incomeBoost: 1.0,
  background: "radial-gradient(circle at center, #B0E0E6 0%, #4682B4 50%, #1E90FF 100%)",
  overlay: "rgba(176, 224, 230, 0.3)"
};

// Player harpoon
const harpoon = {
  equipped: false,
  damage: 3,
  cooldown: 1000, // 1 second
  lastUse: 0
};
const CUBE_SIZE = 48;
const CUBE_SPACING = 18;
const CUBE_COUNT = 8;
const TOP_Y = 30;

const moneyDisplay = document.getElementById('moneyDisplay');
const incomeDisplay = document.getElementById('incomeDisplay');
const houseDisplay = document.getElementById('houseDisplay');
const legendContainer = document.getElementById('legendContainer');
const upgradeBtn = document.getElementById('upgradeBtn');
const downgradeBtn = document.getElementById('downgradeBtn');
const tierHint = document.getElementById('tierHint');

let cubeTier = 0; // 0 = base, 1 = tier 2, 2 = tier 3

let currentWeather = null;
let weatherTimer = null;
let weatherMultiplier = 1; // affects income
let speedMultiplier = 1;   // affects movement
let weatherOverlayAlpha = 0;

let weatherParticles = [];

// put this at top-level, once
let equippedCategory = null;

// make equipCategory callable from inline onclick in the generated HTML
window.equipCategory = function(cat) {
  // toggle: equip if different, unequip if same
  equippedCategory = (equippedCategory === cat) ? null : cat;
  // refresh inventory UI
  updateInventoryDisplay();
};

let equippedItems = {}; // e.g. { Swords: "Iron Sword", Relics: "Magic Relic" }


let equippedSwordSpecial = 0;
let equippedRelicSpecial = 1;
let equippedEggSpecial = 0;
let equippedSkinSpecial = 1;
let equippedPotionSpecial = 1;

// Potion event state
let potionActive = false;
let potionMultiplier = 1;
let potionEndTime = 0;

let swordicon ="";

const skins = {
  1: { color: "#ff2b2b" },
  2: { color: "#4d7cff" },
  3: { color: "#a45ee5" },
  4: { color: "#ffd700" },
  5: { color: "#e9ecef" },
  6: { color: "#FFF917" }, // Sunny
  7: { color: "#312F36" }, // Night
  8: { color: "#DC143C" }, // Santa Red
  9: { color: "#32CD32" }, // Elf Green
  10: { color: "#228B22" }, // Christmas Tree Green
  11: { color: "#1a0a33" }, // Galaxy
  12: { color: "#00ff00" }, // Glitched
  13: { color: "#ff00ff" }, // Disco
  14: { color: "#8B0000" }, // Bloodmoon
  15: { color: "#FFFACD" }, // Heavenly
  16: { color: "#9370DB" }  // Enchant - NEW
};
// Global pet ability flags
window.giftDropMultiplier = 1.0;
window.healingShieldActive = false;
window.luckyStarActive = false;
window.luckyStarMultiplier = 1.0;

window.equipItem = function equipItem(category, itemName) {
  // Find item in player inventory
  const inventoryCategory = playerInventory[category];
  if (!inventoryCategory) {
    console.error("Category not found:", category);
    return;
  }
  
  const item = inventoryCategory.find(i => i.name === itemName);
  if (!item) {
    console.error("Item not found:", itemName);
    return;
  }

  // Assign special values to corresponding global variable
  switch (category) {
    case "Swords":
      equippedSwordSpecial = item.special || 0;
      swordicon = item.icon;
      break;
    case "Relics":
      equippedRelicSpecial = item.special || 1;
      break;
    case "Eggs":
      equippedEggSpecial = item.special || 0;
      break;
    case "Skins":
      equippedSkinSpecial = item.special || 1;
      // Update character color based on skin
      if (skins[equippedSkinSpecial]) {
        character.color = skins[equippedSkinSpecial].color;
      }
      break;
    case "Potions":
      equippedPotionSpecial = item.special || 1;
      activatePotionEvent(item.special);
      break;
  }

  // Mark as equipped in inventory
  playerInventory[category].forEach(i => i.equipped = (i.name === itemName));

  console.log(`âœ… Equipped ${item.name} (${category}) â€” special: ${item.special}`);
  recomputeIncome(); // Recalculate with new equipment
  updateInventoryDisplay();
  html += `<span style="color:#aaa;">Equipped: ${equippedPets.length}/${maxPetSlots}</span>`;
}

// Draw pets following the character
function renderPets(ctx) {
  equippedPets.forEach(pet => {
    // Draw pet body
    ctx.fillStyle = pet.color;
    ctx.fillRect(pet.x, pet.y, 32, 32); // Smaller than character (48x48)
    
    // Draw pet icon
    ctx.font = '20px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(pet.icon, pet.x + 16, pet.y + 16);
    
    // Draw mutation indicator if exists
    if (pet.mutation) {
      const mut = petMutations[pet.mutation];
      ctx.font = '12px sans-serif';
      ctx.fillText(mut.emoji, pet.x + 26, pet.y + 6);
    }
  });
}


// === WEATHER LIST ===
const weatherEvents = [
  {
    name: "Rain",
    duration: 60_000, // lasts 1 min
    incomeBoost: 1.05,
    speedBoost: 1.0,
    bg: "linear-gradient(#445, #223)",
    overlay: "rgba(100,150,255,0.2)"
  },
  {
    name: "Wind",
    duration: 60_000,
    incomeBoost: 1.0,
    speedBoost: 1.05,
    bg: "linear-gradient(#ccd, #889)",
    overlay: "rgba(200,200,255,0.15)"
  },
  {
    name: "Thunder",
    duration: 60_000,
    incomeBoost: 1.10,
    speedBoost: 1.0,
    bg: "linear-gradient(#222, #000)",
    overlay: "rgba(255,255,150,0.25)"
  }
];
// Event emoji mapping
const eventEmojis = {
  "Wind": "ğŸ’¨",
  "Rain": "ğŸŒ§ï¸",
  "Thunder": "â›ˆï¸",
  "Blackhole": "âš«",
  "Hurricane": "ğŸŒ€",
  "Disco": "ğŸª©",
  "Volcano": "ğŸŒ‹",
  "Earthquake": "ğŸ«¨",
  "Glitched": "âšœï¸",
  "Galactic": "ğŸš€",
  "Phoenix Nest": "ğŸ”¥",
  "Bloodmoon": "ğŸŒ•",
  "Tornado": "ğŸŒªï¸",
  "Heavenly": "âœ¨" // NEW
};
function nvl(value, defaultValue) {
return value == null ? defaultValue : value;
}


function updateEnchantUI() {
  const enchantHint = document.getElementById('enchantHint');
  if (!enchantHint) return;
  
  if (enchantmentSystem.unlocked) {
    enchantHint.style.display = 'block';
    enchantHint.textContent = `ğŸ”® Enchants: ${enchantmentSystem.totalEnchants}`;
    
    if (enchantmentSystem.hasEnchantRelic) {
      enchantHint.textContent += ` | ğŸ€ Relic Active`;
    }
  } else {
    enchantHint.style.display = 'none';
  }
}
/**
Purpose:
Updates the HTML inventory UI (#inventoryList) to show:
Playerâ€™s current drops (bones, relics, skins, cubes).
All purchased shop items by category.
Key Behavior:

Builds HTML dynamically with item icons and current counts.
Pulls data from dropCounters, dropLimits, and playerInventory.
 * @returns {void}
 */
function updateInventoryDisplay() {
  //const inv = document.getElementById('inventoryDisplay');
  const inv = document.getElementById("inventoryList");
  let html = ""; // â† ADD THIS LINE
  const bossOpen = document.getElementById("detailsBossDrops")?.open ?? true;
  const shopOpen = document.getElementById("detailsShopPurchases")?.open ?? true;

  if (!inv) return;

  
// --- Boss Drops Section ---
html += `
   <div id="bossDropsContainer">
  <details id="detailsBossDrops" open style="margin-top:8px;">
    <summary style="cursor:pointer; font-weight:bold; color:#00ccff;">ğŸ“¦ Boss Drops</summary>
    <div style="margin-left:10px; margin-top:5px;">
      ğŸ¦´ Skeleton Bones: ${nvl(dropCounters["ğŸ¦´ Skeleton Bones"],0)}/${dropLimits.bones}<br>
      ğŸ“¿ Crossbones Relic: ${nvl(dropCounters["ğŸ“¿ Crossbones Relic"],0)}/${dropLimits.relic}<br>
      â¬œğŸ’€ Skeleton Skin: ${nvl(dropCounters["â¬œğŸ’€ Skeleton Skin"],0)}/${dropLimits.skin}<br>
      â¬œâ˜ ï¸ Crossbones Cube: ${nvl(dropCounters["â¬œâ˜ ï¸ Crossbones Cube"],0)}/${dropLimits.cube}<br>
      â„ï¸ Snowflakes: ${nvl(dropCounters["â„ï¸ Snowflakes"],0)}/âˆ<br>
    </div>
  </details>
   </div>
`;


  // --- Shop Inventory ---
  //html += `<b>Shop Purchases</b><br>`;
// --- Shop Inventory ---
html += '<div id="shopPurchasesContainer"><details id="detailsShopPurchases" open style="margin-top:8px;"><summary style="cursor:pointer; font-weight:bold; color:#ffcc00;">ğŸ›’ Shop Purchases</summary><div style="margin-left:10px; margin-top:5px;"><div>';

const categories = ["Swords", "Relics", "Eggs", "Skins", "Potions", "Totems", "Miscellaneous"];

categories.forEach(cat => {
  const items = playerInventory[cat];
  if (!items || items.length === 0) return;

  html += `<u>${cat}</u><br>`;

  // ONLY ONE forEach loop here
  playerInventory[cat].forEach(item => {
    const limit = (cat === "Eggs" || cat === "Potions") ? 999 : 1;
    const isEquipped = !!item.equipped;

    // Get the correct special value for this category
    let equippedSpecial = 0;
    switch (cat) {
      case "Swords":   equippedSpecial = equippedSwordSpecial; break;
      case "Relics":   equippedSpecial = equippedRelicSpecial; break;
      case "Eggs":     equippedSpecial = equippedEggSpecial; break;
      case "Skins":    equippedSpecial = equippedSkinSpecial; break;
      case "Potions":  equippedSpecial = equippedPotionSpecial; break;
    }

    // Use item.special if it exists, otherwise show equipped value
    const displaySpecial = item.special || equippedSpecial;

    // Build the button label
    const btnLabel = isEquipped ? `Equipped (â­${displaySpecial})` : 'Equip';

    // Display the item
    html += `${item.icon} ${item.name}: ${item.count}/${limit}`;

    // Add Equip button for non-eggs
    if (cat !== "Eggs") {
      html += `
        <button
          onclick="equipItem('${cat}', '${item.name}')"
          style="
            margin-left:5px; 
            padding:2px 6px; 
            border-radius:5px; 
            background:${isEquipped ? '#28a745' : '#333'}; 
            color:white; 
            border:none; 
            cursor:pointer;
          ">
          ${btnLabel}
        </button>`;
    }

// Add Use button for Heavenly Totem
    if (item.name === "Heavenly Totem" && item.count > 0) {
      html += `
        <button
          onclick="useHeavenlyTotem()"
          style="
            margin-left:5px; 
            padding:2px 6px; 
            border-radius:5px; 
            background:#FFD700; 
            color:white; 
            border:none; 
            cursor:pointer;
          ">
          Use âœ¨
        </button>`;
    }
    
    // NEW: Add Use button for Harpoon
    if (item.name === "Harpoon") {
      const harpoonCount = craftingSystem.materials["Harpoon"] || 0;
      if (harpoonCount > 0) {
        html += ` (${harpoonCount} in materials)`;
      }
    }
    
    // NEW: Add Use button for Leviathan Armor
    if (item.name === "Leviathan Armor") {
      const armorCount = craftingSystem.materials["Leviathan Armor"] || 0;
      if (armorCount > 0) {
        html += `
          <button
            onclick="equipLeviathanArmor()"
            style="
              margin-left:5px; 
              padding:2px 6px; 
              border-radius:5px; 
              background:#4682B4; 
              color:white; 
              border:none; 
              cursor:pointer;
            ">
            Equip ğŸ›¡ï¸ (${armorCount})
          </button>`;
      }
    }
    // NEW: Add Use button for Leviathan Totem
if (item.name === "Leviathan Totem") {
  const totemCount = craftingSystem.materials["Leviathan Totem"] || 0;
  if (totemCount > 0) {
    html += `
      <button
        onclick="useLeviathanTotem()"
        style="
          margin-left:5px; 
          padding:2px 6px; 
          border-radius:5px; 
          background:#1E90FF; 
          color:white; 
          border:none; 
          cursor:pointer;
        ">
        Use ğŸŒŠ (${totemCount})
      </button>`;
  }
}
// NEW: Add Use button for Enchant Relic
if (item.name === "Enchant Relic" && item.count > 0) {
  html += `
    <button
      onclick="useEnchantRelic()"
      style="
        margin-left:5px; 
        padding:2px 6px; 
        border-radius:5px; 
        background:#32CD32; 
        color:white; 
        border:none; 
        cursor:pointer;
      ">
      Use ğŸ€
    </button>`;
}

// Add Open buttons for eggs
if (cat === "Eggs" && item.count > 0) {
  html += `
    <button
      onclick="openEggFromInventory('${item.name}', 1)"
      style="
        margin-left:5px; 
        padding:2px 6px; 
        border-radius:5px; 
        background:#FFA500; 
        color:white; 
        border:none; 
        cursor:pointer;
      ">
      Open 1
    </button>`;

  if (item.count >= 10) {
    html += `
      <button
        onclick="openEggFromInventory('${item.name}', 10)"
        style="
          margin-left:5px; 
          padding:2px 6px; 
          border-radius:5px; 
          background:#FF8C00; 
          color:white; 
          border:none; 
          cursor:pointer;
        ">
        Open 10
      </button>`;
  }
}

    html += `<br>`;
  }); // END of the ONE AND ONLY forEach loop

  html += `<br>`;
});
// --- Pet Inventory (ONLY ONE SECTION) ---
html += '<div style="margin-top:15px;"><u>ğŸ¾ Pets</u><br>';

if (playerPets.length === 0) {
  html += '<span style="color:#888;">No pets yet. Buy eggs to hatch pets!</span><br>';
} else {
  html += `<span style="color:#aaa;">Equipped: ${equippedPets.length}/${maxPetSlots}</span>`;
  
  // Add bulk delete button
  html += `<button onclick="bulkDeletePets()" style="margin-left:10px;padding:2px 8px;border-radius:5px;background:#dc3545;color:white;border:none;cursor:pointer;">ğŸ—‘ï¸ Delete All Unequipped</button><br>`;
  
// Add search bar with tips
html += `
  <div style="margin-top:8px;margin-bottom:8px;">
    <input 
      type="text" 
      id="petSearchInput" 
      placeholder="ğŸ” Search pets..." 
      style="padding:4px 8px;border-radius:5px;border:1px solid #555;background:#222;color:white;width:200px;"
      oninput="filterPets(this.value)"
    />
    <button 
      onclick="clearPetSearch()" 
      style="margin-left:5px;padding:4px 8px;border-radius:5px;background:#555;color:white;border:none;cursor:pointer;">
      Clear
    </button>
    <br>
    <span style="font-size:10px;color:#888;margin-left:2px;">
      ğŸ’¡ Search: name, ability, mutation, egg type<br>
      Special: "equipped", "unequipped", "mutated", "enchanted", "christmas"<br>
      Enchant types: "money", "luck", "speed", "damage", "ultimate"
    </span>
  </div>
`;
  
  // Pet list container
  html += '<div id="petListContainer">';
  
playerPets.forEach(pet => {
  const mutationText = pet.mutation ? ` [${petMutations[pet.mutation].emoji} ${pet.mutation}]` : '';
  
  // NEW: Add enchantment display
  let enchantText = '';
  if (pet.enchantment) {
    const icon = enchantmentTypes[pet.enchantment.type].icon;
    enchantText = ` ${icon}${pet.enchantment.tier}`;
  }
  
  const equippedBtn = pet.equipped 
    ? '<button onclick="togglePetEquip(' + pet.id + ')" style="margin-left:5px;padding:2px 6px;border-radius:5px;background:#28a745;color:white;border:none;cursor:pointer;">âœ“ Equipped</button>'
    : '<button onclick="togglePetEquip(' + pet.id + ')" style="margin-left:5px;padding:2px 6px;border-radius:5px;background:#333;color:white;border:none;cursor:pointer;">Equip</button>';
  
  const deleteBtn = '<button onclick="deletePet(' + pet.id + ')" style="margin-left:5px;padding:2px 6px;border-radius:5px;background:#dc3545;color:white;border:none;cursor:pointer;">ğŸ—‘ï¸</button>';
  
  // NEW: Add Enchant button (only if unlocked)
  console.log("Enchantment unlocked?", enchantmentSystem.unlocked); // DEBUG
  const enchantBtn = enchantmentSystem.unlocked 
    ? '<button onclick="enchantPet(' + pet.id + ')" style="margin-left:5px;padding:2px 6px;border-radius:5px;background:#9370DB;color:white;border:none;cursor:pointer;">ğŸ”® Enchant</button>'
    : '';
  
  html += `<div class="pet-item" data-pet-name="${pet.name.toLowerCase()}" data-pet-ability="${pet.ability.toLowerCase()}" data-pet-mutation="${(pet.mutation || '').toLowerCase()}" data-pet-egg="${(pet.eggType || '').toLowerCase()}">`;
  html += `${pet.icon} ${pet.name}${mutationText}${enchantText} ${equippedBtn} ${enchantBtn} ${deleteBtn}<br>`;
  html += `<span style="font-size:11px;color:#888;margin-left:20px;">${pet.description}</span><br>`;
  html += `</div>`;
});
  
  html += '</div>'; // Close petListContainer
}

html += '</div>';
  html += '</div></details>';
  // Save current search value before updating
const searchInput = document.getElementById('petSearchInput');
const currentSearchValue = searchInput ? searchInput.value : '';
  inv.innerHTML = html;
  document.getElementById("detailsBossDrops").open = bossOpen;
  document.getElementById("detailsShopPurchases").open = shopOpen;

// Restore search value after updating
const newSearchInput = document.getElementById('petSearchInput');
if (newSearchInput && currentSearchValue) {
  newSearchInput.value = currentSearchValue;
  filterPets(currentSearchValue);
}
}

// --- Equip logic ---
function equipCategory(cat) {
  equippedCategory = (equippedCategory === cat) ? null : cat;
  updateInventoryDisplay();
}

/**
 * Adds one item of the specified type to the player's inventory.
 * If the item does not already exist in the player's inventory, it will be added with a count of 1.
 * If the item already exists, its count will be incremented by 1.
 * The function will also update the inventory display in the game UI after adding the item.
 * @param {string} itemName - The name of the item to add to the player's inventory.
 * @returns {void}
 */
function addToInventory(itemName) {
  if (!drops[itemName]) drops[itemName] = 0; // ensure item exists
  const limits = {
    "ğŸ—¡ï¸ Sword I": 999n,
    "ğŸ—¡ï¸ Sword II": 999n,
    "ğŸ—¡ï¸ Sword III": 999n,
    "ğŸ—¡ï¸ Sword IV": 999n,
    "ğŸ—¡ï¸ Sword V": 999n,
    "ğŸ“¿ Relic I": 1n,
    "ğŸ“¿ Relic II": 1n,
    "ğŸ“¿ Relic III": 1n,
    "ğŸ“¿ Relic IV": 1n,
    "ğŸ“¿ Relic V": 1n,
    "ğŸ¥š Egg I": 999n,
    "ğŸ¥š Egg II": 999n,
    "ğŸ¥š Egg III": 999n,
    "ğŸ¥š Egg IV": 999n,
    "ğŸ¥š Egg V": 999n,
    "ğŸ’ Skin I": 1n,
    "ğŸ’ Skin II": 1n,
    "ğŸ’ Skin III": 1n,
    "ğŸ’ Skin IV": 1n,
    "ğŸ’ Skin V": 1n,
    "ğŸ§ª Potion I": 999n,
    "ğŸ§ª Potion II": 999n,
    "ğŸ§ª Potion III": 999n,
    "ğŸ§ª Potion IV": 999n,
    "ğŸ§ª Potion V": 999n,
  };
  
  const limit = limits[itemName] ?? 999n;
  if (BigInt(drops[itemName]) < limit) {
    drops[itemName] = BigInt(drops[itemName]) + 1n;
    updateInventoryDisplay();
  }
}
// ADD THIS ENTIRE FUNCTION HERE (before updateShopDisplay)
function buyItem(category, index, skipOdds = false) {
  const item = shopItems[category][index];
  if (!item) {
    console.error("Item not found:", category, index);
    return;
  }

  const limit = (category === "Eggs" || category === "Potions") ? 999n : 1n;
  
  const inventoryKey = item.name;
  const owned = BigInt(inventory[inventoryKey] || 0n);

  if (owned >= limit) {
    alert(`You already own the maximum number of ${item.name}s!`);
    return;
  }

  if (money < item.price) {
    alert(`Not enough money to buy ${item.name}!`);
    return;
  }

  // === Show egg odds before purchase (unless shift is held) ===
  if (category === "Eggs" && !skipOdds) {
    const oddsInfo = showEggOdds(item.name);
    const confirmPurchase = confirm(`${oddsInfo}\nPurchase ${item.name} for ${formatBigInt(item.price)}?`);
    
    if (!confirmPurchase) {
      return; // User cancelled
    }
  }

  money -= item.price;
  inventory[inventoryKey] = owned + 1n;

  const existing = playerInventory[category].find(i => i.name === item.name);
  if (existing) {
    existing.count++;
  } else {
    playerInventory[category].push({
      icon: item.icon,
      name: item.name,
      count: 1,
      special: item.special
    });
  }

  // REMOVED: Eggs should NOT auto-open on purchase
  // They should be opened from inventory instead

  updateDisplays();
  updateInventoryDisplay();
}

// Show egg odds before purchase
// Display pet odds for an egg type
function showEggOdds(eggType) {
  const pets = petDatabase[eggType];
  if (!pets) {
    return "Unknown egg type";
  }
  
  let oddsText = `ğŸ¥š ${eggType} Contents:\n\n`;
  
  // Sort pets by chance descending for better display
  const sortedPets = [...pets].sort((a, b) => b.chance - a.chance);
  
  sortedPets.forEach(pet => {
    const percentage = (pet.chance * 100).toFixed(2);
    oddsText += `${pet.icon} ${pet.name}\n`;
    oddsText += `   ${pet.description}\n`;
    oddsText += `   Chance: ${percentage}%\n\n`;
  });
  
  return oddsText;
}
function updateShopDisplay() {
  const shopContainer = document.getElementById('shopContainer');
  if (!shopContainer) return;
  shopContainer.innerHTML = "<div class='legend-label'>ğŸª SHOP</div>";

  const purchaseLimits = {
    Swords: 1,
    Relics: 1,
    Eggs: 999,
    Skins: 1,
    Potions: 999
  };

  // ========== REGULAR SHOP ITEMS ==========
  for (const [category, items] of Object.entries(shopItems)) {
    const row = document.createElement('div');
    row.style.display = "flex";
    row.style.gap = "10px";
    row.style.marginTop = "8px";
    row.innerHTML = `<strong style='min-width:70px'>${category}:</strong>`;

    items.forEach((item, index) => {
      // Skip ascension-only, rebirth-locked, and enchant-only items
      if (item.ascensionOnly || item.rebirthLocked || item.enchantOnly) {
        return; // Don't show these items
      }
      
      const btn = document.createElement('button');
      btn.innerText = `${item.icon} ${item.name}\nğŸ’°${shortLabel(item.price)}`;
      btn.style.display = "flex";
      btn.style.flexDirection = "column";
      btn.style.alignItems = "center";
      btn.style.justifyContent = "center";
      btn.style.fontSize = "10px";
      btn.style.padding = "4px 6px";
      btn.style.background = "#4a3000";
      btn.style.border = "1px solid #FFD700";

      btn.onclick = (e) => {
        if (category === "Eggs" && e.shiftKey) {
          buyItem(category, index, true); // Skip odds when shift is held
        } else {
          buyItem(category, index, false); // Show odds normally
        }
      };

      row.appendChild(btn);
    });
    
    // Only append the row if it has items
    if (row.children.length > 1) {
      shopContainer.appendChild(row);
    }
  }

  // ========== DAY/NIGHT EVENT SHOPS ==========
  for (const [eventKey, eventShop] of Object.entries(eventShops)) {
    if (eventShop.activeWhen()) {
      const separator = document.createElement('div');
      separator.style.marginTop = "15px";
      separator.style.borderTop = "2px solid rgba(255,255,255,0.2)";
      separator.style.paddingTop = "10px";
      shopContainer.appendChild(separator);

      const eventTitle = document.createElement('div');
      eventTitle.className = 'legend-label';
      eventTitle.textContent = eventShop.displayName;
      eventTitle.style.color = "#FFD700";
      shopContainer.appendChild(eventTitle);

      for (const [category, items] of Object.entries(eventShop.items)) {
        const row = document.createElement('div');
        row.style.display = "flex";
        row.style.gap = "10px";
        row.style.marginTop = "8px";
        row.innerHTML = `<strong style='min-width:70px;color:#FFD700'>${category}:</strong>`;

        items.forEach((item) => {
          const btn = document.createElement('button');
          btn.innerText = `${item.icon} ${item.name}\nğŸ’°${shortLabel(item.price)}`;
          btn.style.display = "flex";
          btn.style.flexDirection = "column";
          btn.style.alignItems = "center";
          btn.style.justifyContent = "center";
          btn.style.fontSize = "10px";
          btn.style.padding = "4px 6px";
          btn.style.background = "#4a3000";
          btn.style.border = "1px solid #FFD700";

          btn.onclick = (e) => {
            if (category === "Eggs" && e.shiftKey) {
              buyEventItem(eventKey, category, item, true); // Skip odds
            } else {
              buyEventItem(eventKey, category, item, false); // Show odds
            }
          };

          row.appendChild(btn);
        });

        shopContainer.appendChild(row);
      }
    }
  }

  // ========== CHRISTMAS SHOP (only when event active) ==========
  if (christmasEvent.active) {
    const separator = document.createElement('div');
    separator.style.marginTop = "15px";
    separator.style.borderTop = "2px solid #DC143C";
    separator.style.paddingTop = "10px";
    shopContainer.appendChild(separator);

    const christmasTitle = document.createElement('div');
    christmasTitle.className = 'legend-label';
    christmasTitle.textContent = 'ğŸ„ Christmas Shop ğŸ„';
    christmasTitle.style.color = "#DC143C";
    shopContainer.appendChild(christmasTitle);

    for (const [category, items] of Object.entries(christmasShopItems)) {
      const row = document.createElement('div');
      row.style.display = "flex";
      row.style.gap = "10px";
      row.style.marginTop = "8px";
      row.innerHTML = `<strong style='min-width:70px;color:#DC143C'>${category}:</strong>`;

      items.forEach((item) => {
        const btn = document.createElement('button');
        btn.innerText = `${item.icon} ${item.name}\nğŸ’°${shortLabel(item.price)}`;
        btn.style.display = "flex";
        btn.style.flexDirection = "column";
        btn.style.alignItems = "center";
        btn.style.justifyContent = "center";
        btn.style.fontSize = "10px";
        btn.style.padding = "4px 6px";
        btn.style.background = "#8B0000";
        btn.style.border = "1px solid #DC143C";

        btn.onclick = (e) => {
          if (category === "Eggs" && e.shiftKey) {
            buyChristmasItem(category, item, true); // Skip odds
          } else {
            buyChristmasItem(category, item, false); // Show odds
          }
        };

        row.appendChild(btn);
      });

      shopContainer.appendChild(row);
    }
  }
}
// Buy Christmas shop items
// Buy Christmas shop items
function buyChristmasItem(category, item, skipOdds = false) {
  const limit = (category === "Eggs" || category === "Potions") ? 999n : 1n;
  const inventoryKey = item.name;
  
  // Count current inventory amount properly
  let owned = 0n;
  const existing = playerInventory[category]?.find(i => i.name === item.name);
  if (existing) {
    owned = BigInt(existing.count);
  }

  if (owned >= limit) {
    alert(`You already own the maximum number of ${item.name}s!`);
    return;
  }
// === EGGS: Show odds before purchase (unless shift is held) ===
if (category === "Eggs" && !skipOdds) {
  const oddsInfo = showEggOdds(item.name);
  const confirmPurchase = confirm(`${oddsInfo}\nPurchase ${item.name} for ${formatBigInt(item.price)}?`);
  
  if (!confirmPurchase) {
    return; // User cancelled
  }
}
  if (money < item.price) {
    alert(`Not enough money to buy ${item.name}!`);
    return;
  }

  // === EGGS: Show odds before purchase (unless shift is held) ===
  if (category === "Eggs" && !skipOdds) {
    const oddsInfo = showEggOdds(item.name);
    const confirmPurchase = confirm(`${oddsInfo}\nPurchase ${item.name} for ${formatBigInt(item.price)}?`);
    
    if (!confirmPurchase) {
      return; // User cancelled
    }
  }

  money -= item.price;

  if (existing) {
    existing.count++;
  } else {
    playerInventory[category].push({
      icon: item.icon,
      name: item.name,
      count: 1,
      special: item.special
    });
  }

  // Special handling for snowflakes
  if (category === "Decorations") {
    christmasEvent.snowCollected += item.special;
    dropCounters["â„ï¸ Snowflakes"] += item.special;
    inventory["â„ï¸ Snowflakes"] += item.special;
  }

  updateDisplays();
  updateInventoryDisplay();
  updateShopDisplay();
}

window.buyChristmasItem = buyChristmasItem;

window.buyChristmasItem = buyChristmasItem;
function buyEventItem(eventKey, category, item, skipOdds = false) {
  const limit = (category === "Eggs" || category === "Potions") ? 999n : 1n;
  const inventoryKey = item.name;
  const owned = BigInt(inventory[inventoryKey] || 0n);

  if (owned >= limit) {
    alert(`You already own the maximum number of ${item.name}s!`);
    return;
  }

  if (money < item.price) {
    alert(`Not enough money to buy ${item.name}!`);
    return;
  }

  // === EGGS: Show odds before purchase (unless shift is held) ===
  if (category === "Eggs" && !skipOdds) {
    const oddsInfo = showEggOdds(item.name);
    const confirmPurchase = confirm(`${oddsInfo}\nPurchase ${item.name} for ${formatBigInt(item.price)}?`);
    
    if (!confirmPurchase) {
      return; // User cancelled
    }
  }

  money -= item.price;
  inventory[inventoryKey] = owned + 1n;

  const existing = playerInventory[category].find(i => i.name === item.name);
  if (existing) {
    existing.count++;
  } else {
    playerInventory[category].push({
      icon: item.icon,
      name: item.name,
      count: 1,
      special: item.special
    });
  }

  // Eggs: Open immediately and hatch a pet
  if (category === "Eggs") {
    const pet = openEgg(item.name);
    if (pet) {
      const mutationText = pet.mutation ? `\n\nğŸ‰ MUTATION: ${pet.mutation} ${petMutations[pet.mutation].emoji}` : '';
      alert(`ğŸ‰ Hatched ${pet.icon} ${pet.name}!\n${pet.description}${mutationText}`);
    }
  }

  updateDisplays();
  updateInventoryDisplay();
  updateShopDisplay();
}



/**
 * Format a BigInt as a string with commas for readability.
 * @param {BigInt} b - The BigInt to format.
 * @returns {string} The formatted string.
 */

 function formatBigInt2(b) {
  if (typeof b === 'number') b = BigInt(Math.floor(b));
  const s = b.toString();
  return s.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}


function formatBigInt(b) {
  if (typeof b === 'number') b = BigInt(Math.floor(b));
  if (typeof b !== 'bigint') return b;

  const isNegative = b < 0n;
  b = isNegative ? -b : b;

  const UNITS = [
    { value: 1_000_000_000_000_000_000_000_000_000_000_000_000_000n, symbol: "QIDCT" }, // quinadecilion (10^24)
    { value: 1_000_000_000_000_000_000_000_000_000_000_000_000_000_000n, symbol: "QADCT" }, // quadadecilion (10^15)
  { value: 1_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000n, symbol: "TDCT" }, // triodecilion (10^4)
  { value: 1_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000n, symbol: "DDCT" }, // duodecilion (10^24)
  { value: 1_000_000_000_000_000_000_000_000_000_000_000_000n, symbol: "UDCT" }, // undecilion (10^24)
   { value: 1_000_000_000_000_000_000_000_000_000_000_000n, symbol: "DC" }, // decilion (10^24)
  { value: 1_000_000_000_000_000_000_000_000_000_000n, symbol: "NO" }, // nonnilion (10^24) 
  { value: 1_000_000_000_000_000_000_000_000_000n, symbol: "OC" }, // octilion (10^24)  
  { value: 1_000_000_000_000_000_000_000_000n, symbol: "SP" }, // septilion (10^24)
    { value: 1_000_000_000_000_000_000_000n, symbol: "SX" }, // sextilion (10^21)
    { value: 1_000_000_000_000_000_000n, symbol: "QI" }, // quintilion (10^18)
    { value: 1_000_000_000_000_000n, symbol: "QA" }, // quadrilion (10^15)
    { value: 1_000_000_000_000n, symbol: "T" }, // trillion (10^12)
    { value: 1_000_000_000n, symbol: "B" }, // billion (10^9)
    { value: 1_000_000n, symbol: "M" }, // million (10^6)
    { value: 1_000n, symbol: "K" } // thousand (10^3)
  ];

  for (const unit of UNITS) {
    if (b >= unit.value) {
      // Compute with BigInt precision safely
      const whole = Number(b / unit.value);
      const frac = Number(b % unit.value) / Number(unit.value);
      const formatted = (whole + frac).toFixed(1).replace(/\.0$/, "");
      return (isNegative ? "-" : "") + formatted + unit.symbol;
    }
  }

  // Fallback for small numbers
  return (isNegative ? "-" : "") + b.toString();
}



/**
 * Format a BigInt as a string with commas for readability and
 * optionally display a unit at the end (e.g. "K" for thousands, "M" for millions, etc.)
 * @param {BigInt} n - The number to format
 * @returns {string} The formatted string
 */
function shortLabel(n) {
  const num = BigInt(n);
  const abs = num < 0n ? -num : num;
const units = [
  [1_000_000_000_000_000_000_000_000_000_000_000n, "DC"], // decillion
  [1_000_000_000_000_000_000_000_000_000_000n, "NO"], // nonillion
  [1_000_000_000_000_000_000_000_000_000n, "OC"], // octillion
  [1_000_000_000_000_000_000_000_000n, "SP"], // septillion
  [1_000_000_000_000_000_000_000n, "SX"], // sextillion
  [1_000_000_000_000_000_000n, "QI"], // quintillion
  [1_000_000_000_000_000n, "QA"], // quadrillion
  [1_000_000_000_000n, "T"], // trillion
  [1_000_000_000n, "B"], // billion
  [1_000_000n, "M"], // million
  [1_000n, "K"] // thousand
];

  for (let [v, l] of units) if (abs >= v) return (num < 0n ? "-" : "") + Number(abs / v) + l;
  return num.toString();
}

const tier1Cubes = [
  { name: "Green", color: "#3bbf6e", value: 100n },
  { name: "Blue", color: "#3b8ebf", value: 1000n },
  { name: "Black", color: "#222222", value: 10000n },
  { name: "Yellow", color: "#e6d44a", value: 100000n },
  { name: "Orange", color: "#ff8a2b", value: 1000000n },
  { name: "Purple", color: "#8b3bff", value: 10000000n },
  { name: "Red", color: "#c53030", value: 100000000n },
  { name: "White", color: "#e9ecef", value: 1000000000n },
];
const tier2Cubes = [
  { name: "Light Green", color: "#9be6b8", value: 10000000000n },
  { name: "Light Blue", color: "#9bd3e6", value: 100000000000n },
  { name: "Dark Grey", color: "#6b6b6b", value: 1000000000000n },
  { name: "Light Yellow", color: "#fff1a8", value: 10000000000000n },
  { name: "Light Orange", color: "#ffc89b", value: 100000000000000n },
  { name: "Light Purple", color: "#d8b8ff", value: 1000000000000000n },
  { name: "Light Red", color: "#ffb8b8", value: 10000000000000000n },
  { name: "Light Gray", color: "#d0d0d0", value: 100000000000000000n },
];
const tier3Cubes = [
  { name: "Dark Green", color: "#0a5f38", value: 1000000000000000000n }, // 1QI
  { name: "Dark Blue", color: "#1a4d7a", value: 10000000000000000000n }, // 10QI
  { name: "Indigo", color: "#4b0082", value: 100000000000000000000n }, // 100QI
  { name: "Dark Yellow", color: "#9b870c", value: 1000000000000000000000n }, // 1SX
  { name: "Dark Orange", color: "#cc5500", value: 10000000000000000000000n }, // 10SX
  { name: "Dark Purple", color: "#5a1d5a", value: 100000000000000000000000n }, // 100SX
  { name: "Dark Red", color: "#8b0000", value: 1000000000000000000000000n }, // 1SP âœ…
  { name: "Neon Green", color: "#39ff14", value: 10000000000000000000000000n }, // 10SP âœ…
];
const tier4Cubes = [
  { name: "Leafy Green", color: "#7cb342", value: 100000000000000000000000000n }, // 100SP âœ…
  { name: "Aquamarine", color: "#7fffd4", value: 1000000000000000000000000000n }, // 1OC âœ…
  { name: "Noir", color: "#0a0a0a", value: 10000000000000000000000000000n }, // 10OC âœ…
  { name: "Bright Orange", color: "#ff9500", value: 100000000000000000000000000000n }, // 100OC âœ…
  { name: "Sunny Orange", color: "#ffcc33", value: 1000000000000000000000000000000n }, // 1NO âœ…
  { name: "Pink", color: "#ff69b4", value: 10000000000000000000000000000000n }, // 10NO âœ…
  { name: "Dark Brown", color: "#5c4033", value: 100000000000000000000000000000000n }, // 1DC âœ…
  { name: "Neon Blue", color: "#1b03a3", value: 1000000000000000000000000000000000n }, // 10DC âœ…
];

const incomeRates = {
  // Tier 1
  "Green": 2n, "Blue": 20n, "Black": 200n, "Yellow": 2000n, 
  "Orange": 20000n, "Purple": 200000n, "Red": 2000000n, "White": 20000000n,
  // Tier 2
  "Light Green": 200000000n, "Light Blue": 2000000000n, "Dark Grey": 20000000000n,
  "Light Yellow": 200000000000n, "Light Orange": 2000000000000n, "Light Purple": 20000000000000n,
  "Light Red": 200000000000000n, "Light Gray": 2000000000000000n,
  // Tier 3
  "Dark Green": 20000000000000000n, "Dark Blue": 200000000000000000n, "Indigo": 2000000000000000000n,
  "Dark Yellow": 20000000000000000000n, "Dark Orange": 200000000000000000000n, 
  "Dark Purple": 2000000000000000000000n, "Dark Red": 20000000000000000000000n,
  "Neon Green": 200000000000000000000000n,
  // Tier 4
  "Leafy Green": 2000000000000000000000000n, "Aquamarine": 20000000000000000000000000n,
  "Noir": 200000000000000000000000000n, "Bright Orange": 2000000000000000000000000000n,
  "Sunny Orange": 20000000000000000000000000000n, "Pink": 200000000000000000000000000000n,
  "Dark Brown": 2000000000000000000000000000000n, "Neon Blue": 20000000000000000000000000000000n,
};

function computeCubePositions() {
  const totalWidth = (CUBE_COUNT * CUBE_SIZE) + ((CUBE_COUNT - 1) * CUBE_SPACING);
  const startX = Math.round((W - totalWidth) / 2);
  const arr = [];
  for (let i = 0; i < CUBE_COUNT; i++) {
    arr.push({ x: startX + i * (CUBE_SIZE + CUBE_SPACING), y: TOP_Y, w: CUBE_SIZE, h: CUBE_SIZE });
  }
  return arr;
}
const cubePositions = computeCubePositions();
function currentCubes() {
  if (cubeTier === 0) return tier1Cubes;
  if (cubeTier === 1) return tier2Cubes;
  if (cubeTier === 2) return tier3Cubes;
  return tier4Cubes;
}
function buildCubes() { return currentCubes().map((c, i) => ({ ...c, pos: cubePositions[i], visible: true })); }

let cubes = buildCubes();

// const character = { x: W / 2 - CUBE_SIZE / 2, y: H / 2 - CUBE_SIZE / 2, w: CUBE_SIZE, h: CUBE_SIZE, color: "#ff2b2b", speed: 250, target: null, assignedName: null, assignedValue: 0n };
const character = {
  x: W / 2 - CUBE_SIZE / 2,
  y: H / 2 - CUBE_SIZE / 2,
  w: CUBE_SIZE,
  h: CUBE_SIZE,
  color: skins[equippedSkinSpecial].color,
  speed: 250,
  target: null,
  assignedName: null,
  assignedValue: 0n,
  hasSword: false,
  slashing: false,
  slashDuration: 200
};

// Update boss sizes and speeds based on character
boss.w = character.w * 1.5;
boss.h = character.h * 1.5;
boss.speed = character.speed * 1.3;

phoenixBoss.w = character.w * 2;
phoenixBoss.h = character.h * 2;
phoenixBoss.speed = character.speed * 1.1;

tornado.speed = character.speed * 1.3;

const house = { w: 140, h: 140, x: W - 160, y: H - 160, border: "#ff3b3b" };

let bossDrops = [];

const inventory = {
  "ğŸ“¿ Crossbones Relic": 0,
  "â¬œğŸ’€ Skeleton Skin": 0,
  "â¬œâ˜ ï¸ Crossbones Cube": 0,
  "â„ï¸ Snowflakes": 0,
};

const dropCounters = {
  "ğŸ“¿ Crossbones Relic": 0,
  "â¬œğŸ’€ Skeleton Skin": 0,
  "â¬œâ˜ ï¸ Crossbones Cube": 0,
  "â„ï¸ Snowflakes": 0,
};


let money = 1000n, incomePerSec = 0n, houseValue = 0n;

let bossSpawnInterval = 10 * 60 * 1000; // 10 minutes in ms
let nextBossSpawn = Date.now() + bossSpawnInterval;

const legendCounts = {};
[...tier1Cubes, ...tier2Cubes, ...tier3Cubes, ...tier4Cubes].forEach(c => legendCounts[c.name] = 0n);
let insideHouse = false;

// === ğŸ›’ SHOP CONFIGURATION ===
const shopItems = {
  Swords: [
    { icon: "âš”ï¸", price: 100_000_000n, name: "Iron Sword", limit: 1, special: 2 },
    { icon: "ğŸ—¡ï¸", price: 100_000_000_000n, name: "Steel Sword", limit: 1, special: 3 },
    { icon: "ğŸ’", price: 10_000_000_000_000n, name: "Crystal Sword", limit: 1, special: 4 },
    { icon: "ğŸ”¥", price: 100_000_000_000_000_000n, name: "Flame Blade", limit: 1, special: 3 },
    { icon: "âš¡", price: 100_000_000_000_000_000_000n, name: "Thunder Edge", limit: 1, special: 5 },
    { icon: "ğŸ†", price: 999_999_999_999_999_999_999_999_999_999_999n, name: "Golden Sword", limit: 1, special: 6, rebirthLocked: 9 },
    { icon: "ğŸ”®", price: 0n, name: "Enchanted Sword", limit: 1, special: 4, enchantOnly: true },
    { icon: "âœ¨", price: 0n, name: "Rare Enchant Sword", limit: 1, special: 6, enchantOnly: true }
  ],
  Relics: [
    { icon: "ğŸ“¿", price: 100_000_000n, name: "Relic of Light", limit: 1, special: 1.1 },
    { icon: "ğŸª¶", price: 100_000_000_000n, name: "Relic of Wind", limit: 1, special: 1.15 },
    { icon: "ğŸ’€", price: 100_000_000_000_000n, name: "Relic of Death", limit: 1, special: 1.20 },
    { icon: "ğŸŒ™", price: 1_000_000_000_000_000_000n, name: "Relic of Night", limit: 1, special: 1.25 },
    { icon: "â˜€ï¸", price: 100_000_000_000_000_000_000n, name: "Relic of Sun", limit: 1, special: 1.30 },
    { icon: "âœ¨", price: 0n, name: "Heavenly Totem", limit: 99, special: 1.35, ascensionOnly: true },
    { icon: "ğŸ€", price: 0n, name: "Enchant Relic", limit: 99, special: 1.0, enchantOnly: true }
  ],
  Eggs: [
    { icon: "ğŸ¥š", price: 100_000_000n, name: "Basic Egg", limit: 999, special: 1 },
    { icon: "ğŸ£", price: 100_000_000_000n, name: "Rare Egg", limit: 999, special: 1 },
    { icon: "ğŸ‰", price: 100_000_000_000_000n, name: "Dragon Egg", limit: 999, special: 1 },
    { icon: "âœ¨", price: 1_000_000_000_000_000_000n, name: "Mythic Egg", limit: 999, special: 1 },
    { icon: "ğŸªº", price: 10_000_000_000_000_000_000_000n, name: "Celestial Egg", limit: 999, special: 1 },
    { icon: "ğŸ”®", price: 0n, name: "Enchant Egg", limit: 999, special: 1, enchantOnly: true },
    { icon: "âœ¨", price: 0n, name: "Ascension Egg", limit: 999, special: 1, ascensionOnly: true }
  ],
  Skins: [
    { icon: "ğŸŸ¥", price: 1_000_000_000n, name: "Red Skin", limit: 1, special: 1 },
    { icon: "ğŸŸ¦", price: 1_000_000_000_000n, name: "Blue Skin", limit: 1, special: 2 },
    { icon: "ğŸŸª", price: 1_000_000_000_000_000n, name: "Purple Skin", limit: 1, special: 3 },
    { icon: "ğŸŸ¨", price: 10_000_000_000_000_000_000n, name: "Gold Skin", limit: 1, special: 4 },
    { icon: "â¬œ", price: 1_000_000_000_000_000_000_000n, name: "Diamond Skin", limit: 1, special: 5 },
    { icon: "âœ¨", price: 0n, name: "Heavenly Skin", limit: 1, special: 15, ascensionOnly: true },
    { icon: "ğŸ”®", price: 0n, name: "Enchant Skin", limit: 1, special: 16, enchantOnly: true }
  ],
  Potions: [
    { icon: "ğŸ§ª", price: 1_000_000n, name: "Health Potion", limit: 999, special: 2 },
    { icon: "ğŸ’Š", price: 10_000_000_000n, name: "Energy Potion", limit: 999, special: 3 },
    { icon: "âš—ï¸", price: 100_000_000_000_000n, name: "Alchemy Potion", limit: 999, special: 4 },
    { icon: "ğŸ§‰", price: 1_000_000_000_000_000_000n, name: "Mystic Potion", limit: 999, special: 5 },
    { icon: "ğŸ¥¤", price: 10_000_000_000_000_000_000_000n, name: "Divine Potion", limit: 999, special: 6 },
    { icon: "ğŸ”®", price: 0n, name: "Enchanted Potion", limit: 999, special: 7, enchantOnly: true }
  ]
};
// === PET SYSTEM CONFIGURATION ===
const petDatabase = {
  "Basic Egg": [
    { name: "Blue Cube", color: "#3b8ebf", icon: "ğŸŸ¦", ability: "passive_income", value: 1.05, chance: 0.40, description: "+5% income" },
    { name: "Orange Cube", color: "#ff8a2b", icon: "ğŸŸ§", ability: "speed_boost", value: 1.10, chance: 0.30, description: "+10% speed" },
    { name: "Purple Cube", color: "#8b3bff", icon: "ğŸŸª", ability: "purple_spawn", value: 1.20, chance: 0.15, description: "Spawns purple cube (5min)" },
    { name: "Green Cube", color: "#3bbf6e", icon: "ğŸŸ©", ability: "cube_grabber", value: 1, chance: 0.10, description: "Grabs random cube (15min)" },
    { name: "Yellow Cube", color: "#e6d44a", icon: "ğŸŸ¨", ability: "day_trigger", value: 0.10, chance: 0.04, description: "Triggers day event (5min)" },
    { name: "Red Cube", color: "#c53030", icon: "ğŸŸ¥", ability: "ember_mutator", value: 0.10, chance: 0.01, description: "Mutates pets with Ember (30min)" }
  ],
  "Rare Egg": [
    { name: "Light Green Cube", color: "#9be6b8", icon: "ğŸŸ©âœ¨", ability: "double_damage", value: 2, chance: 0.50, description: "2x sword damage" },
    { name: "Light Purple Cube", color: "#d8b8ff", icon: "ğŸŸªâœ¨", ability: "passive_income", value: 1.15, chance: 0.30, description: "+15% income" },
    { name: "Light Yellow Cube", color: "#fff1a8", icon: "ğŸŸ¨âœ¨", ability: "shooting_star", value: 0.40, chance: 0.10, description: "Spawns shooting star (15min)" },
    { name: "Light Orange Cube", color: "#ffc89b", icon: "ğŸŸ§âœ¨", ability: "boss_spawn", value: 0.15, chance: 0.05, description: "Spawns boss (15min)" },
    { name: "Light Blue Cube", color: "#9bd3e6", icon: "ğŸŸ¦âœ¨", ability: "glitch_mutator", value: 0.05, chance: 0.045, description: "Mutates with Glitched (10min)" },
    { name: "Light Red Cube", color: "#ffb8b8", icon: "ğŸŸ¥âœ¨", ability: "ability_copy", value: 1, chance: 0.005, description: "Copies nearby pet ability (20min)" }
  ],
  "Dragon Egg": [
    { name: "Dark Yellow Cube", color: "#9b870c", icon: "ğŸŸ¨ğŸ’", ability: "egg_giver", value: 0.20, chance: 0.55, description: "Gives random egg (70s)" },
    { name: "Dark Orange Cube", color: "#cc5500", icon: "ğŸŸ§ğŸ’", ability: "money_doubler", value: 0.10, chance: 0.20, description: "Doubles money (5min)" },
    { name: "Dark Blue Cube", color: "#1a4d7a", icon: "ğŸŸ¦ğŸ’", ability: "double_damage", value: 2, chance: 0.15, description: "2x sword damage" },
    { name: "Dark Purple Cube", color: "#5a1d5a", icon: "ğŸŸªğŸ’", ability: "entity_spawner", value: 1, chance: 0.05, description: "Spawns random entity (15min)" },
    { name: "Dark Green Cube", color: "#0a5f38", icon: "ğŸŸ©ğŸ’", ability: "glitch_event", value: 0.02, chance: 0.049, description: "Starts Glitch event (5min)" },
    { name: "Dark Red Cube", color: "#8b0000", icon: "ğŸŸ¥ğŸ’", ability: "weather_trigger", value: 0.10, chance: 0.001, description: "Random weather (10min)" }
  ],
  "Mythic Egg": [
    { name: "Teal Cube", color: "#008080", icon: "ğŸ”·", ability: "bone_giver", value: 1, chance: 0.60, description: "Gives skeleton bone (10min)" },
    { name: "Indigo Cube", color: "#4b0082", icon: "ğŸŸ£", ability: "blackhole_event", value: 0.10, chance: 0.30, description: "Starts Blackhole (5min)" },
    { name: "Neon Green Cube", color: "#39ff14", icon: "ğŸŸ¢", ability: "cycle_changer", value: 0.60, chance: 0.098, description: "Changes day/night cycle (3min)" },
    { name: "Neon Blue Cube", color: "#1b03a3", icon: "ğŸ”µ", ability: "timer_reducer", value: 5, chance: 0.002, description: "Reduces all timers -5min" }
  ],
  "Celestial Egg": [
   
    { name: "Aquamarine Cube", color: "#7fffd4", icon: "ğŸ’ ", ability: "earthquake_event", value: 0.30, chance: 0.20, description: "Starts Earthquake (10min)" },
    { name: "Bright Orange Cube", color: "#ff9500", icon: "ğŸŸ ", ability: "random_event", value: 1, chance: 0.15, description: "Random event (5min)" },
    { name: "Sunny Orange Cube", color: "#ffcc33", icon: "â˜€ï¸", ability: "passive_income", value: 1.30, chance: 0.10, description: "+30% income" },
   { name: "Noir Cube", color: "#0a0a0a", icon: "â¬›", ability: "night_bonus", value: 1.50, chance: 0.09, description: "+50% income at night" },
    { name: "Celestial Blue Cube", color: "#4169E1", icon: "ğŸŒŒ", ability: "galactic_event", value: 1, chance: 0.001, description: "Starts Galactic event (5min)" }
  ]
};
// Add this AFTER the existing petDatabase entries

petDatabase["Gift Egg"] = [
  { 
    name: "Snowman Cube", 
    color: "#FFFFFF", 
    icon: "â›„", 
    ability: "gift_multiplier", 
    value: 1.25, 
    chance: 0.50, 
    description: "All gift drops give 25% more" 
  },
  { 
    name: "Candy Cane Cube", 
    color: "#FF0000", 
    icon: "ğŸ¬", 
    ability: "double_income_temp", 
    value: 0.30, 
    chance: 0.30, 
    description: "2x income burst (20s, 3min cooldown)" 
  },
  { 
    name: "Present Cube", 
    color: "#FFD700", 
    icon: "ğŸ", 
    ability: "random_cube_spawn", 
    value: 0.25, 
    chance: 0.10, 
    description: "Spawns random tier cube (5min)" 
  },
  { 
    name: "Mistletoe Cube", 
    color: "#90EE90", 
    icon: "â˜˜ï¸", 
    ability: "heal_boss_damage", 
    value: 1, 
    chance: 0.09, 
    description: "Negates next boss hit (10min)" 
  },
  { 
    name: "North Star Cube", 
    color: "#FFFACD", 
    icon: "â­", 
    ability: "lucky_star", 
    value: 2.0, 
    chance: 0.01, 
    description: "2x all drop rates for 30s (15min)" 
  }
];
petDatabase["Galactic Egg"] = [
  { name: "Cosmic Cube", color: "#4a0080", icon: "ğŸŒŒ", ability: "galactic_income", value: 1.40, chance: 0.50, description: "+40% income during Galactic event" },
  { name: "Nebula Cube", color: "#6a2a9a", icon: "â˜„ï¸", ability: "meteor_shower", value: 0.30, chance: 0.30, description: "Spawns meteors for money (10min)" },
  { name: "Starship Cube", color: "#8a4aba", icon: "ğŸ›¸", ability: "warp_speed", value: 1.60, chance: 0.10, description: "+60% speed during Galactic" },
  { name: "Supernova Cube", color: "#aa6ada", icon: "ğŸ’«", ability: "explosive_income", value: 3.0, chance: 0.095, description: "3x income burst (15s, 5min cooldown)" },
  { name: "Dark Matter Cube", color: "#000033", icon: "âš«", ability: "gravity_well", value: 1, chance: 0.005, description: "Pulls all cubes to you (20min)" }
];

petDatabase["Glitched Egg"] = [
  { name: "Error Cube", color: "#00ff00", icon: "âš ï¸", ability: "glitch_income", value: 1.35, chance: 0.50, description: "+35% income during Glitched event" },
  { name: "Bug Cube", color: "#33ff33", icon: "ğŸ›", ability: "duplicate_cube", value: 0.25, chance: 0.30, description: "Duplicates a random cube (8min)" },
  { name: "Corrupted Cube", color: "#66ff66", icon: "ğŸ’š", ability: "corrupt_spawn", value: 0.20, chance: 0.10, description: "Spawns corrupted entities (12min)" },
  { name: "Hack Cube", color: "#99ff99", icon: "ğŸ”“", ability: "unlock_tier", value: 1, chance: 0.095, description: "Temporarily unlock next tier (3min, 15min cooldown)" },
  { name: "Matrix Cube", color: "#ccffcc", icon: "ğŸ”¢", ability: "code_rain", value: 5.0, chance: 0.005, description: "5x income for 10s (10min cooldown)" }
];

petDatabase["Disco Egg"] = [
  { name: "Groove Cube", color: "#ff00ff", icon: "ğŸ•º", ability: "disco_income", value: 1.25, chance: 0.50, description: "+25% income during Disco event" },
  { name: "Beat Cube", color: "#ff33ff", icon: "ğŸµ", ability: "rhythm_boost", value: 1.40, chance: 0.30, description: "+40% speed during Disco" },
  { name: "Dance Cube", color: "#ff66ff", icon: "ğŸ’ƒ", ability: "party_mode", value: 0.15, chance: 0.10, description: "Double ALL multipliers (20s, 8min cooldown)" },
  { name: "Spotlight Cube", color: "#ff99ff", icon: "ğŸ­", ability: "disco_ball", value: 1, chance: 0.095, description: "Spawns special disco cubes (6min)" },
  { name: "Rave Cube", color: "#ffccff", icon: "âœ¨", ability: "strobe_effect", value: 1, chance: 0.005, description: "Random positive effects every 30s" }
];

petDatabase["Bloodmoon Egg"] = [
  { name: "Crimson Cube", color: "#8B0000", icon: "ğŸ©¸", ability: "bloodmoon_income", value: 1.30, chance: 0.50, description: "+30% income during Bloodmoon" },
  { name: "Eclipse Cube", color: "#a50000", icon: "ğŸŒ‘", ability: "shadow_strike", value: 3.0, chance: 0.30, description: "3x sword damage during Bloodmoon" },
  { name: "Lunar Cube", color: "#bf0000", icon: "ğŸŒ™", ability: "blood_ritual", value: 0.20, chance: 0.10, description: "Convert HP to money (5min)" },
  { name: "Vampire Cube", color: "#d90000", icon: "ğŸ§›", ability: "life_steal", value: 1, chance: 0.095, description: "Heal on boss hit (passive)" },
  { name: "Crimson King Cube", color: "#ff0000", icon: "ğŸ‘‘", ability: "blood_pact", value: 2.0, chance: 0.005, description: "2x ALL drops during Bloodmoon" }
];
petDatabase["Void Egg"] = [
  { name: "Void Cube", color: "#1a0033", icon: "ğŸŒŒ", ability: "passive_income", value: 1.50, chance: 0.50, description: "+50% income" },
  { name: "Shadow Cube", color: "#0a0a1a", icon: "ğŸ‘¤", ability: "night_bonus", value: 2.0, chance: 0.30, description: "2x income at night" },
  { name: "Dark Matter Cube", color: "#000000", icon: "âš«", ability: "money_doubler", value: 0.25, chance: 0.15, description: "Double money (3min)" },
  { name: "Obsidian Cube", color: "#1a0a0a", icon: "ğŸ–¤", ability: "double_damage", value: 3.0, chance: 0.049, description: "3x sword damage" },
  { name: "Void King Cube", color: "#2a0044", icon: "ğŸ‘‘ğŸŒŒ", ability: "heavenly_king", value: 6.0, chance: 0.001, description: "6x ALL multipliers" }
];

petDatabase["Dragon Egg"] = [
  { name: "Drake Cube", color: "#8B0000", icon: "ğŸ²", ability: "passive_income", value: 1.60, chance: 0.50, description: "+60% income" },
  { name: "Wyvern Cube", color: "#FF4500", icon: "ğŸ¦", ability: "speed_boost", value: 1.80, chance: 0.30, description: "+80% speed" },
  { name: "Dragon Knight Cube", color: "#DC143C", icon: "ğŸ›¡ï¸", ability: "double_damage", value: 4.0, chance: 0.15, description: "4x sword damage" },
  { name: "Elder Dragon Cube", color: "#B22222", icon: "ğŸ‰ğŸ’", ability: "explosive_income", value: 5.0, chance: 0.049, description: "5x income burst (15s, 5min)" },
  { name: "Dragon Emperor Cube", color: "#8B0000", icon: "ğŸ‘‘ğŸ‰", ability: "heavenly_king", value: 7.0, chance: 0.001, description: "7x ALL multipliers" }
];

petDatabase["Celestial Egg"] = [
  { name: "Star Cube", color: "#FFD700", icon: "â­", ability: "passive_income", value: 1.70, chance: 0.50, description: "+70% income" },
  { name: "Nebula Cube", color: "#9370DB", icon: "ğŸŒ ", ability: "shooting_star", value: 0.60, chance: 0.30, description: "60% bonus (15min)" },
  { name: "Cosmic Cube", color: "#4169E1", icon: "ğŸŒŒ", ability: "galactic_income", value: 2.0, chance: 0.15, description: "2x income during Galactic" },
  { name: "Supernova Cube", color: "#FF6347", icon: "ğŸ’¥", ability: "explosive_income", value: 10.0, chance: 0.049, description: "10x income burst (15s, 3min)" },
  { name: "Celestial King Cube", color: "#F0E68C", icon: "ğŸ‘‘âœ¨", ability: "heavenly_king", value: 8.0, chance: 0.001, description: "8x ALL multipliers" }
];

petDatabase["Mythril Egg"] = [
  { name: "Iron Cube", color: "#708090", icon: "ğŸ”©", ability: "passive_income", value: 1.80, chance: 0.50, description: "+80% income" },
  { name: "Steel Cube", color: "#A9A9A9", icon: "âš™ï¸", ability: "speed_boost", value: 2.0, chance: 0.30, description: "+100% speed" },
  { name: "Mythril Cube", color: "#C0C0C0", icon: "â›ï¸ğŸ’", ability: "double_damage", value: 5.0, chance: 0.15, description: "5x sword damage" },
  { name: "Adamantite Cube", color: "#E5E4E2", icon: "ğŸ’", ability: "gravity_well", value: 1, chance: 0.049, description: "Pull all cubes (20min)" },
  { name: "Mythril King Cube", color: "#F5F5F5", icon: "ğŸ‘‘â›ï¸", ability: "heavenly_king", value: 9.0, chance: 0.001, description: "9x ALL multipliers" }
];

petDatabase["Infinity Egg"] = [
  { name: "Alpha Cube", color: "#FF00FF", icon: "âˆ", ability: "passive_income", value: 2.0, chance: 0.50, description: "+100% income" },
  { name: "Omega Cube", color: "#00FFFF", icon: "Î©", ability: "speed_boost", value: 2.5, chance: 0.30, description: "+150% speed" },
  { name: "Eternal Cube", color: "#FFFF00", icon: "â™¾ï¸", ability: "double_damage", value: 6.0, chance: 0.15, description: "6x sword damage" },
  { name: "Infinite Cube", color: "#FF1493", icon: "âœ¨â™¾ï¸", ability: "party_mode", value: 0.30, chance: 0.049, description: "2x ALL (20s, 8min)" },
  { name: "Infinity King Cube", color: "#FF69B4", icon: "ğŸ‘‘â™¾ï¸", ability: "heavenly_king", value: 10.0, chance: 0.001, description: "10x ALL multipliers" }
];

petDatabase["Enchanted Leviathan Egg"] = [
  { name: "Tidal King Cube", color: "#00CED1", icon: "ğŸŒŠğŸ‘‘", ability: "passive_income", value: 2.5, chance: 0.40, description: "+150% income" },
  { name: "Ocean Emperor Cube", color: "#4682B4", icon: "ğŸŒŠğŸ’", ability: "speed_boost", value: 3.0, chance: 0.30, description: "+200% speed" },
  { name: "Leviathan Lord Cube", color: "#1E90FF", icon: "ğŸŒŠâš”ï¸", ability: "double_damage", value: 8.0, chance: 0.20, description: "8x sword damage" },
  { name: "Abyssal Cube", color: "#000080", icon: "ğŸŒŠâœ¨", ability: "angel_blessing", value: 0.50, chance: 0.09, description: "10x income burst (30s, 2min)" },
  { name: "Enchanted Leviathan King", color: "#0000CD", icon: "ğŸ‘‘âœ¨ğŸŒŠ", ability: "heavenly_king", value: 15.0, chance: 0.01, description: "15x ALL multipliers (ULTIMATE)" }
];
// === ENCHANT EGG PETS (ADD AFTER ALL OTHER PET DATABASES) ===
petDatabase["Enchant Egg"] = [
  { 
    name: "Enchanter Cube", 
    color: "#9370DB", 
    icon: "ğŸ”®", 
    ability: "enchant_booster", 
    value: 0.10, 
    chance: 0.40, 
    description: "10% chance free enchant (5min)" 
  },
  { 
    name: "Mystic Cube", 
    color: "#8A2BE2", 
    icon: "ğŸŒŸ", 
    ability: "enchant_saver", 
    value: 0.50, 
    chance: 0.30, 
    description: "50% refund on enchant cost" 
  },
  { 
    name: "Arcane Cube", 
    color: "#9932CC", 
    icon: "ğŸ”¯", 
    ability: "tier_upgrader", 
    value: 0.20, 
    chance: 0.20, 
    description: "20% chance tier upgrade" 
  },
  { 
    name: "Runic Cube", 
    color: "#BA55D3", 
    icon: "ğŸ“œ", 
    ability: "double_enchant", 
    value: 0.15, 
    chance: 0.05, 
    description: "15% chance 2x enchants (10min)" 
  },
  { 
    name: "Ethereal Cube", 
    color: "#DA70D6", 
    icon: "ğŸ’«", 
    ability: "enchant_keeper", 
    value: 1, 
    chance: 0.049, 
    description: "Keep enchant on rebirth" 
  },
  { 
    name: "Legendary Enchanter", 
    color: "#EE82EE", 
    icon: "ğŸ‘‘", 
    ability: "ultimate_enchanter", 
    value: 0.05, 
    chance: 0.001, 
    description: "5% chance Ultimate tier" 
  }
];
// === ASCENSION EGG PETS (OP ABILITIES) ===
petDatabase["Ascension Egg"] = [
  { 
    name: "Divine Cube", 
    color: "#FFD700", 
    icon: "âœ¨", 
    ability: "divine_income", 
    value: 2.0, 
    chance: 0.30, 
    description: "+100% income (passive)" 
  },
  { 
    name: "Celestial Cube", 
    color: "#87CEEB", 
    icon: "â˜ï¸", 
    ability: "celestial_speed", 
    value: 2.5, 
    chance: 0.25, 
    description: "+150% speed (passive)" 
  },
  { 
    name: "Angelic Cube", 
    color: "#FFFACD", 
    icon: "ğŸ‘¼", 
    ability: "angel_blessing", 
    value: 0.10, 
    chance: 0.20, 
    description: "10x money burst (30s, 2min cooldown)" 
  },
  { 
    name: "Seraph Cube", 
    color: "#F0E68C", 
    icon: "ğŸ•Šï¸", 
    ability: "seraph_protection", 
    value: 5, 
    chance: 0.15, 
    description: "Immune to 5 boss hits" 
  },
  { 
    name: "Archangel Cube", 
    color: "#FAFAD2", 
    icon: "âšœï¸", 
    ability: "archangel_power", 
    value: 5.0, 
    chance: 0.09, 
    description: "5x sword damage (passive)" 
  },
  { 
    name: "Heavenly King Cube", 
    color: "#FFFFFF", 
    icon: "ğŸ‘‘", 
    ability: "heavenly_king", 
    value: 3.0, 
    chance: 0.01, 
    description: "3x ALL multipliers (passive)" 
  }
];
petDatabase["Leviathan Egg"] = [
  { 
    name: "Leviathan Cub", 
    color: "#4682B4", 
    icon: "ğŸŒŠ", 
    ability: "passive_income", 
    value: 1.20, 
    chance: 0.50, 
    description: "+20% income" 
  },
  { 
    name: "Frost Leviathan", 
    color: "#87CEEB", 
    icon: "â„ï¸ğŸŒŠ", 
    ability: "speed_boost", 
    value: 1.30, 
    chance: 0.30, 
    description: "+30% speed" 
  },
  { 
    name: "Tidal Leviathan", 
    color: "#1E90FF", 
    icon: "ğŸŒ€", 
    ability: "double_damage", 
    value: 2.0, 
    chance: 0.15, 
    description: "2x sword damage" 
  },
  { 
    name: "Deep Leviathan", 
    color: "#000080", 
    icon: "ğŸŒŠğŸ’", 
    ability: "money_doubler", 
    value: 0.15, 
    chance: 0.0499, 
    description: "Double money (5min)" 
  },
  { 
    name: "King Leviathan", 
    color: "#0000CD", 
    icon: "ğŸ‘‘ğŸŒŠ", 
    ability: "heavenly_king", 
    value: 5.0, 
    chance: 0.0001, 
    description: "5x ALL multipliers (LEGENDARY)" 
  }
];

petDatabase["Crafters Egg"] = [
  { 
    name: "Apprentice Cube", 
    color: "#8B4513", 
    icon: "ğŸ”¨", 
    ability: "passive_income", 
    value: 1.25, 
    chance: 0.50, 
    description: "+25% income" 
  },
  { 
    name: "Blacksmith Cube", 
    color: "#696969", 
    icon: "âš’ï¸", 
    ability: "double_damage", 
    value: 2.5, 
    chance: 0.30, 
    description: "2.5x sword damage" 
  },
  { 
    name: "Master Crafter Cube", 
    color: "#DAA520", 
    icon: "ğŸ› ï¸", 
    ability: "enchant_booster", 
    value: 0.20, 
    chance: 0.15, 
    description: "20% free enchant (5min)" 
  },
  { 
    name: "Legendary Smith Cube", 
    color: "#FFD700", 
    icon: "ğŸ‘‘ğŸ”¨", 
    ability: "ultimate_enchanter", 
    value: 0.10, 
    chance: 0.05, 
    description: "10% chance Ultimate tier" 
  }
];
const petMutations = {
  "Wet": { color: "#4da6ff", emoji: "ğŸ’§", incomeBoost: 1.05, event: "Rain" },
  "Shocked": { color: "#ffff00", emoji: "âš¡", incomeBoost: 1.10, event: "Thunder" },
  "Disco": { color: "#ff00ff", emoji: "ğŸª©", incomeBoost: 1.20, event: "Disco" },
  "Ember": { color: "#ff4400", emoji: "ğŸ”¥", incomeBoost: 1.30, event: "Volcano" },
  "Glitched": { color: "#00ff00", emoji: "âšœï¸", incomeBoost: 1.35, event: "Glitched" },
  "Galactic": { color: "#4a0080", emoji: "ğŸš€", incomeBoost: 1.40, event: "Galactic" },
  "Phoenix": { color: "#FF4500", emoji: "ğŸ”¥", incomeBoost: 1.45, event: "Phoenix Nest" },
  "Bloodmoon": { color: "#8B0000", emoji: "ğŸŒ•", incomeBoost: 1.50, event: "Bloodmoon" },
  "Windswept": { color: "#4a5568", emoji: "ğŸŒªï¸", incomeBoost: 1.55, event: "Tornado" },
  "Heavenly": { color: "#FFD700", emoji: "âœ¨", incomeBoost: 1.60, event: "Heavenly" } // NEW
};

let playerPets = []; // Array of pet objects
let equippedPets = []; // Max 3 pets that follow character
let petTimers = {}; // Track ability cooldowns
// Open an egg and get a random pet
function openEgg(eggType) {
  const pets = petDatabase[eggType];
  if (!pets) {
    console.error("Unknown egg type:", eggType);
    return null;
  }
  
  const roll = Math.random();
  let cumulative = 0;
  
  for (const pet of pets) {
    cumulative += pet.chance;
    if (roll <= cumulative) {
      // Create pet instance
      const newPet = {
        id: Date.now() + Math.random(), // unique ID
        name: pet.name,
        color: pet.color,
        icon: pet.icon,
        ability: pet.ability,
        abilityValue: pet.value,
        description: pet.description,
        eggType: eggType,
        mutation: null,
        equipped: false,
        offsetAngle: 0, // for positioning around character
        x: character.x,
        y: character.y
      };
      
      // Check for mutation during active event
      if (Math.random() < 0.10) { // 10% mutation chance during events
        if (currentAdminEvent) {
          const eventName = currentAdminEvent.name;
          for (const [mutName, mutData] of Object.entries(petMutations)) {
            if (mutData.event === eventName) {
              newPet.mutation = mutName;
              console.log(`ğŸ‰ Pet mutated with ${mutName}!`);
              break;
            }
          }
        } else if (currentWeather) {
          for (const [mutName, mutData] of Object.entries(petMutations)) {
            if (mutData.event === currentWeather) {
              newPet.mutation = mutName;
              console.log(`ğŸ‰ Pet mutated with ${mutName}!`);
              break;
            }
          }
        }
      }
      
      playerPets.push(newPet);
      console.log(`ğŸ¥š Hatched: ${pet.name} from ${eggType}!`);
      return newPet;
    }
  }
  
  return null;
}
// Open multiple eggs from inventory
function openEggFromInventory(eggName, count) {
  const eggItem = playerInventory.Eggs.find(i => i.name === eggName);
  
  if (!eggItem) {
    alert(`âŒ You don't have any ${eggName}s!`);
    return;
  }
  
  if (eggItem.count < count) {
    alert(`âŒ Not enough ${eggName}s! You have ${eggItem.count}, need ${count}.`);
    return;
  }
  
  let results = [];
  const eggsToOpen = Math.min(count, eggItem.count); // Safety check
  
  console.log(`Opening ${eggsToOpen} ${eggName}(s)...`); // Debug log
  
  // Open exactly the number requested
  for (let i = 0; i < eggsToOpen; i++) {
    const pet = openEgg(eggName);
    if (pet) {
      const mutationText = pet.mutation ? ` [${petMutations[pet.mutation].emoji}]` : '';
      results.push(`${pet.icon} ${pet.name}${mutationText}`);
    }
    eggItem.count--; // Decrement after each successful hatch
  }
  
  // Remove egg from inventory if count reaches 0
  if (eggItem.count <= 0) {
    const index = playerInventory.Eggs.indexOf(eggItem);
    if (index > -1) {
      playerInventory.Eggs.splice(index, 1);
    }
  }
  
  updateInventoryDisplay();
  
  console.log(`Hatched ${results.length} pets from ${eggsToOpen} eggs`); // Debug log
  
  if (results.length > 0) {
    alert(`ğŸ‰ Hatched ${results.length} ${eggName}(s)!\n\n${results.join('\n')}`);
  } else {
    alert(`âŒ Something went wrong! No pets hatched.`);
  }
}

// Make function globally accessible
window.openEggFromInventory = openEggFromInventory;
// Display pet odds for an egg type
function showEggOdds(eggType) {
  const pets = petDatabase[eggType];
  if (!pets) {
    return "Unknown egg type";
  }
  
  let oddsText = `ğŸ¥š ${eggType} Contents:\n\n`;
  
  pets.forEach(pet => {
    const percentage = (pet.chance * 100).toFixed(2);
    oddsText += `${pet.icon} ${pet.name}\n`;
    oddsText += `   ${pet.description}\n`;
    oddsText += `   Chance: ${percentage}%\n\n`;
  });
  
  return oddsText;
}
// Equip/unequip a pet
function togglePetEquip(petId) {
  const pet = playerPets.find(p => p.id === petId);
  if (!pet) return;
  
  if (pet.equipped) {
    // Unequip
    pet.equipped = false;
    equippedPets = equippedPets.filter(p => p.id !== petId);
  } else {
    // Check max equipped limit (now dynamic based on rebirths)
    if (equippedPets.length >= maxPetSlots) {
      alert(`âš ï¸ Maximum ${maxPetSlots} pets can be equipped at once!`);
      return;
    }
    
    // Equip
    pet.equipped = true;
    pet.offsetAngle = equippedPets.length * (Math.PI * 2 / maxPetSlots); // Spread evenly
    equippedPets.push(pet);
  }
  
  recomputeIncome(); // Recalculate with pet bonuses
  updateInventoryDisplay();
}

// Delete a pet
function deletePet(petId) {
  if (!confirm("âš ï¸ Are you sure you want to delete this pet?")) return;
  
  const index = playerPets.findIndex(p => p.id === petId);
  if (index === -1) return;
  
  const pet = playerPets[index];
  
  // Remove from equipped if needed
  if (pet.equipped) {
    equippedPets = equippedPets.filter(p => p.id !== petId);
  }
  
  // Remove from all pets
  playerPets.splice(index, 1);
  
  recomputeIncome();
  updateInventoryDisplay();
}
// Bulk delete all unequipped pets
function bulkDeletePets() {
  const unequippedCount = playerPets.filter(p => !p.equipped).length;
  
  if (unequippedCount === 0) {
    alert("âš ï¸ No unequipped pets to delete!");
    return;
  }
  
  if (!confirm(`âš ï¸ Delete ${unequippedCount} unequipped pet(s)?\n\nThis cannot be undone!`)) {
    return;
  }
  
  // Remove all unequipped pets
  playerPets = playerPets.filter(p => p.equipped);
  
  // Clean up timers
  const validPetIds = new Set(playerPets.map(p => p.id));
  for (let petId in petTimers) {
    if (!validPetIds.has(Number(petId))) {
      delete petTimers[petId];
    }
  }
  
  recomputeIncome();
  updateInventoryDisplay();
  
  alert(`âœ… Deleted ${unequippedCount} unequipped pet(s)!`);
}

// Make function globally accessible
window.bulkDeletePets = bulkDeletePets;
// Initialize pet timers
function initPetTimers() {
  playerPets.forEach(pet => {
    if (!petTimers[pet.id]) {
      petTimers[pet.id] = {
        lastTrigger: Date.now(),
        cooldown: getPetCooldown(pet.ability)
      };
    }
  });
}
// Filter pets by search query
// Advanced filter pets with multiple criteria
// Advanced filter pets with multiple criteria
function filterPets(searchQuery) {
  const query = searchQuery.toLowerCase().trim();
  const petItems = document.querySelectorAll('.pet-item');
  
  if (!query) {
    // Show all pets if search is empty
    petItems.forEach(item => {
      item.style.display = '';
    });
    return;
  }
  
  let foundCount = 0;
  
  // Check for special filter commands
  const isEquippedFilter = query === 'equipped' || query === 'equip';
  const isUnequippedFilter = query === 'unequipped' || query === 'unequip';
  const isMutatedFilter = query === 'mutated' || query === 'mutation';
  const isChristmasFilter = query === 'christmas' || query === 'xmas';
  const isEnchantedFilter = query === 'enchanted' || query === 'enchant';
  
  // Check for enchantment type filters
  const enchantTypes = {
    'money': 'Money Income',
    'luck': 'Luck',
    'speed': 'Speed',
    'damage': 'Sword Damage',
    'ultimate': 'Ultimate'
  };
  const matchedEnchantType = enchantTypes[query];
  
  petItems.forEach(item => {
    const petName = item.getAttribute('data-pet-name');
    const petAbility = item.getAttribute('data-pet-ability');
    const petMutation = item.getAttribute('data-pet-mutation');
    const petEggType = item.getAttribute('data-pet-egg') || '';
    const isEquipped = item.innerHTML.includes('âœ“ Equipped');
    const hasMutation = petMutation !== '';
    const hasEnchantment = item.innerHTML.includes('ğŸ’°') || item.innerHTML.includes('ğŸ€') || 
                          item.innerHTML.includes('âš¡') || item.innerHTML.includes('âš”ï¸') || 
                          item.innerHTML.includes('âœ¨');
    
    // Get pet's actual enchantment type from the HTML
    let petEnchantType = '';
    if (hasEnchantment) {
      const petId = item.querySelector('button[onclick^="togglePetEquip"]')?.getAttribute('onclick')?.match(/\d+/)?.[0];
      if (petId) {
        const pet = playerPets.find(p => p.id == petId);
        if (pet && pet.enchantment) {
          petEnchantType = pet.enchantment.type.toLowerCase();
        }
      }
    }
    
    let matches = false;
    
    // Special filters
    if (isEquippedFilter) {
      matches = isEquipped;
    } else if (isUnequippedFilter) {
      matches = !isEquipped;
    } else if (isMutatedFilter) {
      matches = hasMutation;
    } else if (isChristmasFilter) {
      matches = petEggType.includes('gift') || 
                petEggType.includes('christmas') ||
                petName.includes('snowman') ||
                petName.includes('candy cane') ||
                petName.includes('present') ||
                petName.includes('mistletoe') ||
                petName.includes('north star');
    } else if (isEnchantedFilter) {
      matches = hasEnchantment;
    } else if (matchedEnchantType) {
      matches = petEnchantType.includes(matchedEnchantType.toLowerCase());
    } else {
      // Normal search: name, ability, mutation, or egg type
      matches = petName.includes(query) || 
                petAbility.includes(query) || 
                petMutation.includes(query) ||
                petEggType.includes(query);
    }
    
    if (matches) {
      item.style.display = '';
      foundCount++;
    } else {
      item.style.display = 'none';
    }
  });
  
  // Show count in console for debugging
  console.log(`Found ${foundCount} pet(s) matching "${searchQuery}"`);
}

// Add clear search function
function clearPetSearch() {
  const searchInput = document.getElementById('petSearchInput');
  if (searchInput) {
    searchInput.value = '';
    filterPets('');
  }
}

// Make globally accessible
window.filterPets = filterPets;
window.clearPetSearch = clearPetSearch;
// Get cooldown for pet ability (in milliseconds)
function getPetCooldown(ability) {
  const cooldowns = {
    "purple_spawn": 5 * 60 * 1000,
    "cube_grabber": 15 * 60 * 1000,
    "day_trigger": 5 * 60 * 1000,
    "ember_mutator": 30 * 60 * 1000,
    "shooting_star": 15 * 60 * 1000,
    "boss_spawn": 15 * 60 * 1000,
    "glitch_mutator": 10 * 60 * 1000,
    "ability_copy": 20 * 60 * 1000,
    "egg_giver": 70 * 1000,
    "money_doubler": 5 * 60 * 1000,
    "entity_spawner": 15 * 60 * 1000,
    "glitch_event": 5 * 60 * 1000,
    "weather_trigger": 10 * 60 * 1000,
    "bone_giver": 10 * 60 * 1000,
    "blackhole_event": 5 * 60 * 1000,
    "cycle_changer": 3 * 60 * 1000,
    "timer_reducer": 999 * 60 * 1000,
    "rain_event": 5 * 60 * 1000,
    "earthquake_event": 10 * 60 * 1000,
    "random_event": 5 * 60 * 1000,
    "galactic_event": 5 * 60 * 1000,
    // NEW EVENT PET ABILITIES
    "day_income_boost": 999 * 60 * 1000,    // Passive
    "day_speed_boost": 999 * 60 * 1000,     // Passive
    "ember_giver": 10 * 60 * 1000,          // 10 min
    "night_income_boost": 999 * 60 * 1000,  // Passive
    "night_speed_boost": 999 * 60 * 1000,   // Passive
    "cooldown_reducer": 999 * 60 * 1000,    // Passive
    "mutation_giver": 5 * 60 * 1000,       // 5 min
      // NEW CHRISTMAS PET ABILITIES
    "gift_multiplier": 999 * 60 * 1000,      // Passive
    "double_income_temp": 3 * 60 * 1000,     // 3 min cooldown
    "random_cube_spawn": 5 * 60 * 1000,      // 5 min
    "heal_boss_damage": 10 * 60 * 1000,      // 10 min
    "lucky_star": 15 * 60 * 1000 ,
    // NEW EVENT PET ABILITIES
    "galactic_income": 999 * 60 * 1000,      // Passive
    "meteor_shower": 10 * 60 * 1000,         // 10 min
    "warp_speed": 999 * 60 * 1000,           // Passive
    "explosive_income": 5 * 60 * 1000,       // 5 min
    "gravity_well": 20 * 60 * 1000,          // 20 min
    "glitch_income": 999 * 60 * 1000,        // Passive
    "duplicate_cube": 8 * 60 * 1000,         // 8 min
    "corrupt_spawn": 12 * 60 * 1000,         // 12 min
    "unlock_tier": 15 * 60 * 1000,           // 15 min
    "code_rain": 10 * 60 * 1000,             // 10 min
    "disco_income": 999 * 60 * 1000,         // Passive
    "rhythm_boost": 999 * 60 * 1000,         // Passive
    "party_mode": 8 * 60 * 1000,             // 8 min
    "disco_ball": 6 * 60 * 1000,             // 6 min
    "strobe_effect": 30 * 1000,              // 30 sec
    "bloodmoon_income": 999 * 60 * 1000,     // Passive
    "shadow_strike": 999 * 60 * 1000,        // Passive
    "blood_ritual": 5 * 60 * 1000,           // 5 min
    "life_steal": 999 * 60 * 1000,           // Passive
    "blood_pact": 999 * 60 * 1000,         // Passive
    "divine_income": 999 * 60 * 1000,        // Passive
    "celestial_speed": 999 * 60 * 1000,      // Passive
    "angel_blessing": 2 * 60 * 1000,         // 2 min
    "seraph_protection": 999 * 60 * 1000,    // Passive
    "archangel_power": 999 * 60 * 1000,      // Passive
    "heavenly_king": 999 * 60 * 1000,        // Passive
        // NEW ENCHANT PET ABILITIES
    "enchant_booster": 5 * 60 * 1000,      // 5 min
    "enchant_saver": 999 * 60 * 1000,      // Passive
    "tier_upgrader": 999 * 60 * 1000,      // Passive (triggers on enchant)
    "double_enchant": 10 * 60 * 1000,      // 10 min
    "enchant_keeper": 999 * 60 * 1000,     // Passive
    "ultimate_enchanter": 999 * 60 * 1000  // Passive
  };

  return cooldowns[ability] || 60000;
}
// === EVENT SHOP CONFIGURATION ===
const eventShops = {
  "day": {
    displayName: "â˜€ï¸ Sunny Shop",
    activeWhen: () => dayNightCycle.current === "day",
    items: {
      Swords: [
        { icon: "â˜€ï¸ğŸ—¡ï¸", price: 1_000_000_000_000n, name: "Sunny Sword", limit: 1, special: 3, description: "3 damage" }
      ],
      Relics: [
        { icon: "â˜€ï¸ğŸ“¿", price: 50_000_000_000_000n, name: "Sunny Relic", limit: 1, special: 1.18, description: "1.18x money" }
      ],
      Eggs: [
        { icon: "â˜€ï¸ğŸ¥š", price: 1_000_000_000_000_000n, name: "Sunny Egg", limit: 999, special: 1, description: "3 Sunny Pets" }
      ],
      Skins: [
        { icon: "â˜€ï¸ğŸ’", price: 100_000_000_000_000_000n, name: "Sunny Skin", limit: 1, special: 6, description: "#FFF917" }
      ],
      Potions: [
        { icon: "â˜€ï¸ğŸ§ª", price: 10_000_000_000_000_000_000n, name: "Sunny Potion", limit: 999, special: 5.1, description: "5.1x income" }
      ]
    }
  },
  "night": {
    displayName: "ğŸŒ™ Night Shop",
    activeWhen: () => dayNightCycle.current === "night",
    items: {
      Swords: [
        { icon: "ğŸŒ™ğŸ—¡ï¸", price: 1_000_000_000_000_000n, name: "Night Sword", limit: 1, special: 4, description: "4 damage" }
      ],
      Relics: [
        { icon: "ğŸŒ™ğŸ“¿", price: 10_000_000_000_000_000_000_000n, name: "Dark Relic", limit: 1, special: 1.6, description: "1.6x money" }
      ],
      Eggs: [
        { icon: "ğŸŒ™ğŸ¥š", price: 1_000_000_000_000_000_000_000_000n, name: "Night Egg", limit: 999, special: 1, description: "4 Night Pets" }
      ],
      Skins: [
        { icon: "ğŸŒ™ğŸ’", price: 100_000_000_000_000_000_000_000_000_000_000n, name: "Night Skin", limit: 1, special: 7, description: "#312F36" }
      ],
      Potions: [
        { icon: "ğŸŒ™ğŸ§ª", price: 100_000_000_000_000_000_000_000n, name: "Night Potion", limit: 999, special: 7, description: "7x income" }
      ]
}
  },  // â† Added comma here!
// === NEW EVENT SHOPS ===
  "galactic": {
    displayName: "ğŸš€ Galactic Shop",
    activeWhen: () => currentAdminEvent && currentAdminEvent.name === "Galactic",
    items: {
      Swords: [
        { icon: "ğŸš€ğŸ—¡ï¸", price: 1_000_000_000_000_000_000_000n, name: "Galactic Sword", limit: 1, special: 5, description: "5 damage" }
      ],
      Relics: [
        { icon: "ğŸš€ğŸ“¿", price: 10_000_000_000_000_000_000_000_000n, name: "Galactic Relic", limit: 1, special: 1.57, description: "1.57x money" }
      ],
      Eggs: [
        { icon: "ğŸš€ğŸ¥š", price: 100_000_000_000_000_000_000_000_000_000n, name: "Galactic Egg", limit: 999, special: 1, description: "5 Galactic Pets" }
      ],
      Skins: [
        { icon: "ğŸš€ğŸ’", price: 100_000_000_000_000_000_000_000_000n, name: "Galaxy Skin", limit: 1, special: 11, description: "#1a0a33" }
      ],
      Potions: [
        { icon: "ğŸš€ğŸ§ª", price: 10_000_000_000_000_000_000_000_000n, name: "Galaxy Potion", limit: 999, special: 8, description: "2x odds for Galactic trait" }
      ]
    }
  },
  "glitched": {
    displayName: "âšœï¸ Glitched Shop",
    activeWhen: () => currentAdminEvent && currentAdminEvent.name === "Glitched",
    items: {
      Swords: [
        { icon: "âšœï¸ğŸ—¡ï¸", price: 10_000_000_000_000_000_000_000_000n, name: "Glitched Sword", limit: 1, special: 6, description: "6 damage" }
      ],
      Relics: [
        { icon: "âšœï¸ğŸ“¿", price: 10_000_000_000_000_000_000n, name: "Glitched Relic", limit: 1, special: 1.35, description: "1.35x money" }
      ],
      Eggs: [
        { icon: "âšœï¸ğŸ¥š", price: 100_000_000_000_000_000_000_000_000n, name: "Glitched Egg", limit: 999, special: 1, description: "5 Glitched Pets" }
      ],
      Skins: [
        { icon: "âšœï¸ğŸ’", price: 100_000_000_000_000_000_000n, name: "Glitched Skin", limit: 1, special: 12, description: "#00ff00" }
      ],
      Potions: [
        { icon: "âšœï¸ğŸ§ª", price: 1_000_000_000_000_000_000_000n, name: "Glitched Potion", limit: 999, special: 9, description: "2x odds for Glitched trait" }
      ]
    }
  },
  "disco": {
    displayName: "ğŸª© Disco Shop",
    activeWhen: () => currentAdminEvent && currentAdminEvent.name === "Disco",
    items: {
      Swords: [
        { icon: "ğŸª©ğŸ—¡ï¸", price: 1_000_000_000_000_000_000n, name: "Disco Sword", limit: 1, special: 4, description: "4 damage" }
      ],
      Relics: [
        { icon: "ğŸª©ğŸ“¿", price: 1_000_000_000_000_000_000_000_000_000_000n, name: "Disco Relic", limit: 1, special: 1.7, description: "1.7x money" }
      ],
      Eggs: [
        { icon: "ğŸª©ğŸ¥š", price: 100_000_000_000_000_000_000_000_000_000n, name: "Disco Egg", limit: 999, special: 1, description: "5 Disco Pets" }
      ],
      Skins: [
        { icon: "ğŸª©ğŸ’", price: 1_000_000_000_000_000_000_000_000_000_000_000n, name: "Disco Skin", limit: 1, special: 13, description: "#ff00ff" }
      ],
      Potions: [
        { icon: "ğŸª©ğŸ§ª", price: 1_000_000_000_000_000_000_000_000n, name: "Disco Potion", limit: 999, special: 10, description: "2x odds for Disco trait" }
      ]
    }
  },
  "bloodmoon": {
    displayName: "ğŸŒ• Bloodmoon Shop",
    activeWhen: () => currentAdminEvent && currentAdminEvent.name === "Bloodmoon",
    items: {
      Swords: [
        { icon: "ğŸŒ•ğŸ—¡ï¸", price: 100_000_000_000_000_000_000_000_000_000n, name: "Bloodmoon Sword", limit: 1, special: 6, description: "6 damage" }
      ],
      Relics: [
        { icon: "ğŸŒ•ğŸ“¿", price: 100_000_000_000_000_000_000_000_000n, name: "Bloodmoon Relic", limit: 1, special: 1.46, description: "1.46x money" }
      ],
      Eggs: [
        { icon: "ğŸŒ•ğŸ¥š", price: 1_000_000_000_000_000_000_000_000_000_000n, name: "Bloodmoon Egg", limit: 999, special: 1, description: "5 Bloodmoon Pets" }
      ],
      Skins: [
        { icon: "ğŸŒ•ğŸ’", price: 1_000_000_000_000_000_000_000_000_000_000_000n, name: "Bloodmoon Skin", limit: 1, special: 14, description: "#8B0000" }
      ],
      Potions: [
        { icon: "ğŸŒ•ğŸ§ª", price: 1_000_000_000_000_000_000_000_000n, name: "Bloodmoon Potion", limit: 999, special: 11, description: "2x odds for Bloodmoon trait" }
      ]
    }
  }
};
// Add new pets to database
petDatabase["Sunny Egg"] = [
  { name: "Sunny Yellow Cube", color: "#FFF917", icon: "â˜€ï¸ğŸŸ¨", ability: "day_income_boost", value: 1.20, chance: 0.60, description: "+20% income during day" },
  { name: "Red Orange Cube", color: "#FF6B35", icon: "ğŸŸ§â˜€ï¸", ability: "day_speed_boost", value: 1.30, chance: 0.39, description: "+30% speed during day" },
  { name: "Sunny Red Cube", color: "#FF4500", icon: "ğŸŸ¥â˜€ï¸", ability: "ember_giver", value: 1, chance: 0.01, description: "Gives Ember mutation (10min)" }
];

petDatabase["Night Egg"] = [
  { name: "Onyx Cube", color: "#0a0a0a", icon: "â¬›ğŸŒ™", ability: "night_income_boost", value: 1.30, chance: 0.50, description: "+30% income during night" },
  { name: "Crow Cube", color: "#1c1c1c", icon: "ğŸ¦â€â¬›", ability: "night_speed_boost", value: 1.40, chance: 0.40, description: "+40% speed during night" },
  { name: "Coal Cube", color: "#3d3d3d", icon: "ğŸª¨", ability: "cooldown_reducer", value: 0.10, chance: 0.099, description: "-10% cooldowns for pets" },
  { name: "Obsidian Cube", color: "#000000", icon: "ğŸ’ğŸŒ™", ability: "mutation_giver", value: 1, chance: 0.001, description: "Random mutations (5min)" }
];

// Add new skins
skins[6] = { color: "#FFF917" }; // Sunny
skins[7] = { color: "#312F36" }; // Night
// Make pet functions globally accessible
window.togglePetEquip = togglePetEquip;
window.deletePet = deletePet;
const playerInventory = {
  Swords: [],
  Relics: [],
  Eggs: [],
  Skins: [],
  Potions: []
};

// === ğŸ¦´ DROP LIMITS ===
const dropLimits = {
  bones: 999,
  relic: 1,
  skin: 1,
  cube: 1
};



// Buy items from event shops
function buyEventItem(eventKey, category, item, skipOdds = false) {
  const limit = (category === "Eggs" || category === "Potions") ? 999n : 1n;
  const inventoryKey = item.name;
  const owned = BigInt(inventory[inventoryKey] || 0n);

  if (owned >= limit) {
    alert(`You already own the maximum number of ${item.name}s!`);
    return;
  }

  if (money < item.price) {
    alert(`Not enough money to buy ${item.name}!`);
    return;
  }

  // âœ… NEW: Show odds before purchase (unless shift is held)
  if (category === "Eggs" && !skipOdds) {
    const oddsInfo = showEggOdds(item.name);
    const confirmPurchase = confirm(`${oddsInfo}\nPurchase ${item.name} for ${formatBigInt(item.price)}?`);
    
    if (!confirmPurchase) {
      return; // User cancelled
    }
  }

  money -= item.price;
  inventory[inventoryKey] = owned + 1n;

  const existing = playerInventory[category].find(i => i.name === item.name);
  if (existing) {
    existing.count++;
  } else {
    playerInventory[category].push({
      icon: item.icon,
      name: item.name,
      count: 1,
      special: item.special
    });
  }

  updateDisplays();
  updateInventoryDisplay();
  updateShopDisplay();
}



// --- RENDER LEGEND UI ---
function renderLegendUI() {
  legendContainer.innerHTML = "";

  const itemsToShow = insideHouse ? shopItems : currentCubes();

  itemsToShow.forEach(c => {
    const row = document.createElement("div");
    row.className = "legend-row";
    row.innerHTML = `
      <div class="swatch" style="background:${c.color}"></div>
      <div class="legend-label">${insideHouse ? "SHOP: " : ""}${c.name} (${shortLabel(c.value)})</div>
      <div class="counter" id="cnt-${c.name.replace(/\s+/g, "_")}">${insideHouse ? "" : (legendCounts[c.name] || 0n)}</div>
    `;
    legendContainer.appendChild(row);

    // Click handler for shop
    if (insideHouse) {
      row.style.cursor = "pointer";
      row.addEventListener("click", () => {
        if (money >= c.value) {
          money -= c.value;
          alert(`âœ… Purchased ${c.name} for ${formatBigInt(c.value)} money!`);
          updateDisplays();
        } else {
          alert("âŒ Not enough money for ${c.name}");
        }
      });
    }
  });

  // Hide inventory when in shop
  document.getElementById("inventoryList").style.display = insideHouse ? "none" : "block";
}



// --- UPDATE HOUSE DEPOSIT & SHOP SWITCH ---
function checkHouseDeposit() {
  const nowInside = rectsOverlap(character, house);

  if (nowInside && !insideHouse) {
    insideHouse = true;
    document.getElementById("shopContainer").style.display = "block";
    updateShopDisplay(); // This will now show event shops if active

    if (character.assignedValue && money >= character.assignedValue) {
      money -= character.assignedValue;
      houseValue += character.assignedValue;
      legendCounts[character.assignedName] = (legendCounts[character.assignedName] || 0n) + 1n;
      recomputeIncome();
      updateDisplays();
      character.assignedValue = 0n;
      character.assignedName = null;
    }
  } else if (!nowInside && insideHouse) {
    insideHouse = false;
    document.getElementById("shopContainer").style.display = "none";
    renderLegendUI();
  }
}

/**
 * Recomputes the total income per second based on the current legend counts and income rates.
 * Applies the current weather multiplier to the total income.
 * Updates the income display with the new total income per second.
 * @returns {undefined}
 */
function recomputeIncome() {
  incomePerSec = 0n;

  for (let n in legendCounts) {
    incomePerSec += legendCounts[n] * (incomeRates[n] || 0n);
  }

  // === PET BONUSES ===
  let petIncomeMultiplier = 1.0;
  let petSpeedMultiplier = 1.0;
  let petCooldownReduction = 0;
  let giftMultiplier = 1.0; // NEW: For gift_multiplier ability
  
  equippedPets.forEach(pet => {
    // Passive income pets
    if (pet.ability === "passive_income") {
      petIncomeMultiplier *= pet.abilityValue;
    }
    
    // NEW: Gift multiplier (passive)
    if (pet.ability === "gift_multiplier") {
      giftMultiplier *= pet.abilityValue;
    }
    
    // Night bonus pet (only active during night)
    if (pet.ability === "night_bonus" && dayNightCycle.current === "night") {
      petIncomeMultiplier *= pet.abilityValue;
    }
    // Galactic event income boost
    if (pet.ability === "galactic_income" && currentAdminEvent && currentAdminEvent.name === "Galactic") {
      petIncomeMultiplier *= pet.abilityValue;
    }
    
    // Galactic warp speed
    if (pet.ability === "warp_speed" && currentAdminEvent && currentAdminEvent.name === "Galactic") {
      petSpeedMultiplier *= pet.abilityValue;
    }
    
    // Glitched event income boost
    if (pet.ability === "glitch_income" && currentAdminEvent && currentAdminEvent.name === "Glitched") {
      petIncomeMultiplier *= pet.abilityValue;
    }
    
    // Disco event income boost
    if (pet.ability === "disco_income" && currentAdminEvent && currentAdminEvent.name === "Disco") {
      petIncomeMultiplier *= pet.abilityValue;
    }
    
    // Disco rhythm boost
    if (pet.ability === "rhythm_boost" && currentAdminEvent && currentAdminEvent.name === "Disco") {
      petSpeedMultiplier *= pet.abilityValue;
    }
    
    // Bloodmoon event income boost
    if (pet.ability === "bloodmoon_income" && currentAdminEvent && currentAdminEvent.name === "Bloodmoon") {
      petIncomeMultiplier *= pet.abilityValue;
    }
    
    // Bloodmoon shadow strike (damage boost)
    if (pet.ability === "shadow_strike" && currentAdminEvent && currentAdminEvent.name === "Bloodmoon") {
      // This will be used in combat calculations
      window.bloodmoonDamageBoost = pet.abilityValue;
    }
    
    // Blood pact (drop multiplier)
    if (pet.ability === "blood_pact" && currentAdminEvent && currentAdminEvent.name === "Bloodmoon") {
      window.bloodPactActive = true;
      window.bloodPactMultiplier = pet.abilityValue;
    }
  if (pet.ability === "divine_income") {
    petIncomeMultiplier *= pet.abilityValue; // 2.0x
  }
  
  if (pet.ability === "celestial_speed") {
    petSpeedMultiplier *= pet.abilityValue; // 2.5x
  }
  
  if (pet.ability === "archangel_power") {
    window.archangelDamageBoost = pet.abilityValue; // 5x
  }
  
  if (pet.ability === "heavenly_king") {
    petIncomeMultiplier *= pet.abilityValue; // 3x
    petSpeedMultiplier *= pet.abilityValue; // 3x
    window.heavenlyKingDamageBoost = pet.abilityValue; // 3x
  }
  // === ENCHANTMENT BONUSES ===
equippedPets.forEach(pet => {
  if (pet.enchantment) {
    const ench = pet.enchantment;
    const boost = ench.data.boost;
    
    switch (ench.type) {
      case "Money Income":
        petIncomeMultiplier *= boost;
        break;
      case "Speed":
        petSpeedMultiplier *= boost;
        break;
      case "Sword Damage":
        if (!window.enchantDamageBoost) window.enchantDamageBoost = 1;
        window.enchantDamageBoost *= boost;
        break;
      case "Luck":
        if (!window.enchantLuckBoost) window.enchantLuckBoost = 1;
        window.enchantLuckBoost *= boost;
        break;
      case "Ultimate":
        petIncomeMultiplier *= boost;
        petSpeedMultiplier *= boost;
        if (!window.enchantDamageBoost) window.enchantDamageBoost = 1;
        window.enchantDamageBoost *= boost;
        break;
    }
  }
});
  });
  
  // Store gift multiplier globally for drop calculations
  window.giftDropMultiplier = giftMultiplier;
  
  // Update character speed with pet bonuses
  character.speed = 250 * petSpeedMultiplier;

const adminMultiplier = currentAdminEvent ? currentAdminEvent.incomeBoost : 1;
const christmasMultiplier = christmasEvent.active ? christmasEvent.incomeBoost : 1;
const heavenlyMultiplier = heavenlyEvent.active ? heavenlyEvent.incomeBoost : 1;
  
const totalMultiplier = weatherMultiplier * equippedRelicSpecial * petIncomeMultiplier * 
                        (potionActive ? potionMultiplier : 1) * adminMultiplier * 
                        rebirthMultiplier * christmasMultiplier * heavenlyMultiplier;

  const adjustedIncome = BigInt(Math.floor(Number(incomePerSec) * totalMultiplier));
  
  incomePerSec = adjustedIncome;
  
  const shortText = formatBigInt(adjustedIncome);
  const fullText = formatBigInt2(adjustedIncome);

  incomeDisplay.textContent = "Income/sec: " + shortText;
  incomeDisplay.title = fullText;

  if (potionActive) {
    const timeLeft = Math.ceil((potionEndTime - Date.now()) / 1000);
    incomeDisplay.textContent += ` ğŸ§ª(${timeLeft}s)`;
  }
  
  if (christmasEvent.active) {
    incomeDisplay.textContent += ` ğŸ„`;
  }
}


/**
 * Triggers a random weather event which affects income and speed.
 * Prevents overlap of weather events by checking if there is a current event.
 * Logs the name of the weather event to the console.
 * Sets the background color of the document body to the weather event's background color.
 * Sets the alpha value of the weather overlay to 0.3.
 * Ends the weather event after its specified duration using setTimeout.
 * @returns {undefined}
 */
function triggerWeatherEvent() {
  if (currentWeather) return;
  const w = weatherEvents[Math.floor(Math.random() * weatherEvents.length)];
  currentWeather = w.name;
  weatherMultiplier = w.incomeBoost;
  speedMultiplier = w.speedBoost;
  document.body.style.background = w.bg;
  weatherOverlayAlpha = 0.3;
  console.log(`ğŸŒ¦ Weather started: ${w.name}`);

  weatherTimer = setTimeout(endWeatherEvent, w.duration);
  startWeatherAnimation(currentWeather);
  updateEventIndicator(); // â† ADD THIS
}

/**
 * Ends the current weather event by resetting its associated multipliers and
 * background style, and logging a message to the console.
 * This function is called automatically after the duration of the weather event.
 * @returns {undefined}
 */
function endWeatherEvent() {
  console.log(`ğŸŒ¤ Weather ended: ${currentWeather}`);
  currentWeather = null;
  weatherMultiplier = 1;
  speedMultiplier = 1;
  document.body.style.background = "linear-gradient(#111,#07101a)";
  weatherOverlayAlpha = 0;

  stopWeatherAnimation();
  updateEventIndicator(); // â† ADD THIS
}
// === CHRISTMAS EVENT FUNCTIONS ===
function startChristmasEvent() {
  if (christmasEvent.active) return;
  
  christmasEvent.active = true;
  christmasEvent.lastTrigger = Date.now();
  
  console.log("ğŸ„ Christmas Event Started! +20% income for 10 minutes");
  
  // Generate snowflakes
  generateSnowflakes();
  
  // Show shop
  updateShopDisplay();
  
  recomputeIncome();
  updateEventIndicator();
  
  // End after duration
  setTimeout(() => {
    endChristmasEvent();
  }, christmasEvent.duration);
}

function endChristmasEvent() {
  christmasEvent.active = false;
  christmasEvent.snowflakes = [];
  
  console.log("ğŸ„ Christmas Event Ended");
  
  updateShopDisplay();
  recomputeIncome();
  updateEventIndicator();
}

function generateSnowflakes() {
  christmasEvent.snowflakes = [];
  for (let i = 0; i < 50; i++) {
    christmasEvent.snowflakes.push({
      x: Math.random() * W,
      y: Math.random() * H - H, // Start above screen
      size: 2 + Math.random() * 4,
      speed: 30 + Math.random() * 50,
      sway: Math.random() * 2 - 1,
      swaySpeed: 1 + Math.random() * 2
    });
  }
}

function updateSnowflakes(dt) {
  if (!christmasEvent.active) return;
  
  christmasEvent.snowflakes.forEach(flake => {
    flake.y += flake.speed * dt;
    flake.x += Math.sin(flake.y * 0.01 * flake.swaySpeed) * flake.sway;
    
    // Wrap around screen
    if (flake.y > H) {
      flake.y = -10;
      flake.x = Math.random() * W;
    }
    
    if (flake.x < 0) flake.x = W;
    if (flake.x > W) flake.x = 0;
    
    // Check collision with character
    if (rectsOverlap(
      { x: flake.x - flake.size, y: flake.y - flake.size, w: flake.size * 2, h: flake.size * 2 },
      character
    )) {
      christmasEvent.snowCollected++;
      dropCounters["â„ï¸ Snowflakes"]++;
      inventory["â„ï¸ Snowflakes"]++;
      
      // Respawn snowflake
      flake.y = -10;
      flake.x = Math.random() * W;
      
      updateInventoryDisplay();
    }
  });
}

function drawSnowflakes(ctx) {
  if (!christmasEvent.active) return;
  
  ctx.save();
  ctx.fillStyle = "white";
  christmasEvent.snowflakes.forEach(flake => {
    ctx.globalAlpha = 0.8;
    ctx.beginPath();
    ctx.arc(flake.x, flake.y, flake.size, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;
  ctx.restore();
}

// Auto-trigger Christmas event every hour
setInterval(() => {
  if (!christmasEvent.active && Date.now() - christmasEvent.lastTrigger >= christmasEvent.interval) {
    startChristmasEvent();
  }// === HEAVENLY EVENT FUNCTIONS ===
function useHeavenlyTotem() {
  const totem = playerInventory.Relics.find(i => i.name === "Heavenly Totem");
  if (totem && totem.count > 0 && !heavenlyEvent.active) {
    totem.count--;
    if (totem.count === 0) {
      const index = playerInventory.Relics.indexOf(totem);
      if (index > -1) {
        playerInventory.Relics.splice(index, 1);
      }
    }
    startHeavenlyEvent();
    updateInventoryDisplay();
  } else if (heavenlyEvent.active) {
    alert("âœ¨ Heavenly Event already active!");
  } else {
    alert("âŒ No Heavenly Totem available!");
  }
}

// Make globally accessible
window.useHeavenlyTotem = useHeavenlyTotem;
}, 60000); // Check every minute
// === USE ENCHANT RELIC FUNCTION ===
function useEnchantRelic() {
  const relic = playerInventory.Relics.find(i => i.name === "Enchant Relic");
  
  if (!relic || relic.count <= 0) {
    alert("âŒ No Enchant Relics available!");
    return;
  }
  
  if (enchantmentSystem.hasEnchantRelic) {
    alert("âœ¨ Enchant Relic already active!\nIt will be consumed on your next enchant.");
    return;
  }
  
  enchantmentSystem.hasEnchantRelic = true;
  alert("âœ¨ Enchant Relic activated!\n\nğŸ€ Next enchant has boosted odds for higher tiers!\n(Consumed after 1 enchant)");
  updateInventoryDisplay();
  updateEnchantUI();
}
// === CRAFTING SYSTEM FUNCTIONS ===

function unlockCraftingRecipe(recipeName) {
  const recipe = craftingSystem.recipes[recipeName];
  if (!recipe) {
    console.error("Recipe not found:", recipeName);
    return false;
  }
  
  // Check if already unlocked
  if (craftingSystem.unlockedRecipes.includes(recipeName)) {
    return true;
  }
  
  // Auto-unlock recipes don't need unlock items
  if (recipe.autoUnlock) {
    craftingSystem.unlockedRecipes.push(recipeName);
    return true;
  }
  
  const unlockItem = recipe.unlockItem;
  
  // Check in materials
  if (craftingSystem.materials[unlockItem] && craftingSystem.materials[unlockItem] > 0) {
    craftingSystem.unlockedRecipes.push(recipeName);
    console.log(`ğŸ”“ Unlocked recipe: ${recipeName} (via materials)`);
    return true;
  }
  
  // Check in inventory (for eggs, relics, swords, skins, potions)
  for (let category in playerInventory) {
    const item = playerInventory[category].find(i => i.name === unlockItem);
    if (item && item.count > 0) {
      craftingSystem.unlockedRecipes.push(recipeName);
      console.log(`ğŸ”“ Unlocked recipe: ${recipeName} (via ${category})`);
      return true;
    }
  }
  
  // Check for pet unlock (e.g., "Leviathan Pet" or "King Leviathan")
  if (unlockItem.includes("Pet") || unlockItem.includes("King") || unlockItem.includes("Emperor")) {
    const petNameVariations = [
      unlockItem,
      unlockItem.replace(" Pet", ""),
      unlockItem.replace("Pet", "")
    ];
    
    const hasPet = playerPets.some(p => 
      petNameVariations.some(variation => p.name.includes(variation))
    );
    
    if (hasPet) {
      craftingSystem.unlockedRecipes.push(recipeName);
      console.log(`ğŸ”“ Unlocked recipe: ${recipeName} (via pet)`);
      return true;
    }
  }
  
  return false;
}

function canCraftItem(recipeName) {
  const recipe = craftingSystem.recipes[recipeName];
  if (!recipe) return false;
  
  // Check if recipe is unlocked
  if (!recipe.autoUnlock && !craftingSystem.unlockedRecipes.includes(recipeName)) {
    return false;
  }
  
  // Check money
  if (money < recipe.moneyCost) {
    return false;
  }
  
  // Check materials
  for (let material in recipe.materials) {
    const needed = recipe.materials[material];
    const owned = craftingSystem.materials[material] || 0;
    
    // Special case: Check if material is an egg/pet in inventory
    if (material === "King Leviathan") {
      const hasPet = playerPets.some(p => p.name === material);
      if (!hasPet) return false;
    } else if (material.includes("Egg") || material.includes("Skin")) {
      // Check in player inventory
      let found = false;
      for (let category in playerInventory) {
        const item = playerInventory[category].find(i => i.name === material);
        if (item && item.count >= needed) {
          found = true;
          break;
        }
      }
      if (!found && owned < needed) return false;
    } else {
      if (owned < needed) return false;
    }
  }
  
  return true;
}

function craftItem(recipeName) {
  const recipe = craftingSystem.recipes[recipeName];
  if (!recipe) {
    alert("âŒ Recipe not found!");
    return;
  }
  
  // Try to unlock recipe first
  if (!recipe.autoUnlock && !craftingSystem.unlockedRecipes.includes(recipeName)) {
    const unlocked = unlockCraftingRecipe(recipeName);
    if (!unlocked) {
      alert(`ğŸ”’ Recipe locked! Need: ${recipe.unlockItem}`);
      return;
    }
  }
  
  // Check if can craft
  if (!canCraftItem(recipeName)) {
    alert(`âŒ Not enough materials or money to craft ${recipeName}!`);
    return;
  }
  
  // Build materials list for confirmation
  let materialsText = "";
  for (let material in recipe.materials) {
    materialsText += `\nâ€¢ ${material} x${recipe.materials[material]}`;
  }
  
  const confirm = window.confirm(
    `ğŸ”¨ Craft ${recipe.icon} ${recipeName}?\n\nMaterials needed:${materialsText}\nğŸ’° Money: ${formatBigInt(recipe.moneyCost)}\n\nContinue?`
  );
  
  if (!confirm) return;
  
  // Consume materials
  for (let material in recipe.materials) {
    const needed = recipe.materials[material];
    
    if (material === "King Leviathan") {
      // Remove pet
      const petIndex = playerPets.findIndex(p => p.name === material);
      if (petIndex > -1) {
        playerPets.splice(petIndex, 1);
        equippedPets = equippedPets.filter(p => p.name !== material);
      }
    } else if (material.includes("Egg") || material.includes("Skin") || material.includes("Potion")) {
      // Check player inventory first
      let consumed = false;
      for (let category in playerInventory) {
        const item = playerInventory[category].find(i => i.name === material);
        if (item && item.count >= needed) {
          item.count -= needed;
          if (item.count <= 0) {
            const index = playerInventory[category].indexOf(item);
            if (index > -1) playerInventory[category].splice(index, 1);
          }
          consumed = true;
          break;
        }
      }
      // If not in inventory, consume from materials
      if (!consumed) {
        craftingSystem.materials[material] = (craftingSystem.materials[material] || 0) - needed;
      }
    } else {
      // Normal materials
      craftingSystem.materials[material] = (craftingSystem.materials[material] || 0) - needed;
    }
  }
  
  // Consume money
  money -= recipe.moneyCost;
  
// Give crafted item
if (recipe.type === "Materials" || recipe.type === "Miscellaneous" || recipe.type === "Totems") {
  // Add to materials
  craftingSystem.materials[recipeName] = (craftingSystem.materials[recipeName] || 0) + 1;
  console.log(`âœ… Added ${recipeName} to materials`);
} else {
  // Add to player inventory
  // Ensure category exists
  if (!playerInventory[recipe.type]) {
    playerInventory[recipe.type] = [];
  }
  
  const existing = playerInventory[recipe.type].find(i => i.name === recipeName);
  if (existing) {
    existing.count++;
    console.log(`âœ… Added ${recipeName} to ${recipe.type} (now ${existing.count})`);
  } else {
    playerInventory[recipe.type].push({
      icon: recipe.icon,
      name: recipeName,
      count: 1,
      special: recipe.special,
      equipped: false
    });
    console.log(`âœ… Created new ${recipeName} in ${recipe.type}`);
  }
}
  
  console.log(`âœ… Crafted: ${recipeName}`);
  
  updateDisplays();
  updateInventoryDisplay();
  updateCraftingDisplay();
  
  alert(`âœ… Successfully crafted ${recipe.icon} ${recipeName}!`);
}

function buyMaterial(materialName) {
  const material = merchantShop[materialName];
  if (!material) {
    alert("âŒ Material not found!");
    return;
  }
  
  if (money < material.price) {
    alert(`âŒ Not enough money! Need ${formatBigInt(material.price)}`);
    return;
  }
  
  const confirm = window.confirm(
    `ğŸ’° Buy ${material.icon} ${materialName}?\n\nPrice: ${formatBigInt(material.price)}`
  );
  
  if (!confirm) return;
  
  money -= material.price;
  craftingSystem.materials[materialName] = (craftingSystem.materials[materialName] || 0) + 1;
  
  updateDisplays();
  updateCraftingDisplay();
  
  console.log(`âœ… Bought: ${materialName}`);
}

function showCraftingMenu() {
  if (!craftingSystem.unlocked) {
    alert("ğŸ”’ Crafting unlocks at Rebirth 1!");
    return;
  }
  
  // AUTO-CHECK: Try to unlock recipes based on current inventory
  for (let recipeName in craftingSystem.recipes) {
    if (!craftingSystem.unlockedRecipes.includes(recipeName)) {
      unlockCraftingRecipe(recipeName);
    }
  }
  
  const overlay = document.createElement('div');
  overlay.id = 'craftingOverlay';
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.9);
    z-index: 10000;
    overflow-y: auto;
    padding: 20px;
  `;
  
  let html = `
    <div style="max-width: 1200px; margin: 0 auto; background: #1a1a2e; border-radius: 15px; padding: 20px; color: white;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 style="color: #FFD700; margin: 0;">ğŸ”¨ Crafting System</h2>
        <button onclick="closeCraftingMenu()" style="background: #8B0000; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 16px;">Close</button>
      </div>
      
      <div style="display: flex; gap: 10px; margin-bottom: 20px;">
        <button onclick="showCraftingTab('recipes')" id="tabRecipes" class="craft-tab" style="flex: 1; padding: 10px; background: #2a5298; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;">ğŸ“œ Recipes</button>
        <button onclick="showCraftingTab('merchant')" id="tabMerchant" class="craft-tab" style="flex: 1; padding: 10px; background: #555; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;">ğŸ›’ Merchant</button>
        <button onclick="showCraftingTab('materials')" id="tabMaterials" class="craft-tab" style="flex: 1; padding: 10px; background: #555; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;">ğŸ“¦ Materials</button>
      </div>
      
      <div id="craftingContent"></div>
    </div>
  `;
  
  overlay.innerHTML = html;
  document.body.appendChild(overlay);
  
  showCraftingTab('recipes');
}

function showCraftingTab(tab) {
  // Update tab buttons
  document.querySelectorAll('.craft-tab').forEach(btn => {
    btn.style.background = '#555';
  });
  
  if (tab === 'recipes') {
    document.getElementById('tabRecipes').style.background = '#2a5298';
    displayRecipes();
  } else if (tab === 'merchant') {
    document.getElementById('tabMerchant').style.background = '#2a5298';
    displayMerchant();
  } else if (tab === 'materials') {
    document.getElementById('tabMaterials').style.background = '#2a5298';
    displayMaterials();
  }
}

function displayRecipes() {
  const content = document.getElementById('craftingContent');
  if (!content) return;
  
  let html = `<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px;">`;
  
  for (let recipeName in craftingSystem.recipes) {
    const recipe = craftingSystem.recipes[recipeName];
    const isUnlocked = recipe.autoUnlock || craftingSystem.unlockedRecipes.includes(recipeName);
    const canCraft = canCraftItem(recipeName);
    
    html += `
      <div style="background: ${canCraft ? '#1a4d2e' : '#2a2a2a'}; padding: 15px; border-radius: 10px; border: 2px solid ${isUnlocked ? '#FFD700' : '#555'};">
        <div style="font-size: 32px; text-align: center; margin-bottom: 10px;">${recipe.icon}</div>
        <h3 style="margin: 0 0 10px 0; text-align: center; color: ${isUnlocked ? '#FFD700' : '#888'};">${recipeName}</h3>
        
        ${!isUnlocked ? `<p style="color: #ff6b6b; font-size: 12px; text-align: center;">ğŸ”’ Unlock: ${recipe.unlockItem}</p>` : ''}
        
        <div style="font-size: 12px; margin: 10px 0;">
          <strong>Materials:</strong><br>
    `;
    
    for (let material in recipe.materials) {
      const needed = recipe.materials[material];
      const owned = craftingSystem.materials[material] || 0;
      const hasEnough = owned >= needed;
      
      html += `<span style="color: ${hasEnough ? '#90EE90' : '#ff6b6b'};">â€¢ ${material}: ${owned}/${needed}</span><br>`;
    }
    
    html += `
          <strong>Cost:</strong> ${formatBigInt(recipe.moneyCost)}
        </div>
        
        <button 
          onclick="craftItem('${recipeName}')" 
          style="width: 100%; padding: 8px; background: ${canCraft ? '#228B22' : '#555'}; color: white; border: none; border-radius: 5px; cursor: ${canCraft ? 'pointer' : 'not-allowed'}; font-weight: bold;"
          ${!canCraft ? 'disabled' : ''}
        >
          ${canCraft ? 'ğŸ”¨ Craft' : 'âŒ Cannot Craft'}
        </button>
      </div>
    `;
  }
  
  html += `</div>`;
  content.innerHTML = html;
}

function displayMerchant() {
  const content = document.getElementById('craftingContent');
  if (!content) return;
  
  let html = `<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 15px;">`;
  
  for (let materialName in merchantShop) {
    const material = merchantShop[materialName];
    const canAfford = money >= material.price;
    
    html += `
      <div style="background: #2a2a2a; padding: 15px; border-radius: 10px; text-align: center;">
        <div style="font-size: 32px; margin-bottom: 10px;">${material.icon}</div>
        <h4 style="margin: 0 0 10px 0;">${materialName}</h4>
        <p style="font-size: 14px; color: #FFD700; margin: 5px 0;">ğŸ’° ${formatBigInt(material.price)}</p>
        <button 
          onclick="buyMaterial('${materialName}')" 
          style="width: 100%; padding: 8px; background: ${canAfford ? '#2a5298' : '#555'}; color: white; border: none; border-radius: 5px; cursor: ${canAfford ? 'pointer' : 'not-allowed'}; font-weight: bold; margin-top: 10px;"
          ${!canAfford ? 'disabled' : ''}
        >
          ${canAfford ? 'ğŸ’° Buy' : 'âŒ Too Expensive'}
        </button>
      </div>
    `;
  }
  
  html += `</div>`;
  content.innerHTML = html;
}

function displayMaterials() {
  const content = document.getElementById('craftingContent');
  if (!content) return;
  
  let html = `<div style="background: #2a2a2a; padding: 20px; border-radius: 10px;">`;
  html += `<h3 style="color: #FFD700; margin-top: 0;">ğŸ“¦ Your Materials</h3>`;
  
  // Collect all materials (including zero counts for visibility)
  const allMaterialNames = new Set();
  
  // Add from merchantShop
  for (let name in merchantShop) {
    allMaterialNames.add(name);
  }
  
  // Add from craftingSystem.materials
  for (let name in craftingSystem.materials) {
    if (craftingSystem.materials[name] > 0) {
      allMaterialNames.add(name);
    }
  }
  
  // Add boss drops
  const bossDrops = [
    "Phoenix Feather", "Phoenix Ember",
    "Leviathan Scale", "Leviathan Heart", "Leviathan Fang",
    "Enchanted Leviathan Scale", "Enchanted Leviathan Heart", "Enchanted Leviathan Fang"
  ];
  bossDrops.forEach(name => allMaterialNames.add(name));
  
  // Convert to array and sort
  const sortedMaterials = Array.from(allMaterialNames).sort();
  
  if (sortedMaterials.length === 0) {
    html += `<p style="color: #888; text-align: center;">No materials yet. Buy from the merchant!</p>`;
  } else {
    html += `<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 10px;">`;
    
    sortedMaterials.forEach(materialName => {
      const count = craftingSystem.materials[materialName] || 0;
      
      // Only show if count > 0
      if (count > 0) {
        const materialInfo = merchantShop[materialName] || craftingSystem.recipes[materialName];
        let icon = "ğŸ“¦";
        
        // Try to find icon
        if (materialInfo) {
          icon = materialInfo.icon;
        }
        
        html += `
          <div style="background: #1a1a2e; padding: 10px; border-radius: 8px; text-align: center; border: 2px solid #FFD700;">
            <div style="font-size: 24px;">${icon}</div>
            <div style="font-size: 12px; margin-top: 5px;">${materialName}</div>
            <div style="color: #FFD700; font-weight: bold; margin-top: 5px;">x${count}</div>
          </div>
        `;
      }
    });
    
    html += `</div>`;
  }
  
  html += `</div>`;
  content.innerHTML = html;
}

function updateCraftingDisplay() {
  const content = document.getElementById('craftingContent');
  if (!content) return;
  
  // Re-render current tab
  const recipesTab = document.getElementById('tabRecipes');
  const merchantTab = document.getElementById('tabMerchant');
  const materialsTab = document.getElementById('tabMaterials');
  
  if (recipesTab && recipesTab.style.background === 'rgb(42, 82, 152)') {
    displayRecipes();
  } else if (merchantTab && merchantTab.style.background === 'rgb(42, 82, 152)') {
    displayMerchant();
  } else if (materialsTab && materialsTab.style.background === 'rgb(42, 82, 152)') {
    displayMaterials();
  }
}

function closeCraftingMenu() {
  const overlay = document.getElementById('craftingOverlay');
  if (overlay) overlay.remove();
}
// === LEVIATHAN BOSS FUNCTIONS ===

function useLeviathanTotem() {
  const totem = craftingSystem.materials["Leviathan Totem"];
  if (!totem || totem < 1) {
    alert("âŒ No Leviathan Totems available!");
    return;
  }
  
  if (leviathanBoss.visible || enchantedLeviathanBoss.visible) {
    alert("âš ï¸ Leviathan already active!");
    return;
  }
  
  // Check if player has harpoon
  const hasHarpoon = craftingSystem.materials["Harpoon"] && craftingSystem.materials["Harpoon"] > 0;
  if (!hasHarpoon) {
    alert("âŒ You need a Harpoon to fight the Leviathan!\n\nCraft one in the Crafting menu.");
    return;
  }
  
  if (!confirm("ğŸŒŠ Summon the Leviathan?\n\nâš ï¸ This is a dangerous boss fight!\nâ€¢ You have 5 HP\nâ€¢ Leviathan has 50 HP\nâ€¢ Use Harpoon to attack (3 damage)\nâ€¢ Long range attacks!\n\nReady?")) {
    return;
  }
  
  // Consume totem
  craftingSystem.materials["Leviathan Totem"]--;
  
  // Equip harpoon
  harpoon.equipped = true;
  
  // Reset player HP
  leviathanBoss.playerCurrentHP = leviathanBoss.playerMaxHP;
  
  // Spawn Leviathan on right side
  leviathanBoss.x = W - leviathanBoss.w - 50;
  leviathanBoss.y = H / 2 - leviathanBoss.h / 2;
  leviathanBoss.visible = true;
  leviathanBoss.hitsRemaining = leviathanBoss.hitsToDie;
  leviathanBoss.playerHits = 0;
  leviathanBoss.enchanted = false;
  leviathanBoss.canSummonEnchanted = false;
  
  // Start Forgotten Altar event
  startForgottenAltar();
  
  console.log("ğŸŒŠ Leviathan summoned!");
  updateCraftingDisplay();
}
function equipLeviathanArmor() {
  const armorCount = craftingSystem.materials["Leviathan Armor"] || 0;
  
  if (armorCount <= 0) {
    alert("âŒ No Leviathan Armor available!");
    return;
  }
  
  if (window.leviathanArmorEquipped) {
    alert("âš ï¸ Leviathan Armor already equipped!");
    return;
  }
  
  // Consume armor
  craftingSystem.materials["Leviathan Armor"]--;
  
  // Apply armor effects
  window.leviathanArmorEquipped = true;
  window.leviathanArmorDamageReduction = 0.5; // 50% damage reduction
  leviathanBoss.playerMaxHP += 2;
  leviathanBoss.playerCurrentHP = leviathanBoss.playerMaxHP;
  
  console.log("ğŸ›¡ï¸ Leviathan Armor equipped! +2 HP, 50% damage reduction");
  
  updateCraftingDisplay();
  updateInventoryDisplay();
  
  alert("âœ… Leviathan Armor Equipped!\n\nğŸ›¡ï¸ Effects:\nâ€¢ +2 Max HP (now " + leviathanBoss.playerMaxHP + " HP)\nâ€¢ 50% damage reduction\nâ€¢ HP fully restored");
}

// Make globally accessible
window.equipLeviathanArmor = equipLeviathanArmor;
function startForgottenAltar() {
  forgottenAltar.active = true;
  document.body.style.background = forgottenAltar.background;
  
  console.log("â„ï¸ Forgotten Altar activated!");
  updateEventIndicator();
}

function endForgottenAltar() {
  forgottenAltar.active = false;
  document.body.style.background = "linear-gradient(#111,#07101a)";
  
  console.log("â„ï¸ Forgotten Altar ended");
  updateEventIndicator();
}

function useHarpoon() {
  if (!harpoon.equipped) {
    return;
  }
  
  const now = Date.now();
  if (now - harpoon.lastUse < harpoon.cooldown) {
    return; // Still on cooldown
  }
  
  // Check if in range of Leviathan
  let hitLeviathan = false;
  
  if (leviathanBoss.visible) {
    const dx = character.x - leviathanBoss.x;
    const dy = character.y - leviathanBoss.y;
    const distance = Math.hypot(dx, dy);
    
    if (distance < 250) { // Harpoon range
      leviathanBoss.hitsRemaining -= harpoon.damage;
      leviathanBoss.flash = true;
      hitLeviathan = true;
      
      spawnSlash(leviathanBoss.x + leviathanBoss.w / 2, leviathanBoss.y + leviathanBoss.h / 2, Math.random() * Math.PI * 2);
      
      setTimeout(() => (leviathanBoss.flash = false), 150);
      
      console.log(`ğŸ”± Hit Leviathan! HP: ${leviathanBoss.hitsRemaining}/${leviathanBoss.hitsToDie}`);
      
      // Check if defeated
      if (leviathanBoss.hitsRemaining <= 0) {
        defeatLeviathan();
      }
    }
  }
  
  if (enchantedLeviathanBoss.visible) {
    const dx = character.x - enchantedLeviathanBoss.x;
    const dy = character.y - enchantedLeviathanBoss.y;
    const distance = Math.hypot(dx, dy);
    
    if (distance < 250) {
      enchantedLeviathanBoss.hitsRemaining -= harpoon.damage;
      enchantedLeviathanBoss.flash = true;
      hitLeviathan = true;
      
      spawnSlash(enchantedLeviathanBoss.x + enchantedLeviathanBoss.w / 2, enchantedLeviathanBoss.y + enchantedLeviathanBoss.h / 2, Math.random() * Math.PI * 2);
      
      setTimeout(() => (enchantedLeviathanBoss.flash = false), 150);
      
      console.log(`ğŸ”± Hit Enchanted Leviathan! HP: ${enchantedLeviathanBoss.hitsRemaining}/${enchantedLeviathanBoss.hitsToDie}`);
      
      if (enchantedLeviathanBoss.hitsRemaining <= 0) {
        defeatEnchantedLeviathan();
      }
    }
  }
  
  if (hitLeviathan) {
    harpoon.lastUse = now;
  }
}

function defeatLeviathan() {
  leviathanBoss.visible = false;
  leviathanBoss.canSummonEnchanted = true;
  leviathanBoss.enchantedSummonTimer = Date.now() + 10000; // 10 seconds
  
  console.log("ğŸŒŠ Leviathan defeated! 10 seconds to summon Enchanted Leviathan...");
  
  // Apply lucky star multiplier to drop chances
  const dropMultiplier = window.luckyStarActive ? window.luckyStarMultiplier : 1.0;
  
  const drops = [];
  
  // 100% Leviathan Scale
  drops.push("Leviathan Scale");
  craftingSystem.materials["Leviathan Scale"] = (craftingSystem.materials["Leviathan Scale"] || 0) + 1;
  
  // 10% Leviathan Heart
  if (Math.random() <= 0.10 * dropMultiplier) {
    drops.push("Leviathan Heart");
    craftingSystem.materials["Leviathan Heart"] = (craftingSystem.materials["Leviathan Heart"] || 0) + 1;
  }
  
  // 1% Leviathan Fang
  if (Math.random() <= 0.01 * dropMultiplier) {
    drops.push("Leviathan Fang");
    craftingSystem.materials["Leviathan Fang"] = (craftingSystem.materials["Leviathan Fang"] || 0) + 1;
  }
  
  bossDrops.push({
    x: leviathanBoss.x + leviathanBoss.w / 2,
    y: leviathanBoss.y,
    items: drops.map(d => `ğŸŒŠ ${d}`),
    timer: 5000,
    opacity: 1
  });
  
  alert(`ğŸŒŠ LEVIATHAN DEFEATED!\n\nDrops:\n${drops.map(d => `â€¢ ${d}`).join('\n')}\n\nâ±ï¸ You have 10 seconds to use an Enchant Relic to summon the Enchanted Leviathan!`);
  
  updateCraftingDisplay();
  
  // Check for enchanted summon
  setTimeout(() => {
    if (leviathanBoss.canSummonEnchanted) {
      leviathanBoss.canSummonEnchanted = false;
      endForgottenAltar();
      harpoon.equipped = false;
      console.log("â±ï¸ Time expired - no Enchanted Leviathan summoned");
    }
  }, 10000);
}

function summonEnchantedLeviathan() {
  if (!leviathanBoss.canSummonEnchanted) {
    alert("âŒ Cannot summon Enchanted Leviathan right now!");
    return;
  }
  
  // Check for Enchant Relic
  const hasRelic = playerInventory.Relics.find(i => i.name === "Enchant Relic" && i.count > 0);
  if (!hasRelic) {
    alert("âŒ Need an Enchant Relic to summon Enchanted Leviathan!");
    return;
  }
  
  if (!confirm("âœ¨ Summon ENCHANTED LEVIATHAN?\n\nâš ï¸ EXTREME DANGER!\nâ€¢ 100 HP (double health!)\nâ€¢ Stronger attacks!\nâ€¢ Better drops!\n\nThis will consume your Enchant Relic!\n\nContinue?")) {
    return;
  }
  
  // Consume Enchant Relic
  hasRelic.count--;
  if (hasRelic.count <= 0) {
    const index = playerInventory.Relics.indexOf(hasRelic);
    if (index > -1) {
      playerInventory.Relics.splice(index, 1);
    }
  }
  
  leviathanBoss.canSummonEnchanted = false;
  
  // Reset player HP
  leviathanBoss.playerCurrentHP = leviathanBoss.playerMaxHP;
  
  // Spawn Enchanted Leviathan
  enchantedLeviathanBoss.x = W - enchantedLeviathanBoss.w - 50;
  enchantedLeviathanBoss.y = H / 2 - enchantedLeviathanBoss.h / 2;
  enchantedLeviathanBoss.visible = true;
  enchantedLeviathanBoss.hitsRemaining = enchantedLeviathanBoss.hitsToDie;
  enchantedLeviathanBoss.playerHits = 0;
  
  harpoon.equipped = true;
  
  console.log("âœ¨ğŸŒŠ ENCHANTED LEVIATHAN SUMMONED!");
  updateInventoryDisplay();
}

function defeatEnchantedLeviathan() {
  enchantedLeviathanBoss.visible = false;
  harpoon.equipped = false;
  endForgottenAltar();
  
  console.log("âœ¨ğŸŒŠ Enchanted Leviathan defeated!");
  
  const dropMultiplier = window.luckyStarActive ? window.luckyStarMultiplier : 1.0;
  
  const drops = [];
  
  // 100% Enchanted Leviathan Scale
  drops.push("Enchanted Leviathan Scale");
  craftingSystem.materials["Enchanted Leviathan Scale"] = (craftingSystem.materials["Enchanted Leviathan Scale"] || 0) + 1;
  
  // 10% Enchanted Leviathan Heart
  if (Math.random() <= 0.10 * dropMultiplier) {
    drops.push("Enchanted Leviathan Heart");
    craftingSystem.materials["Enchanted Leviathan Heart"] = (craftingSystem.materials["Enchanted Leviathan Heart"] || 0) + 1;
  }
  
  // 1% Enchanted Leviathan Fang
  if (Math.random() <= 0.01 * dropMultiplier) {
    drops.push("Enchanted Leviathan Fang");
    craftingSystem.materials["Enchanted Leviathan Fang"] = (craftingSystem.materials["Enchanted Leviathan Fang"] || 0) + 1;
  }
  
  bossDrops.push({
    x: enchantedLeviathanBoss.x + enchantedLeviathanBoss.w / 2,
    y: enchantedLeviathanBoss.y,
    items: drops.map(d => `âœ¨ ${d}`),
    timer: 5000,
    opacity: 1
  });
  
  alert(`âœ¨ğŸŒŠ ENCHANTED LEVIATHAN DEFEATED!\n\nDrops:\n${drops.map(d => `â€¢ ${d}`).join('\n')}`);
  
  updateCraftingDisplay();
}

// Make functions globally accessible
window.useLeviathanTotem = useLeviathanTotem;
window.summonEnchantedLeviathan = summonEnchantedLeviathan;
// Make functions globally accessible
window.showCraftingMenu = showCraftingMenu;
window.showCraftingTab = showCraftingTab;
window.closeCraftingMenu = closeCraftingMenu;
window.craftItem = craftItem;
window.buyMaterial = buyMaterial;
// Make globally accessible
window.useEnchantRelic = useEnchantRelic;
// === ENCHANTMENT SYSTEM FUNCTIONS ===

function rollEnchantment() {
  // Determine if using Enchant Relic for better odds
  const hasRelic = enchantmentSystem.hasEnchantRelic;
  
  // Pick enchantment type first
  const types = Object.keys(enchantmentTypes);
  const typeRoll = Math.random();
  
  let selectedType = null;
  
  // Ultimate has special 0.1% chance
  if (typeRoll < 0.001 && hasRelic) {
    selectedType = "Ultimate";
  } else {
    // Pick from other types equally
    const normalTypes = types.filter(t => t !== "Ultimate");
    selectedType = normalTypes[Math.floor(Math.random() * normalTypes.length)];
  }
  
  // Roll for tier within that type
  const tiers = enchantmentTypes[selectedType].tiers;
  const tierKeys = Object.keys(tiers);
  
  let cumulativeChance = 0;
  const tierRoll = Math.random();
  
  // If has Enchant Relic, boost chances for higher tiers
  let selectedTier = null;
  
  for (const tier of tierKeys.reverse()) { // Start from highest tier
    let chance = tiers[tier].chance;
    
    // Enchant Relic doubles chance for Tier IV and V
    if (hasRelic && (tier === "IV" || tier === "V")) {
      chance *= 2;
    }
    
    cumulativeChance += chance;
    
    if (tierRoll < cumulativeChance) {
      selectedTier = tier;
      break;
    }
  }
  
  // Fallback to Tier I if nothing rolled
  if (!selectedTier) selectedTier = "I";
  
  return {
    type: selectedType,
    tier: selectedTier,
    data: tiers[selectedTier]
  };
}

function enchantPet(petId) {
  const pet = playerPets.find(p => p.id === petId);
  if (!pet) {
    alert("âŒ Pet not found!");
    return;
  }
  
  // Check if enchanting is unlocked
  if (!enchantmentSystem.unlocked) {
    alert("ğŸ”’ Enchanting unlocks at Rebirth 2!");
    return;
  }
  
  // Check if player has enough money
  if (money < enchantmentSystem.enchantCost) {
    alert(`âŒ Need ${formatBigInt(enchantmentSystem.enchantCost)} to enchant!`);
    return;
  }
  
  // Check if pet already has enchantment
  if (pet.enchantment) {
    const confirm = window.confirm(`âš ï¸ ${pet.name} already has ${pet.enchantment.type} ${pet.enchantment.tier}!\n\nOverwrite with new enchantment?`);
    if (!confirm) return;
  }
  
  // Deduct cost
  money -= enchantmentSystem.enchantCost;
  
  // Roll enchantment
  const result = rollEnchantment();
  
  // Apply enchantment to pet
  pet.enchantment = result;
  
  // Consume Enchant Relic if used
  if (enchantmentSystem.hasEnchantRelic) {
    enchantmentSystem.hasEnchantRelic = false;
    const relic = playerInventory.Relics.find(i => i.name === "Enchant Relic");
    if (relic) {
      relic.count--;
      if (relic.count <= 0) {
        const index = playerInventory.Relics.indexOf(relic);
        if (index > -1) playerInventory.Relics.splice(index, 1);
      }
    }
  }
  
  // Increment total enchants
  enchantmentSystem.totalEnchants++;
  
  // Check for milestone rewards
  checkEnchantMilestones();
  
  // Update displays
  updateDisplays();
  updateInventoryDisplay();
  updateEnchantUI(); // UPDATE UI
  updateAdminPanelStats(); // UPDATE ADMIN PANEL
  recomputeIncome();
  
  // Show result
  const icon = enchantmentTypes[result.type].icon;
  alert(`âœ¨ ENCHANTED! âœ¨\n\n${pet.icon} ${pet.name}\n${icon} ${result.type} ${result.tier}\n${result.data.description}\n\nTotal Enchants: ${enchantmentSystem.totalEnchants}`);
}

function checkEnchantMilestones() {
  const total = enchantmentSystem.totalEnchants;
  
  // Every 50 enchants = Enchant Egg
  const eggMilestones = Math.floor(total / 50);
  const currentEggs = playerInventory.Eggs.find(i => i.name === "Enchant Egg");
  const expectedEggs = eggMilestones;
  
  if (!currentEggs || currentEggs.count < expectedEggs) {
    const toAdd = expectedEggs - (currentEggs ? currentEggs.count : 0);
    if (currentEggs) {
      currentEggs.count = expectedEggs;
    } else {
      playerInventory.Eggs.push({
        icon: "ğŸ”®",
        name: "Enchant Egg",
        count: expectedEggs,
        special: 1
      });
    }
    console.log(`ğŸ Earned ${toAdd} Enchant Egg(s)! (Milestone: ${total})`);
  }
  
  // Every 100 enchants = Enchant Relic
  const relicMilestones = Math.floor(total / 100);
  const currentRelics = playerInventory.Relics.find(i => i.name === "Enchant Relic");
  const expectedRelics = relicMilestones;
  
  if (!currentRelics || currentRelics.count < expectedRelics) {
    const toAdd = expectedRelics - (currentRelics ? currentRelics.count : 0);
    if (currentRelics) {
      currentRelics.count = expectedRelics;
    } else {
      playerInventory.Relics.push({
        icon: "ğŸ€",
        name: "Enchant Relic",
        count: expectedRelics,
        special: 1.0
      });
    }
    console.log(`ğŸ Earned ${toAdd} Enchant Relic(s)! (Milestone: ${total})`);
  }
  
  // Specific milestones
  const milestones = [
    { count: 100, item: "Enchanted Sword", category: "Swords", icon: "ğŸ”®", special: 4 },
    { count: 200, item: "Enchanted Relic", category: "Relics", icon: "ğŸ”®", special: 1.40 },
    { count: 400, item: "Enchant Skin", category: "Skins", icon: "ğŸ”®", special: 16 },
    { count: 500, item: "Enchanted Potion", category: "Potions", icon: "ğŸ”®", special: 7 },
    { count: 1000, item: "Rare Enchant Sword", category: "Swords", icon: "âœ¨", special: 6 }
  ];
  
  milestones.forEach(milestone => {
    if (total >= milestone.count) {
      const existing = playerInventory[milestone.category].find(i => i.name === milestone.item);
      if (!existing) {
        playerInventory[milestone.category].push({
          icon: milestone.icon,
          name: milestone.item,
          count: 1,
          special: milestone.special
        });
        alert(`ğŸ‰ MILESTONE REWARD!\n\n${milestone.icon} ${milestone.item}\n(${milestone.count} enchants)`);
      }
    }
  });
  
  // UPDATE UI AFTER CHECKING MILESTONES
  updateEnchantUI();
  updateAdminPanelStats();
}
// Make globally accessible
window.enchantPet = enchantPet;
window.useEnchantRelic = useEnchantRelic;
// === ADVENT CALENDAR FUNCTIONS ===
function updateAdventDay() {
  const now = new Date();
  const currentMonth = now.getMonth(); // 0-11 (December = 11)
  let currentDate = now.getDate(); // 1-31
  
  // Apply debug offset if set
  if (adventCalendar.debugOffset) {
    currentDate = adventCalendar.debugOffset + 1;
    console.log(`ğŸ“… DEBUG MODE: Using day ${currentDate} (offset: ${adventCalendar.debugOffset})`);
  }
  
  // Only active in December (or debug mode)
  if (currentMonth === 11 || adventCalendar.debugOffset > 0) {
    adventCalendar.currentDay = Math.min(currentDate, 25);
  } else {
    adventCalendar.currentDay = 0; // Not December or past Christmas
  }
}

function canClaimAdventDay(day) {
  const now = new Date();
  const currentMonth = now.getMonth();
  let currentDate = now.getDate();
  
  // Apply debug offset if set
  if (adventCalendar.debugOffset) {
    currentDate = adventCalendar.debugOffset + 1;
  }
  
  // Not December (unless in debug mode)
  if (currentMonth !== 11 && adventCalendar.debugOffset === 0) return false;
  
  // Future day
  if (day > currentDate) return false;
  
  // Already claimed
  if (adventCalendar.claimedDays.includes(day)) return false;
  
  // Day must be 1-25
  if (day < 1 || day > 25) return false;
  
  return true;
}

function claimAdventReward(day) {
  if (!canClaimAdventDay(day)) {
    if (adventCalendar.claimedDays.includes(day)) {
      alert(`âŒ Day ${day} already claimed!`);
    } else if (day > new Date().getDate() && new Date().getMonth() === 11) {
      alert(`âŒ Day ${day} not available yet! Come back later.`);
    } else {
      alert(`âŒ Cannot claim day ${day}!`);
    }
    return;
  }
  
  const reward = adventCalendar.rewards[day];
  if (!reward) {
    alert(`âŒ No reward for day ${day}!`);
    return;
  }
  
  // Mark as claimed
  adventCalendar.claimedDays.push(day);
  
  // Give reward
  let rewardMsg = `ğŸ„ Day ${day} Claimed!\n\n`;
  
  switch (reward.type) {
    case "pet":
      const petData = christmasPets[reward.name];
      const newPet = {
        id: Date.now() + Math.random(),
        name: petData.name,
        color: petData.color,
        icon: petData.icon,
        ability: petData.ability,
        abilityValue: petData.value,
        description: petData.description,
        eggType: "Advent Calendar",
        mutation: null,
        equipped: false,
        offsetAngle: 0,
        x: character.x,
        y: character.y
      };
      playerPets.push(newPet);
      rewardMsg += `ğŸ Received: ${petData.icon} ${petData.name}\n${petData.description}`;
      break;
      
    case "sword":
      playerInventory.Swords.push({
        icon: reward.icon,
        name: reward.name,
        count: 1,
        special: reward.special
      });
      rewardMsg += `ğŸ Received: ${reward.icon} ${reward.name} (${reward.special} damage)`;
      break;
      
    case "relic":
      playerInventory.Relics.push({
        icon: reward.icon,
        name: reward.name,
        count: 1,
        special: reward.special
      });
      rewardMsg += `ğŸ Received: ${reward.icon} ${reward.name} (${reward.special}x money)`;
      break;
      
    case "skin":
      playerInventory.Skins.push({
        icon: reward.icon,
        name: reward.name,
        count: 1,
        special: reward.special
      });
      skins[reward.special] = { color: reward.color };
      rewardMsg += `ğŸ Received: ${reward.icon} ${reward.name}`;
      break;
      
    case "snow":
      christmasEvent.snowCollected += reward.amount;
      dropCounters["â„ï¸ Snowflakes"] += reward.amount;
      inventory["â„ï¸ Snowflakes"] += reward.amount;
      rewardMsg += `ğŸ Received: â„ï¸ ${reward.amount} Snowflakes`;
      break;
      
    case "money":
      money += reward.amount;
      rewardMsg += `ğŸ Received: ğŸ’° ${formatBigInt(reward.amount)} Money`;
      break;
  }
  
  alert(rewardMsg);
  updateInventoryDisplay();
  updateDisplays();
  showAdventCalendar(); // Refresh calendar
}

function showAdventCalendar() {
  updateAdventDay();
  
  let html = `
    <div style="background:#1a0a00;padding:20px;border-radius:15px;max-width:600px;margin:20px auto;color:white;">
      <h2 style="text-align:center;color:#FFD700;">ğŸ„ Advent Calendar ğŸ„</h2>
      <p style="text-align:center;color:#aaa;">Claim daily rewards throughout December!</p>
      <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:10px;margin-top:20px;">
  `;
  
  for (let day = 1; day <= 25; day++) {
    const isClaimed = adventCalendar.claimedDays.includes(day);
    const canClaim = canClaimAdventDay(day);
    const isToday = day === adventCalendar.currentDay;
    const reward = adventCalendar.rewards[day];
    
    let bgColor = "#333";
    let textColor = "#888";
    let cursor = "not-allowed";
    
    if (isClaimed) {
      bgColor = "#2d5016"; // Green - claimed
      textColor = "#90EE90";
    } else if (canClaim) {
      bgColor = "#8B0000"; // Red - available
      textColor = "#FFD700";
      cursor = "pointer";
    } else if (isToday) {
      bgColor = "#4a3000"; // Gold - today but not yet claimable
      textColor = "#FFD700";
    }
    
    const rewardIcon = reward ? getRewardIcon(reward) : "ğŸ";
    
    html += `
      <div 
        onclick="${canClaim ? `claimAdventReward(${day})` : ''}"
        style="
          background:${bgColor};
          padding:15px;
          border-radius:10px;
          text-align:center;
          cursor:${cursor};
          border:${isToday ? '2px solid gold' : '1px solid #555'};
          transition:transform 0.2s;
        "
        ${canClaim ? 'onmouseover="this.style.transform=\'scale(1.05)\'" onmouseout="this.style.transform=\'scale(1)\'"' : ''}
      >
        <div style="font-size:24px;">${rewardIcon}</div>
        <div style="color:${textColor};font-weight:bold;margin-top:5px;">${day}</div>
        ${isClaimed ? '<div style="font-size:12px;color:#90EE90;">âœ“</div>' : ''}
      </div>
    `;
  }
  
  html += `
      </div>
      <div style="margin-top:20px;text-align:center;">
        <button onclick="closeAdventCalendar()" style="padding:10px 20px;background:#8B0000;color:white;border:none;border-radius:8px;cursor:pointer;font-size:16px;">
          Close
        </button>
      </div>
      <p style="text-align:center;color:#888;font-size:12px;margin-top:10px;">
        Claimed: ${adventCalendar.claimedDays.length}/25
      </p>
    </div>
  `;
  
  // Create overlay
  const overlay = document.createElement('div');
  overlay.id = 'adventCalendarOverlay';
  overlay.style.cssText = `
    position:fixed;
    top:0;
    left:0;
    width:100%;
    height:100%;
    background:rgba(0,0,0,0.8);
    z-index:10000;
    overflow-y:auto;
  `;
  overlay.innerHTML = html;
  document.body.appendChild(overlay);
}

function getRewardIcon(reward) {
  switch (reward.type) {
    case "pet": return reward.icon;
    case "sword": return reward.icon;
    case "relic": return reward.icon;
    case "skin": return reward.icon;
    case "snow": return "â„ï¸";
    case "money": return "ğŸ’°";
    default: return "ğŸ";
  }
}

function closeAdventCalendar() {
  const overlay = document.getElementById('adventCalendarOverlay');
  if (overlay) overlay.remove();
}

// Make functions globally accessible
window.claimAdventReward = claimAdventReward;
window.closeAdventCalendar = closeAdventCalendar;
window.showAdventCalendar = showAdventCalendar;
function updateEventIndicator() {
  const indicator = document.getElementById('eventIndicator');
  if (!indicator) return;
    // Check for Forgotten Altar event first
  if (forgottenAltar.active) {
    indicator.textContent = "â„ï¸";
    indicator.title = `Active: Forgotten Altar (Leviathan Battle)`;
    return;
  }
    // Check for Heavenly event first
  if (heavenlyEvent.active) {
    indicator.textContent = "âœ¨";
    indicator.title = `Active: Heavenly Event (+35% income)`;
    return;
  }
  // Check for Christmas event first (highest priority for seasonal)
  if (christmasEvent.active) {
    indicator.textContent = "ğŸ„";
    indicator.title = `Active: Christmas Event (+20% income, Shop open!)`;
    return;
  }
  
  // Check for admin event
  if (currentAdminEvent) {
    const emoji = eventEmojis[currentAdminEvent.name] || "ğŸ®";
    indicator.textContent = emoji;
    indicator.title = `Active: ${currentAdminEvent.name} (+${(currentAdminEvent.incomeBoost - 1) * 100}% income)`;
    return;
  }
  
  // Check for weather event
  if (currentWeather) {
    const emoji = eventEmojis[currentWeather] || "ğŸŒ¤ï¸";
    indicator.textContent = emoji;
    indicator.title = `Active: ${currentWeather} (+${(weatherMultiplier - 1) * 100}% income)`;
    return;
  }
  
  // Show day/night cycle
  const cycle = dayNightCycle[dayNightCycle.current];
  indicator.textContent = cycle.emoji;
  indicator.title = `Current: ${cycle.name}`;
}



function activatePotionEvent(multiplier) {
  potionActive = true;
  potionMultiplier = multiplier;
  potionEndTime = Date.now() + 60000; // 1 minute from now
  
  console.log(`ğŸ§ª Potion activated! ${multiplier}x income for 60 seconds`);
  
  // Find and consume the equipped potion
  const equippedPotion = playerInventory.Potions.find(i => i.equipped);
  if (equippedPotion && equippedPotion.count > 0) {
    equippedPotion.count--;
    
    // If count reaches 0, remove the potion from inventory
    if (equippedPotion.count === 0) {
      const index = playerInventory.Potions.indexOf(equippedPotion);
      if (index > -1) {
        playerInventory.Potions.splice(index, 1);
      }
    }
  }
  
  // Recalculate income with new multiplier
  recomputeIncome();
  
  // Set timeout to end potion effect after 60 seconds
  setTimeout(() => {
    potionActive = false;
    potionMultiplier = 1;
    console.log(`ğŸ§ª Potion effect ended`);
    
    // Unequip the potion - reset button to "Equip" status
    if (playerInventory.Potions) {
      playerInventory.Potions.forEach(i => i.equipped = false);
    }
    equippedPotionSpecial = 1;
    
    // Recalculate income back to normal
    recomputeIncome();
    // Update the UI to show "Equip" button again
    updateInventoryDisplay();
  }, 60000);
  
  // Update inventory display immediately to show reduced count
  updateInventoryDisplay();
}


/**
 * Starts a weather animation based on the given type.
 * The type can be one of "Rain", "Wind", or "Thunder".
 * For "Rain", generates 150 particles with random positions and lengths/speeds.
 * For "Wind", generates 80 particles with random positions and lengths/speeds.
 * For "Thunder", generates a single particle with a flashing effect.
 * @param {string} type - The type of the weather animation to start.
 * @returns {undefined}
 */
function startWeatherAnimation(type) {
  weatherParticles = [];

  if (type === "Rain") {
    for (let i = 0; i < 150; i++) {
      weatherParticles.push({
        x: Math.random() * W,
        y: Math.random() * H,
        len: 10 + Math.random() * 10,
        speed: 300 + Math.random() * 200
      });
    }
  }

  if (type === "Wind") {
    for (let i = 0; i < 80; i++) {
      weatherParticles.push({
        x: Math.random() * W,
        y: Math.random() * H,
        len: 20 + Math.random() * 10,
        speed: 100 + Math.random() * 150
      });
    }
  }

  if (type === "Thunder") {
    weatherParticles.push({ flash: true, alpha: 0 });
  }
}

/**
 * Stops the current weather animation by resetting the weatherParticles array.
 * This function is called automatically after the duration of the weather event.
 * @returns {undefined}
 */
function stopWeatherAnimation() {
  weatherParticles = [];
}

/**
 * Updates the weather animation by moving and/or flashing the weather particles.
 * This function is called continuously by the requestAnimationFrame loop.
 * @param {number} dt - The time elapsed since the last frame in milliseconds.
 * @returns {undefined}
 */
function updateWeatherAnimation(dt) {
  if (!currentWeather) return;

  if (currentWeather === "Rain") {
    for (const p of weatherParticles) {
      p.y += p.speed * dt;
      if (p.y > H) {
        p.y = -p.len;
        p.x = Math.random() * W;
      }
    }
  }

  if (currentWeather === "Wind") {
    for (const p of weatherParticles) {
      p.x += p.speed * dt;
      if (p.x > W) {
        p.x = -p.len;
        p.y = Math.random() * H;
      }
    }
  }

  if (currentWeather === "Thunder") {
    // Random flash effect
    if (Math.random() < 0.005) {
      weatherParticles[0].alpha = 1;
    }
    if (weatherParticles[0].alpha > 0) {
      weatherParticles[0].alpha -= dt * 2;
    }
  }
}
// Update day/night stars
// Update day/night stars and clouds
function updateDayNightAnimation(dt) {
  // Update stars for night and sunrise
  if (dayNightCycle.current === "night" || dayNightCycle.current === "sunrise") {
    dayNightStars.forEach(star => {
      star.twinkle += dt * star.twinkleSpeed;
      if (star.twinkle > 1) star.twinkle = 0;
    });
  }
  
  // Update clouds for sunset and sunrise
  if (dayNightCycle.current === "sunset" || dayNightCycle.current === "sunrise") {
    sunsetClouds.forEach(cloud => {
      cloud.x += cloud.speed * dt;
      if (cloud.x > W + cloud.width) {
        cloud.x = -cloud.width;
        cloud.y = 100 + Math.random() * 150;
      }
    });
  }
}

// === ADMIN ABUSE EVENT FUNCTIONS ===
function triggerAdminEvent(event) {
  if (currentAdminEvent) {
    console.log(`âš ï¸ Admin event ${currentAdminEvent.name} already active, skipping ${event.name}`);
    return;
  }
  
  currentAdminEvent = event;
  document.body.style.background = event.bg;
  adminEventOverlayAlpha = 0.3;
  
  console.log(`ğŸ® Admin Abuse: ${event.name} started! +${(event.incomeBoost - 1) * 100}% income for ${event.duration/1000}s`);
  
  recomputeIncome();
  startAdminAnimation(event.animation);
  updateEventIndicator(); // â† ADD THIS
  
  adminEventTimer = setTimeout(() => endAdminEvent(), event.duration);
}

function endAdminEvent() {
  if (!currentAdminEvent) return;
  
  console.log(`âœ… Admin event ${currentAdminEvent.name} ended`);
  currentAdminEvent = null;
  document.body.style.background = "linear-gradient(#111,#07101a)";
  adminEventOverlayAlpha = 0;
  adminEventShakeX = 0;
  adminEventShakeY = 0;
  
  recomputeIncome();
  stopAdminAnimation();
  updateEventIndicator(); // â† ADD THIS
}

function startAdminAnimation(type) {
  adminEventParticles = [];
  
  switch(type) {
    case "blackhole":
      for (let i = 0; i < 100; i++) {
        adminEventParticles.push({
          angle: Math.random() * Math.PI * 2,
          distance: 200 + Math.random() * 300,
          speed: 50 + Math.random() * 100,
          size: 1 + Math.random() * 2
        });
      }
      break;
      
    case "hurricane":
      for (let i = 0; i < 150; i++) {
        adminEventParticles.push({
          angle: Math.random() * Math.PI * 2,
          distance: Math.random() * Math.max(W, H),
          speed: 100 + Math.random() * 200,
          size: 2 + Math.random() * 3,
          isRain: Math.random() > 0.7
        });
      }
      break;
      
    case "disco":
      for (let i = 0; i < 50; i++) {
        adminEventParticles.push({
          x: Math.random() * W,
          y: Math.random() * H,
          size: 10 + Math.random() * 20,
          hue: Math.random() * 360,
          alpha: 0.5 + Math.random() * 0.5
        });
      }
      break;
      
    case "volcano":
      for (let i = 0; i < 80; i++) {
        adminEventParticles.push({
          x: W / 2 + (Math.random() - 0.5) * 100,
          y: H,
          vx: (Math.random() - 0.5) * 200,
          vy: -300 - Math.random() * 200,
          size: 3 + Math.random() * 5,
          life: 1
        });
      }
      break;
      
    case "glitched":
      // Glitch blocks
      for (let i = 0; i < 30; i++) {
        adminEventParticles.push({
          x: Math.random() * W,
          y: Math.random() * H,
          w: 20 + Math.random() * 100,
          h: 5 + Math.random() * 30
        });
      }
      break;
      
    case "galactic":
      // Stars and planets
      for (let i = 0; i < 100; i++) {
        adminEventParticles.push({
          x: Math.random() * W,
          y: Math.random() * H,
          size: 1 + Math.random() * 3,
          twinkle: Math.random()
        });
      }
      // Add some planets
      for (let i = 0; i < 5; i++) {
        adminEventParticles.push({
          x: Math.random() * W,
          y: Math.random() * H,
          size: 20 + Math.random() * 40,
          isPlanet: true,
          hue: Math.random() * 360
        });
      }
      break;
       case "phoenix":
      // Spawn phoenix nest
      phoenixBoss.nestX = W / 2 - 50;
      phoenixBoss.nestY = H / 2 - 50;
      
      // Fire particles around nest
      for (let i = 0; i < 60; i++) {
        adminEventParticles.push({
          x: phoenixBoss.nestX + 50 + (Math.random() - 0.5) * 80,
          y: phoenixBoss.nestY + 50 + (Math.random() - 0.5) * 80,
          vx: (Math.random() - 0.5) * 100,
          vy: -100 - Math.random() * 100,
          size: 2 + Math.random() * 4,
          life: 1,
          color: Math.random() > 0.5 ? "#FF4500" : "#FFD700"
        });
      }
      
      // Spawn phoenix boss
      phoenixBoss.x = phoenixBoss.nestX + 50;
      phoenixBoss.y = phoenixBoss.nestY - 100;
      phoenixBoss.visible = true;
      phoenixBoss.hitsRemaining = 25;
      break;
      
    case "bloodmoon":
      // Red mist particles
      for (let i = 0; i < 80; i++) {
        adminEventParticles.push({
          x: Math.random() * W,
          y: Math.random() * H,
          size: 10 + Math.random() * 30,
          alpha: 0.1 + Math.random() * 0.2,
          drift: Math.random() * 2 - 1,
          driftSpeed: 20 + Math.random() * 30
        });
      }
      break;
      
    case "tornado":
      // Spawn tornado at random edge
      const edge = Math.floor(Math.random() * 4);
      if (edge === 0) { tornado.x = 0; tornado.y = Math.random() * H; }
      else if (edge === 1) { tornado.x = W; tornado.y = Math.random() * H; }
      else if (edge === 2) { tornado.x = Math.random() * W; tornado.y = 0; }
      else { tornado.x = Math.random() * W; tornado.y = H; }
      
      tornado.visible = true;
      
      // Debris particles
      for (let i = 0; i < 50; i++) {
        adminEventParticles.push({
          angle: Math.random() * Math.PI * 2,
          distance: Math.random() * 60,
          speed: 200 + Math.random() * 300,
          size: 2 + Math.random() * 4
        });
      }
      break;
  }
}

function stopAdminAnimation() {
  adminEventParticles = [];
}

function updateAdminAnimation(dt) {
  if (!currentAdminEvent) return;
  
  const type = currentAdminEvent.animation;
  
  switch(type) {
    case "blackhole":
      adminEventParticles.forEach(p => {
        p.distance -= p.speed * dt;
        if (p.distance < 10) p.distance = 500;
      });
      break;
      
    case "hurricane":
      adminEventParticles.forEach(p => {
        p.angle += p.speed * dt * 0.01;
        if (p.isRain) {
          p.distance += 50 * dt;
          if (p.distance > Math.max(W, H)) p.distance = 0;
        }
      });
      break;
      
    case "disco":
      adminEventParticles.forEach(p => {
        p.hue = (p.hue + 100 * dt) % 360;
      });
      break;
      
    case "volcano":
      adminEventParticles.forEach(p => {
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += 400 * dt; // gravity
        p.life -= dt * 0.5;
        
        if (p.life <= 0) {
          p.x = W / 2 + (Math.random() - 0.5) * 100;
          p.y = H;
          p.vx = (Math.random() - 0.5) * 200;
          p.vy = -300 - Math.random() * 200;
          p.life = 1;
        }
      });
      break;
      
    case "earthquake":
      adminEventShakeX = (Math.random() - 0.5) * 10;
      adminEventShakeY = (Math.random() - 0.5) * 10;
      break;
      
    case "glitched":
      if (Math.random() < 0.1) {
        adminEventParticles.forEach(p => {
          p.x = Math.random() * W;
          p.y = Math.random() * H;
        });
      }
      break;
      
    case "galactic":
      adminEventParticles.forEach(p => {
        if (!p.isPlanet) {
          p.twinkle = (p.twinkle + dt) % 1;
        }
      });
      break;
        case "phoenix":
      // Update fire particles
      adminEventParticles.forEach(p => {
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += 200 * dt; // gravity
        p.life -= dt * 0.8;
        
        if (p.life <= 0) {
          p.x = phoenixBoss.nestX + 50 + (Math.random() - 0.5) * 80;
          p.y = phoenixBoss.nestY + 50 + (Math.random() - 0.5) * 80;
          p.vx = (Math.random() - 0.5) * 100;
          p.vy = -100 - Math.random() * 100;
          p.life = 1;
        }
      });
    
      // ğŸ”¥ PHOENIX BOSS LOGIC
if (phoenixBoss.visible && !phoenixBoss.retreating) {
  const dx = character.x - phoenixBoss.x;
  const dy = character.y - phoenixBoss.y;
  const distance = Math.hypot(dx, dy);
  
  // Phoenix follows player slowly
  if (distance > 100) {
    phoenixBoss.x += (dx / distance) * phoenixBoss.speed * dt * 0.3;
    phoenixBoss.y += (dy / distance) * phoenixBoss.speed * dt * 0.3;
  }
  
  // Long range attack
  if (distance < phoenixBoss.longRangeRadius && !phoenixBoss.attackCooldown) {
    phoenixBoss.attackCooldown = true;
    
    // Phoenix IGNORES mistletoe shield
    phoenixBoss.playerHits++;
    
    console.log("ğŸ”¥ Phoenix hit you with long-range attack!");
    
    if (phoenixBoss.playerHits >= 3) {
      money = money / 2n;
      phoenixBoss.visible = false;
      phoenixBoss.playerHits = 0;
      alert("ğŸ”¥ Phoenix defeated you! Lost 50% money!");
    }
    
    setTimeout(() => (phoenixBoss.attackCooldown = false), 3000);
  }
}
// ğŸ—¡ï¸ Sword vs Phoenix Boss
if (phoenixBoss.visible && character.slashing && !phoenixBoss.retreating) {
  // ... all the sword collision code ...
}
// ğŸŒŠ LEVIATHAN BOSS LOGIC
if (leviathanBoss.visible) {
  const dx = character.x - leviathanBoss.x;
  const dy = character.y - leviathanBoss.y;
  const distance = Math.hypot(dx, dy);
  
  // Leviathan stays on right side, moves up and down slowly
  const targetY = H / 2 + Math.sin(Date.now() / 1000) * 100;
  leviathanBoss.y += (targetY - leviathanBoss.y) * dt * 0.5;
  
  // Long range attack
  if (distance < leviathanBoss.longRangeRadius && !leviathanBoss.attackCooldown) {
    leviathanBoss.attackCooldown = true;
    leviathanBoss.playerHits++;
const damageReduction = window.leviathanArmorEquipped ? (window.leviathanArmorDamageReduction || 0) : 0;
const damage = Math.random() < damageReduction ? 0 : 1;
leviathanBoss.playerCurrentHP -= damage;

if (damage === 0) {
  console.log("ğŸ›¡ï¸ Leviathan Armor blocked the attack!");
}
    
    console.log(`ğŸŒŠ Leviathan attacked! Player HP: ${leviathanBoss.playerCurrentHP}/${leviathanBoss.playerMaxHP}`);
    
    // Show damage indicator
    const dmgIndicator = document.createElement('div');
    dmgIndicator.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(30, 144, 255, 0.9);
      color: white;
      padding: 20px 40px;
      border-radius: 15px;
      font-size: 28px;
      font-weight: bold;
      z-index: 10001;
      animation: fadeOut 1s forwards;
    `;
    dmgIndicator.textContent = `ğŸŒŠ HIT! ${leviathanBoss.playerCurrentHP} HP LEFT`;
    document.body.appendChild(dmgIndicator);
    
    setTimeout(() => dmgIndicator.remove(), 1000);
    
    if (leviathanBoss.playerCurrentHP <= 0) {
      money = money / 2n;
      leviathanBoss.visible = false;
      harpoon.equipped = false;
      endForgottenAltar();
      alert("ğŸ’€ You were defeated by the Leviathan!\n\nLost 50% money!");
    }
    
    setTimeout(() => (leviathanBoss.attackCooldown = false), 3000);
  }
}

// ğŸŒŠâœ¨ ENCHANTED LEVIATHAN BOSS LOGIC
if (enchantedLeviathanBoss.visible) {
  const dx = character.x - enchantedLeviathanBoss.x;
  const dy = character.y - enchantedLeviathanBoss.y;
  const distance = Math.hypot(dx, dy);
  
  // Enchanted Leviathan moves more aggressively
  const targetY = H / 2 + Math.sin(Date.now() / 800) * 120;
  enchantedLeviathanBoss.y += (targetY - enchantedLeviathanBoss.y) * dt * 0.7;
  
  // Long range attack (faster)
  if (distance < enchantedLeviathanBoss.longRangeRadius && !enchantedLeviathanBoss.attackCooldown) {
    enchantedLeviathanBoss.attackCooldown = true;
    enchantedLeviathanBoss.playerHits++;
    leviathanBoss.playerCurrentHP--;
    
    console.log(`âœ¨ğŸŒŠ Enchanted Leviathan attacked! Player HP: ${leviathanBoss.playerCurrentHP}/${leviathanBoss.playerMaxHP}`);
    
    const dmgIndicator = document.createElement('div');
    dmgIndicator.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(147, 112, 219, 0.9);
      color: white;
      padding: 20px 40px;
      border-radius: 15px;
      font-size: 28px;
      font-weight: bold;
      z-index: 10001;
      animation: fadeOut 1s forwards;
    `;
    dmgIndicator.textContent = `âœ¨ HIT! ${leviathanBoss.playerCurrentHP} HP LEFT`;
    document.body.appendChild(dmgIndicator);
    
    setTimeout(() => dmgIndicator.remove(), 1000);
    
    if (leviathanBoss.playerCurrentHP <= 0) {
      money = money / 2n;
      enchantedLeviathanBoss.visible = false;
      harpoon.equipped = false;
      endForgottenAltar();
      alert("ğŸ’€ You were defeated by the Enchanted Leviathan!\n\nLost 50% money!");
    }
    
    setTimeout(() => (enchantedLeviathanBoss.attackCooldown = false), 2500);
  }
}
      break;
      
    case "bloodmoon":
      adminEventParticles.forEach(p => {
        p.x += p.drift * p.driftSpeed * dt;
        if (p.x > W + p.size) p.x = -p.size;
        if (p.x < -p.size) p.x = W + p.size;
      });
      break;
      
    case "tornado":
      if (tornado.visible) {
        // Move tornado toward player
        const dx = character.x - tornado.x;
        const dy = character.y - tornado.y;
        const distance = Math.hypot(dx, dy);
        
        if (distance > 5) {
          tornado.x += (dx / distance) * tornado.speed * dt;
          tornado.y += (dy / distance) * tornado.speed * dt;
        }
        
        tornado.angle += dt * 10; // rotation
        
        // Update debris particles
        adminEventParticles.forEach(p => {
          p.angle += p.speed * dt * 0.01;
        });
        
        // Check collision with player
        if (rectsOverlap(tornado, character)) {
          tornado.visible = false;
          endAdminEvent();
          money = money / 2n; // Penalty
          alert("ğŸŒªï¸ Tornado hit you! Lost 50% money!");
        }
      }
      break;
        // === ADD THIS CLEANUP CODE HERE (at the very end, before closing brace) ===
  // CLEANUP: Prevent particle array from growing too large
  if (adminEventParticles.length > MAX_PARTICLES) {
    adminEventParticles.splice(0, adminEventParticles.length - MAX_PARTICLES);
  }
} // <-- This is the closing brace of updateAdminAnimation
  }


function drawAdminAnimation(ctx) {
  if (!currentAdminEvent) return;
  
  ctx.save();
  
  const type = currentAdminEvent.animation;
  const centerX = W / 2;
  const centerY = H / 2;
  
  switch(type) {
    case "blackhole":
      ctx.fillStyle = "rgba(138,43,226,0.3)";
      ctx.beginPath();
      ctx.arc(centerX, centerY, 50, 0, Math.PI * 2);
      ctx.fill();
      
      adminEventParticles.forEach(p => {
        const x = centerX + Math.cos(p.angle) * p.distance;
        const y = centerY + Math.sin(p.angle) * p.distance;
        ctx.fillStyle = `rgba(200,150,255,${1 - p.distance/500})`;
        ctx.fillRect(x, y, p.size, p.size);
      });
      break;
      
    case "hurricane":
      adminEventParticles.forEach(p => {
        if (p.isRain) {
          const x = centerX + Math.cos(p.angle) * p.distance;
          const y = centerY + Math.sin(p.angle) * p.distance;
          ctx.strokeStyle = "rgba(150,200,255,0.4)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x, y + 10);
          ctx.stroke();
        } else {
          const x = centerX + Math.cos(p.angle) * p.distance;
          const y = centerY + Math.sin(p.angle) * p.distance;
          ctx.strokeStyle = "rgba(255,255,255,0.2)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + Math.cos(p.angle) * 20, y + Math.sin(p.angle) * 20);
          ctx.stroke();
        }
      });
      break;
      
    case "disco":
      adminEventParticles.forEach(p => {
        ctx.fillStyle = `hsla(${p.hue}, 100%, 50%, ${p.alpha})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      });
      break;
      
    case "volcano":
      adminEventParticles.forEach(p => {
        if (p.life > 0) {
          ctx.fillStyle = `rgba(255,${100 + p.life * 150},0,${p.life})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
        }
      });
      break;
      
    case "glitched":
      adminEventParticles.forEach(p => {
        const colors = ['#ff0000', '#00ff00', '#0000ff', '#ff00ff', '#00ffff'];
        ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
        ctx.globalAlpha = 0.3;
        ctx.fillRect(p.x, p.y, p.w, p.h);
      });
      ctx.globalAlpha = 1;
      break;
      
    case "galactic":
      adminEventParticles.forEach(p => {
        if (p.isPlanet) {
          ctx.fillStyle = `hsl(${p.hue}, 70%, 50%)`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
        } else {
          ctx.fillStyle = `rgba(255,255,255,${0.3 + p.twinkle * 0.7})`;
          ctx.fillRect(p.x, p.y, p.size, p.size);
        }
      });
      break;
      case "phoenix":
      // Draw nest
      ctx.fillStyle = "#8B4513";
      ctx.fillRect(phoenixBoss.nestX, phoenixBoss.nestY, 100, 100);
      ctx.strokeStyle = "#654321";
      ctx.lineWidth = 3;
      ctx.strokeRect(phoenixBoss.nestX, phoenixBoss.nestY, 100, 100);
      
      // Draw fire particles
      adminEventParticles.forEach(p => {
        if (p.life > 0) {
          ctx.fillStyle = p.color;
          ctx.globalAlpha = p.life;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
        }
      });
      ctx.globalAlpha = 1;
      
      // Draw phoenix boss
      if (phoenixBoss.visible) {
        ctx.fillStyle = phoenixBoss.flash ? "#FFD700" : phoenixBoss.color;
        ctx.fillRect(phoenixBoss.x, phoenixBoss.y, phoenixBoss.w, phoenixBoss.h);
        ctx.strokeStyle = 'rgba(0,0,0,0.6)';
        ctx.strokeRect(phoenixBoss.x + 0.5, phoenixBoss.y + 0.5, phoenixBoss.w - 1, phoenixBoss.h - 1);
        ctx.font = '32px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(phoenixBoss.emoji, phoenixBoss.x + phoenixBoss.w / 2, phoenixBoss.y + phoenixBoss.h / 2);
        
        // Draw long range circle
        ctx.strokeStyle = "rgba(255, 69, 0, 0.3)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(phoenixBoss.x + phoenixBoss.w / 2, phoenixBoss.y + phoenixBoss.h / 2, phoenixBoss.longRangeRadius, 0, Math.PI * 2);
        ctx.stroke();
        
        // Draw HP bar
        const barWidth = 200;
        ctx.fillStyle = '#222';
        ctx.fillRect(W/2 - barWidth/2, 50, barWidth, 10);
        ctx.fillStyle = '#FF4500';
        ctx.fillRect(W/2 - barWidth/2, 50, barWidth * (phoenixBoss.hitsRemaining / phoenixBoss.hitsToDie), 10);
        ctx.fillStyle = '#fff';
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`Phoenix HP: ${phoenixBoss.hitsRemaining}/${phoenixBoss.hitsToDie}`, W/2, 45);
      }
      break;
      // ğŸŒŠ Draw Leviathan Boss
if (leviathanBoss.visible) {
  ctx.fillStyle = leviathanBoss.flash ? "#87CEEB" : leviathanBoss.color;
  ctx.fillRect(leviathanBoss.x, leviathanBoss.y, leviathanBoss.w, leviathanBoss.h);
  ctx.strokeStyle = 'rgba(0,0,0,0.6)';
  ctx.strokeRect(leviathanBoss.x + 0.5, leviathanBoss.y + 0.5, leviathanBoss.w - 1, leviathanBoss.h - 1);
  ctx.font = '48px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(leviathanBoss.emoji, leviathanBoss.x + leviathanBoss.w / 2, leviathanBoss.y + leviathanBoss.h / 2);
  
  // Draw long range circle
  ctx.strokeStyle = "rgba(30, 144, 255, 0.3)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(leviathanBoss.x + leviathanBoss.w / 2, leviathanBoss.y + leviathanBoss.h / 2, leviathanBoss.longRangeRadius, 0, Math.PI * 2);
  ctx.stroke();
  
  // Draw HP bar
  const barWidth = 250;
  ctx.fillStyle = '#222';
  ctx.fillRect(W/2 - barWidth/2, 50, barWidth, 12);
  ctx.fillStyle = '#1E90FF';
  ctx.fillRect(W/2 - barWidth/2, 50, barWidth * (leviathanBoss.hitsRemaining / leviathanBoss.hitsToDie), 12);
  ctx.fillStyle = '#fff';
  ctx.font = '14px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(`ğŸŒŠ Leviathan HP: ${leviathanBoss.hitsRemaining}/${leviathanBoss.hitsToDie}`, W/2, 45);
  
  // Draw player HP bar
  ctx.fillStyle = '#222';
  ctx.fillRect(W/2 - barWidth/2, H - 40, barWidth, 12);
  ctx.fillStyle = '#00ff00';
  ctx.fillRect(W/2 - barWidth/2, H - 40, barWidth * (leviathanBoss.playerCurrentHP / leviathanBoss.playerMaxHP), 12);
  ctx.fillStyle = '#fff';
  ctx.fillText(`Player HP: ${leviathanBoss.playerCurrentHP}/${leviathanBoss.playerMaxHP}`, W/2, H - 45);
}

// ğŸŒŠâœ¨ Draw Enchanted Leviathan Boss
if (enchantedLeviathanBoss.visible) {
  ctx.fillStyle = enchantedLeviathanBoss.flash ? "#DDA0DD" : enchantedLeviathanBoss.color;
  ctx.fillRect(enchantedLeviathanBoss.x, enchantedLeviathanBoss.y, enchantedLeviathanBoss.w, enchantedLeviathanBoss.h);
  ctx.strokeStyle = 'rgba(0,0,0,0.6)';
  ctx.strokeRect(enchantedLeviathanBoss.x + 0.5, enchantedLeviathanBoss.y + 0.5, enchantedLeviathanBoss.w - 1, enchantedLeviathanBoss.h - 1);
  ctx.font = '52px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(enchantedLeviathanBoss.emoji, enchantedLeviathanBoss.x + enchantedLeviathanBoss.w / 2, enchantedLeviathanBoss.y + enchantedLeviathanBoss.h / 2);
  
  // Draw long range circle
  ctx.strokeStyle = "rgba(147, 112, 219, 0.3)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(enchantedLeviathanBoss.x + enchantedLeviathanBoss.w / 2, enchantedLeviathanBoss.y + enchantedLeviathanBoss.h / 2, enchantedLeviathanBoss.longRangeRadius, 0, Math.PI * 2);
  ctx.stroke();
  
  // Draw HP bar
  const barWidth = 250;
  ctx.fillStyle = '#222';
  ctx.fillRect(W/2 - barWidth/2, 50, barWidth, 12);
  ctx.fillStyle = '#9370DB';
  ctx.fillRect(W/2 - barWidth/2, 50, barWidth * (enchantedLeviathanBoss.hitsRemaining / enchantedLeviathanBoss.hitsToDie), 12);
  ctx.fillStyle = '#fff';
  ctx.font = '14px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(`âœ¨ğŸŒŠ Enchanted Leviathan HP: ${enchantedLeviathanBoss.hitsRemaining}/${enchantedLeviathanBoss.hitsToDie}`, W/2, 45);
  
  // Draw player HP bar
  ctx.fillStyle = '#222';
  ctx.fillRect(W/2 - barWidth/2, H - 40, barWidth, 12);
  ctx.fillStyle = '#00ff00';
  ctx.fillRect(W/2 - barWidth/2, H - 40, barWidth * (leviathanBoss.playerCurrentHP / leviathanBoss.playerMaxHP), 12);
  ctx.fillStyle = '#fff';
  ctx.fillText(`Player HP: ${leviathanBoss.playerCurrentHP}/${leviathanBoss.playerMaxHP}`, W/2, H - 45);
}
    case "bloodmoon":
      // Draw bloodmoon in sky
      ctx.save();
      ctx.fillStyle = "#8B0000";
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.arc(W - 100, 80, 40, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.restore();
      
      // Draw red mist particles
      adminEventParticles.forEach(p => {
        ctx.fillStyle = `rgba(139, 0, 0, ${p.alpha})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      });
      break;
      
    case "tornado":
      if (tornado.visible) {
        // Draw tornado spiral
        ctx.save();
        ctx.translate(tornado.x + tornado.w / 2, tornado.y + tornado.h / 2);
        ctx.rotate(tornado.angle);
        
        // Draw tornado body
        ctx.strokeStyle = "rgba(100, 100, 100, 0.6)";
        ctx.lineWidth = 15;
        ctx.beginPath();
        for (let i = 0; i < 20; i++) {
          const angle = (i / 20) * Math.PI * 4;
          const radius = (i / 20) * 40;
          const x = Math.cos(angle) * radius;
          const y = Math.sin(angle) * radius - i * 2;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
        
        ctx.restore();
        
        // Draw debris particles
        adminEventParticles.forEach(p => {
          const x = tornado.x + tornado.w / 2 + Math.cos(p.angle) * p.distance;
          const y = tornado.y + tornado.h / 2 + Math.sin(p.angle) * p.distance;
          ctx.fillStyle = "rgba(150, 150, 150, 0.5)";
          ctx.fillRect(x, y, p.size, p.size);
        });
      }
      break;
  }
  
  ctx.restore();
}

// Check for scheduled admin events
function checkScheduledAdminEvents() {
  const now = new Date();
  
  adminAbuseEvents.forEach(event => {
    // Only process if event has triggers array
    if (event.triggers && Array.isArray(event.triggers)) {
      event.triggers.forEach(trigger => {
        if (!trigger.triggered && trigger.date <= now) {
          trigger.triggered = true;
          triggerAdminEvent(event);
        }
      });
    }
  });
}

// Check every second for scheduled events
setInterval(checkScheduledAdminEvents, 1000);

/**
 * Draws the weather animation based on the current weather type.
 * This function is called continuously by the requestAnimationFrame loop.
 * @param {CanvasRenderingContext2D} ctx - The canvas context to draw on.
 * @returns {undefined}
 */
function drawWeatherAnimation(ctx) {
  if (!currentWeather) return;

  ctx.save();
  if (currentWeather === "Rain") {
    ctx.strokeStyle = "rgba(150,200,255,0.5)";
    ctx.lineWidth = 1.5;
    for (const p of weatherParticles) {
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(p.x, p.y + p.len);
      ctx.stroke();
    }
  }

  if (currentWeather === "Wind") {
    ctx.strokeStyle = "rgba(255,255,255,0.2)";
    ctx.lineWidth = 2;
    for (const p of weatherParticles) {
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(p.x + p.len, p.y);
      ctx.stroke();
    }
  }

  if (currentWeather === "Thunder") {
    const a = weatherParticles[0].alpha;
    if (a > 0) {
      ctx.fillStyle = `rgba(255,255,200,${a})`;
      ctx.fillRect(0, 0, W, H);
    }
  }
  ctx.restore();
}

// Auto every 5 minutes
setInterval(() => {
  if (!currentWeather) triggerWeatherEvent();
}, 300_000);

// Manual trigger with ']'
document.addEventListener("keydown", e => {
  if (e.key === "]") triggerWeatherEvent();
});
// Focus search box with Ctrl+F or Cmd+F
document.addEventListener('keydown', (e) => {
  if ((e.ctrlKey || e.metaKey) && e.key === 'f' && !insideHouse) {
    e.preventDefault(); // Prevent browser search
    const searchInput = document.getElementById('petSearchInput');
    if (searchInput) {
      searchInput.focus();
    }
  }
  
  // Clear search with ESC key
  if (e.key === 'Escape') {
    const searchInput = document.getElementById('petSearchInput');
    if (searchInput && document.activeElement === searchInput) {
      clearPetSearch();
      searchInput.blur();
    }
  }
});
//setInterval(() => { money += incomePerSec; updateDisplays(); }, 1000);
setInterval(() => { 
  money += incomePerSec; 
  updateDisplays(); 
  
  if (potionActive) {
    recomputeIncome(); // Updates the countdown timer every second
  }
}, 1000);

function updateDisplays() {
  moneyDisplay.textContent = "Money: " + formatBigInt(money);  
  moneyDisplay.title = formatBigInt2(money);

  incomeDisplay.textContent = "Income/sec: " + formatBigInt(incomePerSec);
  incomeDisplay.title = formatBigInt2(incomePerSec);

  houseDisplay.textContent = "House value: " + formatBigInt(houseValue);
  houseDisplay.title = formatBigInt2(houseValue);
  
  updateEnchantUI(); // NEW

  if (!insideHouse) {
    for (let c of currentCubes()) {
      const el = document.getElementById("cnt-" + c.name.replace(/\s+/g, "_"));
      if (el) el.textContent = legendCounts[c.name].toString();
    }
  }
}

function rectsOverlap(a, b) { return !(a.x + a.w <= b.x || b.x + b.w <= a.x || a.y + a.h <= b.y || b.y + b.h <= a.y); }


// ğŸŒªï¸ TORNADO LOGIC
if (tornado.visible) {
  const dx = character.x - tornado.x;
  const dy = character.y - tornado.y;
  const distance = Math.hypot(dx, dy);
  
  if (distance > 5) {
    tornado.x += (dx / distance) * tornado.speed * dt;
    tornado.y += (dy / distance) * tornado.speed * dt;
  }
  
  tornado.angle += dt * 10;
  
  // Check collision with player
  if (rectsOverlap(tornado, character)) {
    tornado.visible = false;
    endAdminEvent();
    money = money / 2n;
    alert("ğŸŒªï¸ Tornado hit you! Lost 50% money!");
  }
}
checkCubeCollisions();
  checkHouseDeposit();

function checkCubeCollisions() {
  for (let c of cubes) {
    if (rectsOverlap(character, c.pos)) {
      character.assignedName = c.name;
      character.assignedValue = BigInt(c.value);
      resolveSolidCollision(character, c.pos);
    }
  }
}
// Add this near your other admin functions
function checkGameHealth() {
  console.log('=== GAME HEALTH CHECK ===');
  console.log('Player Pets:', playerPets.length);
  console.log('Pet Timers:', Object.keys(petTimers).length);
  console.log('Boss Drops:', bossDrops.length);
  console.log('Specials:', specials.length);
  console.log('Admin Particles:', adminEventParticles.length);
  console.log('Weather Particles:', weatherParticles.length);
  console.log('Slashes:', slashes.length);
  console.log('Snowflakes:', christmasEvent.snowflakes.length);
  console.log('========================');
}

// Call this every minute to monitor
setInterval(checkGameHealth, 60000);
function resolveSolidCollision(a, b) {
  const overlapX = Math.min(a.x + a.w - b.x, b.x + b.w - a.x);
  const overlapY = Math.min(a.y + a.h - b.y, b.y + b.h - a.y);
  if (overlapX < overlapY) a.x += (a.x < b.x) ? -overlapX : overlapX;
  else a.y += (a.y < b.y) ? -overlapY : overlapY;
}

function handleSlash() {
  specials.forEach(s => {
    if (s.visible && rectsOverlap({x: character.x-10, y: character.y-10, w: character.w+20, h: character.h+20}, s)) {
      s.visible = false;
      // maybe apply some effect
    }
  });
}

/// WINDOW EVENT LISTENERS
const keys = {};
window.addEventListener("keydown", e => {
  const key = e.key.toLowerCase();
  if (["w","a","s","d","arrowup","arrowdown","arrowleft","arrowright"].includes(key)) {
    keys[key] = true;
  }

  // Sword toggle
  if (key === "q") character.hasSword = !character.hasSword;
  if (key === "z" && character.hasSword && !character.slashing) {
    character.slashing = true;
    setTimeout(() => { character.slashing = false; }, character.slashDuration);
  }
  // NEW: Harpoon attack with X key
  if (key === "x" && harpoon.equipped) {
    useHarpoon();
  }
  
  // NEW: Summon Enchanted Leviathan with E key (during the 10 second window)
  if (key === "e" && leviathanBoss.canSummonEnchanted) {
    summonEnchantedLeviathan();
  }
  // === ADMIN PANEL (: key) ===
  if (e.key === ":") {
    toggleAdminPanel();
    return; // Stop processing other keys
  }
  
  // Focus search with Ctrl/Cmd+F
  if ((e.ctrlKey || e.metaKey) && e.key === 'f' && !insideHouse) {
    e.preventDefault();
    const searchInput = document.getElementById('petSearchInput');
    if (searchInput) searchInput.focus();
  }
  
  // Clear search with ESC
  if (e.key === 'Escape') {
    const searchInput = document.getElementById('petSearchInput');
    if (searchInput && document.activeElement === searchInput) {
      clearPetSearch();
      searchInput.blur();
    }
  }
});

window.addEventListener("keyup", e => {
  const key = e.key.toLowerCase();
  if ("wasd".includes(key)) keys[key] = false;
});

window.addEventListener("keyup", e => { if ("wasd".includes(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false; });
canvas.addEventListener("mousedown", e => {
  const r = canvas.getBoundingClientRect();
  character.target = { x: e.clientX - r.left - character.w / 2, y: e.clientY - r.top - character.h / 2 };
});
// === TIER SYSTEM BUTTONS ===
function updateTierButtons() {
  upgradeBtn.disabled = (cubeTier >= 3);
  downgradeBtn.disabled = (cubeTier <= 0);
  tierHint.textContent = `Current Tier: ${cubeTier + 1}`;
}
function performRebirth() {
  // Check if at max rebirth and should show Ascension instead
  if (rebirthCount >= rebirthLevels.length) {
    performAscension();
    return;
  }

  const nextRebirth = rebirthLevels[rebirthCount];
  
  // Check if player has enough money
  if (money < nextRebirth.cost) {
    alert(`âŒ Not enough money! Need ${formatBigInt(nextRebirth.cost)}`);
    return;
  }

  // Check if player has enough cubes
  const cubeCount = legendCounts[nextRebirth.requiredCube] || 0n;
  
  if (cubeCount < BigInt(nextRebirth.requiredCount)) {
    let availableCubes = "";
    for (let key in legendCounts) {
      if (legendCounts[key] > 0n) {
        availableCubes += `\n${key}: ${legendCounts[key]}`;
      }
    }
    
    alert(`âŒ Need ${nextRebirth.requiredCount} ${nextRebirth.requiredCube} cubes!\nYou have: ${cubeCount}\n\nYour cubes:${availableCubes}`);
    return;
  }

  // Build rewards message
  let rewardsMsg = `ğŸ”„ REBIRTH ${nextRebirth.level}\n\n`;
  rewardsMsg += `Cost: ${formatBigInt(nextRebirth.cost)}\n`;
  rewardsMsg += `Required: ${nextRebirth.requiredCount}x ${nextRebirth.requiredCube}\n\n`;
  rewardsMsg += `Rewards:\n`;
  rewardsMsg += `â€¢ +0.5x Income Multiplier\n`;
  
  if (nextRebirth.petSlotReward) {
    rewardsMsg += `â€¢ +${nextRebirth.petSlotReward} Pet Slot(s)\n`;
  }
  
  if (nextRebirth.goldenSwordReward) {
    rewardsMsg += `â€¢ ğŸ† Golden Sword (6 damage)\n`;
  }
  
  rewardsMsg += `\nâš ï¸ This will reset:\n`;
  rewardsMsg += `- Money â†’ 1K\n`;
  rewardsMsg += `- Income/sec â†’ 0\n`;
  rewardsMsg += `- House Value â†’ 0\n`;
  rewardsMsg += `- All Legend Counts â†’ 0\n\n`;
  rewardsMsg += `Continue?`;

  if (!confirm(rewardsMsg)) {
    return;
  }

// Perform rebirth
rebirthCount++;
rebirthMultiplier += nextRebirth.incomeMultiplier;

// Unlock enchanting at rebirth 2
if (rebirthCount >= 2) {
  enchantmentSystem.unlocked = true;
  console.log("ğŸ”® Enchanting system unlocked!");
}

// Unlock crafting at rebirth 1
if (rebirthCount >= 1) {
  if (!craftingSystem.unlocked) {
    craftingSystem.unlocked = true;
    console.log("ğŸ”¨ Crafting system unlocked!");
    
    // Auto-unlock all auto-unlock recipes
    for (let recipeName in craftingSystem.recipes) {
      const recipe = craftingSystem.recipes[recipeName];
      if (recipe.autoUnlock) {
        unlockCraftingRecipe(recipeName);
      }
    }
  }
}
  // Apply pet slot rewards
  if (nextRebirth.petSlotReward) {
    maxPetSlots += nextRebirth.petSlotReward;
  }
  
  // Give Golden Sword
  if (nextRebirth.goldenSwordReward) {
    const existing = playerInventory.Swords.find(i => i.name === "Golden Sword");
    if (!existing) {
      playerInventory.Swords.push({
        icon: "ğŸ†",
        name: "Golden Sword",
        count: 1,
        special: 6
      });
    }
  }
  
  // Reset everything
  money = 1000n;
  incomePerSec = 0n;
  houseValue = 0n;
  
  // Reset all legend counts
  for (let key in legendCounts) {
    legendCounts[key] = 0n;
  }
  
  // Reset character
  character.assignedValue = 0n;
  character.assignedName = null;
  
  // Recalculate income
  recomputeIncome();
  updateDisplays();
  updateInventoryDisplay();
  updateRebirthUI();
  
  // Auto-save
  saveBtn.click();
  
  // Build completion message
  let completionMsg = `âœ… Rebirth ${rebirthCount} Complete!\n\n`;
  completionMsg += `Income Multiplier: ${rebirthMultiplier}x\n`;
  completionMsg += `Max Pet Slots: ${maxPetSlots}\n`;
  
  if (nextRebirth.goldenSwordReward) {
    completionMsg += `\nğŸ† Golden Sword unlocked in inventory!`;
  }
  
  alert(completionMsg);
}

function performAscension() {
  // Check if max ascensions reached
  if (ascensionCount >= ascensionLevels.length) {
    alert("âœ¨ You have completed all Ascensions!\n\nYou cannot progress further.");
    return;
  }

  const nextAscension = ascensionLevels[ascensionCount];
  
  // Check if player has enough money
  if (money < nextAscension.cost) {
    alert(`âŒ Not enough money! Need ${formatBigInt(nextAscension.cost)}`);
    return;
  }

  // Build rewards message
  let rewardsMsg = `âœ¨ ASCENSION ${nextAscension.level} âœ¨\n\n`;
  rewardsMsg += `Cost: ${formatBigInt(nextAscension.cost)}\n\n`;
  rewardsMsg += `Rewards:\n`;
  rewardsMsg += `â€¢ ${nextAscension.rewards.eggs} Ascension Eggs\n`;
  rewardsMsg += `â€¢ ${nextAscension.rewards.totem} Heavenly Totem\n`;
  
  if (nextAscension.rewards.skin) {
    rewardsMsg += `â€¢ Heavenly Skin\n`;
  }
  
  rewardsMsg += `\nâš ï¸ THIS WILL RESET EVERYTHING:\n`;
  rewardsMsg += `- Money â†’ 1K\n`;
  rewardsMsg += `- Income/sec â†’ 0\n`;
  rewardsMsg += `- House Value â†’ 0\n`;
  rewardsMsg += `- All Legend Counts â†’ 0\n`;
  rewardsMsg += `- ALL Boss Drops â†’ 0\n`;
  rewardsMsg += `- ALL Shop Items â†’ Cleared\n`;
  rewardsMsg += `- Pets kept, but unequipped\n`;
  rewardsMsg += `- REBIRTHS RESET TO 0\n\n`;
  rewardsMsg += `âš ï¸ This is a MAJOR reset! Continue?`;

  if (!confirm(rewardsMsg)) {
    return;
  }

  // Perform ascension
  ascensionCount++;
  
  // **RESET REBIRTHS**
  rebirthCount = 0;
  rebirthMultiplier = 1.0;
  maxPetSlots = 3;
  
  // Give Ascension Eggs
  const existing = playerInventory.Eggs.find(i => i.name === "Ascension Egg");
  if (existing) {
    existing.count += nextAscension.rewards.eggs;
  } else {
    playerInventory.Eggs.push({
      icon: "âœ¨",
      name: "Ascension Egg",
      count: nextAscension.rewards.eggs,
      special: 1
    });
  }
  
  // Give Heavenly Totem
  const existingTotem = playerInventory.Relics.find(i => i.name === "Heavenly Totem");
  if (existingTotem) {
    existingTotem.count += nextAscension.rewards.totem;
  } else {
    playerInventory.Relics.push({
      icon: "âœ¨",
      name: "Heavenly Totem",
      count: nextAscension.rewards.totem,
      special: 1.35
    });
  }
  
  // Give Heavenly Skin if reward includes it
  if (nextAscension.rewards.skin) {
    const existingSkin = playerInventory.Skins.find(i => i.name === "Heavenly Skin");
    if (!existingSkin) {
      playerInventory.Skins.push({
        icon: "âœ¨",
        name: "Heavenly Skin",
        count: 1,
        special: 15
      });
    }
  }
  
  // FULL RESET
  money = 1000n;
  incomePerSec = 0n;
  houseValue = 0n;
  
  // Reset all legend counts
  for (let key in legendCounts) {
    legendCounts[key] = 0n;
  }
  
  // Clear ALL boss drops
  for (let key in dropCounters) {
    dropCounters[key] = 0;
    inventory[key] = 0;
  }
  
  // Clear ALL shop items (except Ascension rewards)
  playerInventory.Swords = [];
  playerInventory.Potions = [];
  
  // Keep only Ascension eggs, Heavenly Totems, and Heavenly Skin
  playerInventory.Eggs = playerInventory.Eggs.filter(i => i.name === "Ascension Egg");
  playerInventory.Relics = playerInventory.Relics.filter(i => i.name === "Heavenly Totem");
  playerInventory.Skins = playerInventory.Skins.filter(i => i.name === "Heavenly Skin");
  
  // Unequip all pets but keep them
  playerPets.forEach(p => p.equipped = false);
  equippedPets = [];
  
  // Reset character
  character.assignedValue = 0n;
  character.assignedName = null;
  
  // Check if any pet has enchant_keeper ability
  const hasEnchantKeeper = playerPets.some(p => 
    p.ability === "enchant_keeper" && p.equipped
  );

  // Remove enchantments from pets unless they have enchant_keeper
  if (!hasEnchantKeeper) {
    playerPets.forEach(pet => {
      if (pet.enchantment) {
        delete pet.enchantment;
      }
    });
    console.log("ğŸ’” All pet enchantments lost on ascension");
  } else {
    console.log("ğŸ’– Enchantments kept thanks to Enchant Keeper pet!");
  }
  
  // Recalculate income
  recomputeIncome();
  updateDisplays();
  updateInventoryDisplay();
  updateRebirthUI();
  
  // Auto-save
  saveBtn.click();
  
  // Build completion message
  let completionMsg = `âœ¨ ASCENSION ${ascensionCount} COMPLETE! âœ¨\n\n`;
  completionMsg += `Received:\n`;
  completionMsg += `â€¢ ${nextAscension.rewards.eggs} Ascension Eggs\n`;
  completionMsg += `â€¢ ${nextAscension.rewards.totem} Heavenly Totem\n`;
  
  if (nextAscension.rewards.skin) {
    completionMsg += `â€¢ Heavenly Skin\n`;
  }
  
  completionMsg += `\nAscensions: ${ascensionCount}/${ascensionLevels.length}`;
  completionMsg += `\nRebirths reset to 0 - work your way back to Rebirth 9!`;
  
  alert(completionMsg);
}

function updateRebirthUI() {
  // Check if at rebirth 9 (max rebirth)
  if (rebirthCount >= rebirthLevels.length) {
    // Show Ascension button
    if (ascensionCount >= ascensionLevels.length) {
      rebirthBtn.textContent = "âœ¨ Ascension (MAX)";
      rebirthBtn.disabled = true;
      rebirthHint.textContent = `Rebirths: ${rebirthCount} (${rebirthMultiplier}x) | Ascensions: ${ascensionCount}/${ascensionLevels.length} (MAX)`;
    } else {
      const nextAscension = ascensionLevels[ascensionCount];
      rebirthBtn.textContent = `âœ¨ Ascension ${nextAscension.level}`;
      rebirthBtn.disabled = false;
      rebirthHint.textContent = `Rebirths: ${rebirthCount} (${rebirthMultiplier}x) | Ascensions: ${ascensionCount}/${ascensionLevels.length} | Pets: ${maxPetSlots}`;
    }
  } else {
    // Normal rebirth
    const nextRebirth = rebirthLevels[rebirthCount];
    rebirthBtn.textContent = `ğŸ”„ Rebirth ${nextRebirth.level}`;
    rebirthBtn.disabled = false;
    rebirthHint.textContent = `Rebirths: ${rebirthCount} (${rebirthMultiplier}x) | Pets: ${maxPetSlots}`;
  }
}
function initializeGame() {
  cubes = buildCubes();
  renderLegendUI();
  updateInventoryDisplay();
  updateDisplays();
  updateTierButtons();
  updateRebirthUI();
  updateEventIndicator(); // â† ADD THIS
  initPetTimers(); // â† ADD THIS LINE
  updateAdventDay(); // NEW: Initialize advent calendar
  setTimeout(spawnBoss, 600000);
  specials.forEach(s => setTimeout(() => spawnSpecial(s), randomSpawnInterval(s.respawn)));
}
upgradeBtn.addEventListener("click", () => {
  if (cubeTier < 3) {
    cubeTier++;
    cubes = buildCubes();
    renderLegendUI();
    updateDisplays();
    updateTierButtons();
  }
});

downgradeBtn.addEventListener("click", () => {
  if (cubeTier > 0) {
    cubeTier--;
    cubes = buildCubes();
    renderLegendUI();
    updateDisplays();
    updateTierButtons();
  }
});
rebirthBtn.addEventListener("click", () => {
  performRebirth();
});

const adventBtn = document.getElementById('adventBtn');
if (adventBtn) {
  adventBtn.addEventListener('click', () => {
    showAdventCalendar();
  });
}

// --- SAVE & LOAD PROGRESS ---
const saveBtn = document.getElementById("saveBtn");
const loadBtn = document.getElementById("loadBtn");

saveBtn.addEventListener("click", () => {
  const data = {
    money: money.toString(),
    incomePerSec: incomePerSec.toString(),
    houseValue: houseValue.toString(),
    legendCounts: Object.fromEntries(
      Object.entries(legendCounts).map(([k, v]) => [k, v.toString()])
    ),
    dropCounters,
    playerInventory,
    cubeTier,
    bossDrops,
    rebirthCount,
    rebirthMultiplier,
    maxPetSlots,
    ascensionCount,
    // ENCHANTMENT DATA
    enchantmentSystem: {
      unlocked: enchantmentSystem.unlocked,
      totalEnchants: enchantmentSystem.totalEnchants,
      hasEnchantRelic: enchantmentSystem.hasEnchantRelic
    },
      // NEW: Add crafting system data
  craftingSystem: {
    unlocked: craftingSystem.unlocked,
    unlockedRecipes: craftingSystem.unlockedRecipes,
    materials: craftingSystem.materials
  },
    adventCalendar: {
      currentDay: adventCalendar.currentDay,
      claimedDays: adventCalendar.claimedDays,
      year: adventCalendar.year,
      debugOffset: adventCalendar.debugOffset || 0
    },
    christmasEvent: {
      snowCollected: christmasEvent.snowCollected,
      lastTrigger: christmasEvent.lastTrigger
    },
    heavenlyEvent: {
      lastTrigger: heavenlyEvent.lastTrigger
    }
  };

  data.equipped = {
    swords: equippedSwordSpecial,
    relics: equippedRelicSpecial,
    eggs: equippedEggSpecial,
    skins: equippedSkinSpecial,
    potions: equippedPotionSpecial
  };
  
  // Save pets and timers
  data.playerPets = JSON.parse(JSON.stringify(playerPets));
  data.petTimers = {};
  for (let petId in petTimers) {
    data.petTimers[petId] = {
      lastTrigger: petTimers[petId].lastTrigger,
      cooldown: petTimers[petId].cooldown
    };
  }
  
  localStorage.setItem("cubeGameSave", JSON.stringify(data));
  alert("âœ… Progress Saved!");
});


loadBtn.addEventListener("click", () => {
  const raw = localStorage.getItem("cubeGameSave");
  if (!raw) return alert("âš ï¸ No saved game found.");

  if (!confirm("âš ï¸ Are you sure you want to load your previous save? All unsaved progress will be lost.")) {
    return;
  }

  try {
    const data = JSON.parse(raw);
    money = BigInt(data.money);
    incomePerSec = BigInt(data.incomePerSec);
    houseValue = BigInt(data.houseValue);
    for (let k in data.legendCounts) legendCounts[k] = BigInt(data.legendCounts[k]);
    cubeTier = data.cubeTier || 0;
    
    rebirthCount = data.rebirthCount || 0;
    rebirthMultiplier = data.rebirthMultiplier || 1.0;
    maxPetSlots = data.maxPetSlots || 3;
    ascensionCount = data.ascensionCount || 0;
// NEW: Check if crafting should be unlocked based on rebirth level
if (rebirthCount >= 1) {
  craftingSystem.unlocked = true;
  
  // Auto-unlock all auto-unlock recipes
  for (let recipeName in craftingSystem.recipes) {
    const recipe = craftingSystem.recipes[recipeName];
    if (recipe.autoUnlock && !craftingSystem.unlockedRecipes.includes(recipeName)) {
      craftingSystem.unlockedRecipes.push(recipeName);
    }
  }
}
    if (data.heavenlyEvent) {
      heavenlyEvent.lastTrigger = data.heavenlyEvent.lastTrigger || 0;
    }
    
    // LOAD ENCHANTMENT DATA
    if (data.enchantmentSystem) {
      enchantmentSystem.unlocked = data.enchantmentSystem.unlocked || false;
      enchantmentSystem.totalEnchants = data.enchantmentSystem.totalEnchants || 0;
      enchantmentSystem.hasEnchantRelic = data.enchantmentSystem.hasEnchantRelic || false;
      
      console.log(`âœ… Loaded enchantments: ${enchantmentSystem.totalEnchants} total, unlocked: ${enchantmentSystem.unlocked}`);
    } else {
      // If no enchantment data exists, check if should be unlocked based on rebirth count
      enchantmentSystem.unlocked = (rebirthCount >= 2);
      enchantmentSystem.totalEnchants = 0;
      enchantmentSystem.hasEnchantRelic = false;
    }
    // LOAD CRAFTING DATA
if (data.craftingSystem) {
  craftingSystem.unlocked = data.craftingSystem.unlocked || false;
  craftingSystem.unlockedRecipes = data.craftingSystem.unlockedRecipes || [];
  craftingSystem.materials = data.craftingSystem.materials || {};
  
  console.log(`âœ… Loaded crafting: ${Object.keys(craftingSystem.materials).length} materials`);
}
    if (data.adventCalendar) {
      adventCalendar.currentDay = data.adventCalendar.currentDay || 1;
      adventCalendar.claimedDays = data.adventCalendar.claimedDays || [];
      adventCalendar.year = data.adventCalendar.year || new Date().getFullYear();
      adventCalendar.debugOffset = data.adventCalendar.debugOffset || 0;
    }
    
    if (data.christmasEvent) {
      christmasEvent.snowCollected = data.christmasEvent.snowCollected || 0;
      christmasEvent.lastTrigger = data.christmasEvent.lastTrigger || 0;
      dropCounters["â„ï¸ Snowflakes"] = christmasEvent.snowCollected;
      inventory["â„ï¸ Snowflakes"] = christmasEvent.snowCollected;
    }

    if (data.dropCounters) Object.assign(dropCounters, data.dropCounters);
    if (data.playerInventory) {
      for (let cat in data.playerInventory) {
        playerInventory[cat] = data.playerInventory[cat];
      }
    }

    if (data.equipped) {
      equippedSwordSpecial = data.equipped.swords || 0;
      equippedRelicSpecial = data.equipped.relics || 1;
      equippedEggSpecial = data.equipped.eggs || 0;
      equippedSkinSpecial = data.equipped.skins || 1;
      equippedPotionSpecial = data.equipped.potions || 1;
    }

    if (data.bossDrops) bossDrops = data.bossDrops;
    
    // Load pets properly
    playerPets = [];
    equippedPets = [];
    
    if (data.playerPets && Array.isArray(data.playerPets)) {
      playerPets = data.playerPets;
      equippedPets = playerPets.filter(p => p.equipped);
      console.log(`âœ… Loaded ${playerPets.length} pets (${equippedPets.length} equipped)`);
    }
    
    if (data.petTimers) {
      petTimers = data.petTimers;
    } else {
      petTimers = {};
    }

    cubes = buildCubes();
    renderLegendUI();
    updateDisplays();
    updateInventoryDisplay();
    updateTierButtons();
    updateRebirthUI();
    updateEnchantUI(); // UPDATE ENCHANT UI
    updateAdminPanelStats(); // UPDATE ADMIN PANEL (this updates the enchant count in admin panel)
    initPetTimers();
    recomputeIncome();

    alert("âœ… Progress Loaded!");
  } catch (err) {
    console.error(err);
    alert("âŒ Failed to load save data!");
  }
});



// ---- Special Cubes ----
const specials = [
  { name: "teal", color: "teal", emoji: "ğŸ’", duration: 2000, respawn: 15000, effect: c => money += money / 10n },
  { name: "brown", color: "brown", emoji: "ğŸ’€", duration: 5000, respawn: 60000, chase: true, speed: 120, effect: c => money -= money / 10n },
  { name: "yellow", color: "yellow", emoji: "â­", duration: 1000, respawn: 300000, effect: c => money += money * 30n / 100n },
  { name: "scarlet", color: "crimson", emoji: "ğŸ”¥", duration: 15000, respawn: 300000, chase: true, speed: 180, effect: c => money -= money * 30n / 100n },
  { name: "pink", color: "pink", emoji: "ğŸ’–", duration: 1000, respawn: 390000, effect: c => money += money * 50n / 100n },
  { name: "magenta", color: "magenta", emoji: "ğŸ’”", duration: 30000, respawn: 420000, chase: true, speed: 240, effect: c => money -= money * 50n / 100n },
];

// âš¡ Slash effects list
const slashes = [];

function spawnSlash(x, y, angle) {
  slashes.push({
    x, y,
    angle,
    life: 0,          // starts fresh
    maxLife: 15,      // frames before fade out
  });
}

// helper: generate random spawn interval (1Ã— to 1.3Ã— respawn)
function randomSpawnInterval(respawn) {
  return respawn + Math.random() * respawn * 0.3;
}

// spawn special cube at random position avoiding character and cubes
function spawnSpecial(s) {
  // position randomly, avoiding character and cubes
  do {
    s.x = Math.random() * (W - CUBE_SIZE);
    s.y = Math.random() * (H - CUBE_SIZE);
  } while (cubes.some(c => rectsOverlap({ x: s.x, y: s.y, w: CUBE_SIZE, h: CUBE_SIZE }, c.pos)) ||
           rectsOverlap({ x: s.x, y: s.y, w: CUBE_SIZE, h: CUBE_SIZE }, character));

  s.visible = true;

  // hide after duration
  setTimeout(() => {
    s.visible = false;
    // schedule next spawn strictly based on respawn timer
    setTimeout(() => spawnSpecial(s), randomSpawnInterval(s.respawn));
  }, s.duration);
}

// initialize special cubes with first spawn delayed by respawn time
//specials.forEach(s => setTimeout(() => spawnSpecial(s), randomSpawnInterval(s.respawn)));

function spawnBoss() {
  boss.x = Math.random() * (W - boss.w);
  boss.y = Math.random() * (H - boss.h);
  boss.spawnX = boss.x; // save spawn position
  boss.spawnY = boss.y;
  boss.visible = true;
  boss.hitsRemaining = 10;
  boss.playerHits = 0;

  nextBossSpawn = Date.now() + bossSpawnInterval; // reset timer

  // hide boss if not defeated in 30 seconds
  setTimeout(() => {
    if (boss.visible) boss.visible = false;
  }, 60000);
}


// initial spawn timer (10 min after game starts)
//setTimeout(spawnBoss, 600000);


// ---- Update loop handling specials ----
function update(dt) {
  let mx = 0, my = 0;
if (keys.w || keys.arrowup) my -= 1;
if (keys.s || keys.arrowdown) my += 1;
if (keys.a || keys.arrowleft) mx -= 1;
if (keys.d || keys.arrowright) mx += 1;
 updatePets(dt); // â† ADD THIS LINE
   updatePets(dt);
  updateSnowflakes(dt); // NEW: Add snowflake updates

  if (mx || my) {
    const len = Math.hypot(mx, my);
    character.x += (mx / len) * character.speed * dt * speedMultiplier;
    character.y += (my / len) * character.speed * dt * speedMultiplier;
  } else if (character.target) {
    const dx = character.target.x - character.x, dy = character.target.y - character.y, dist = Math.hypot(dx, dy);
    if (dist > 2) { 
      character.x += (dx / dist) * character.speed * dt * speedMultiplier; 
      character.y += (dy / dist) * character.speed * dt * speedMultiplier; }
    else character.target = null;
  }

  character.x = Math.max(0, Math.min(W - character.w, character.x));
  character.y = Math.max(0, Math.min(H - character.h, character.y));
updatePets(dt); // â† ADD THIS LINE HERE
  specials.forEach(s => {
    if (s.visible && s.chase) {
      const dx = character.x - s.x, dy = character.y - s.y, dist = Math.hypot(dx, dy);
      if (dist > 1) { s.x += (dx / dist) * (s.speed * dt); s.y += (dy / dist) * (s.speed * dt); 
          if (boss.pauseUntil && Date.now() < boss.pauseUntil) return;        
      }
    }
    if (s.visible && rectsOverlap(s, character)) {
      s.visible = false;
      s.effect();
      updateDisplays();
      // next spawn is already scheduled independently, no need to trigger here
    }
  });

// ğŸ§© Boss movement and attack logic
if (boss.visible) {
  const dx = character.x - boss.x;
  const dy = character.y - boss.y;
  const distance = Math.hypot(dx, dy);

  if (boss.retreating) {
    // Move back to original spawn
    const rx = boss.spawnX - boss.x;
    const ry = boss.spawnY - boss.y;
    const rDist = Math.hypot(rx, ry);
    if (rDist > 2) {
      boss.x += (rx / rDist) * boss.speed * dt * 0.5;
      boss.y += (ry / rDist) * boss.speed * dt * 0.5;
    } else {
      boss.retreating = false; // stop retreating
      boss.pauseUntil = Date.now() + 800; // pause 0.8s before resuming chase

    }
  } else {
    // Normal chasing behavior
    if (distance > 2) {
      boss.x += (dx / distance) * boss.speed * dt * 0.5;
      boss.y += (dy / distance) * boss.speed * dt * 0.5;
    }

    // Attack range check
if (distance < boss.w * 1.2 && !boss.attackCooldown) {
  boss.attackCooldown = true;
  
  // Check for healing shield
  if (window.healingShieldActive) {
    window.healingShieldActive = false;
    const shield = document.getElementById('healingShield');
    if (shield) shield.remove();
    
    console.log("â˜˜ï¸ Healing shield blocked boss attack!");
    
    // Show blocked message
    const blocked = document.createElement('div');
    blocked.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(144, 238, 144, 0.95);
      color: white;
      padding: 20px 40px;
      border-radius: 15px;
      font-size: 24px;
      font-weight: bold;
      z-index: 10002;
    `;
    blocked.textContent = 'â˜˜ï¸ ATTACK BLOCKED! â˜˜ï¸';
    document.body.appendChild(blocked);
    
    setTimeout(() => blocked.remove(), 2000);
  } else {
    // Normal boss attack
    boss.playerHits++;

    if (boss.playerHits < 3) {
      boss.retreating = true;
    } else {
      money = money / 2n;
      boss.visible = false;
      boss.playerHits = 0;
      nextBossSpawn = Date.now() + bossSpawnInterval;
    }
  }

  setTimeout(() => (boss.attackCooldown = false), 2000);
}
  }
}
// ğŸ—¡ï¸ Sword vs Boss collision check
if (boss.visible && character.slashing && !boss.retreating) {
// Check if boss is defeated
if (boss.hitsRemaining <= 0) {
  boss.visible = false;
  boss.hitsRemaining = boss.hitsToDie;
  boss.playerHits = 0;
  nextBossSpawn = Date.now() + bossSpawnInterval;

  // Apply lucky star multiplier to drop chances
  const dropMultiplier = window.luckyStarActive ? window.luckyStarMultiplier : 1.0;
  const giftMult = window.giftDropMultiplier || 1.0;
  
  const drops = [];
  if (Math.random() <= 1.0 * dropMultiplier) drops.push("ğŸ¦´ Skeleton Bones");
  if (Math.random() <= 0.30 * dropMultiplier) drops.push("ğŸ“¿ Crossbones Relic");
  if (Math.random() <= 0.05 * dropMultiplier) drops.push("â¬œğŸ’€ Skeleton Skin");
  if (Math.random() <= 0.01 * dropMultiplier) drops.push("â¬œâ˜ ï¸ Crossbones Cube");

  bossDrops.push({
    x: boss.x + boss.w / 2,
    y: boss.y,
    items: drops,
    timer: 3000,
    opacity: 1
  });

drops.forEach(item => {
  // Remove emoji prefix to get material name
  const materialName = item.replace("ğŸª¶ ", "").replace("ğŸ”¥ ", "");
  
  // Add to crafting materials instead
  if (!craftingSystem.materials[materialName]) {
    craftingSystem.materials[materialName] = 0;
  }
  craftingSystem.materials[materialName]++;
  
  console.log(`Added ${materialName} to crafting materials`);
});
  updateInventoryDisplay();
}


  // Define sword attack range in front of the player based on direction of movement
  const swordRange = 40;
  let swordBox = { x: character.x, y: character.y, w: character.w, h: character.h };

  // Check movement keys to infer facing direction
  if (keys.w) swordBox.y -= swordRange;
  else if (keys.s) swordBox.y += swordRange;
  else if (keys.a) swordBox.x -= swordRange;
  else swordBox.x += swordRange;

  swordBox.w += swordRange / 2;
  swordBox.h += swordRange / 2;

  // For debugging (optional)
  // ctx.strokeStyle = "yellow";
  // ctx.strokeRect(swordBox.x, swordBox.y, swordBox.w, swordBox.h);

if (rectsOverlap(swordBox, boss) && !boss.hitCooldown && !boss.retreating) {
  // Calculate pet damage multiplier
  let petDamageMultiplier = 1;
  equippedPets.forEach(pet => {
    if (pet.ability === "double_damage") {
      petDamageMultiplier *= pet.abilityValue;
    }
  });

  // Apply sword special multiplier + pet damage
const enchantDmgBoost = window.enchantDamageBoost || 1;
const dmg = Math.max(1, Math.floor(equippedSwordSpecial * petDamageMultiplier * enchantDmgBoost));
  boss.hitsRemaining -= dmg;

  boss.flash = true;
  spawnSlash(boss.x + boss.w / 2, boss.y + boss.h / 2, Math.random() * Math.PI * 2);

  // Rest of your existing boss retreat code...
  boss.retreating = true;
  boss.invulnerable = true;

  const angle = Math.random() * 2 * Math.PI;
  const distance = 30 + Math.random() * 20;
  const newX = boss.x + Math.cos(angle) * distance;
  const newY = boss.y + Math.sin(angle) * distance;

  const startX = boss.x;
  const startY = boss.y;
  const startTime = performance.now();
  const retreatDuration = 400;

  function retreatAnimation(now) {
    const progress = Math.min((now - startTime) / retreatDuration, 1);
    boss.x = startX + (newX - startX) * progress;
    boss.y = startY + (newY - startY) * progress;

    if (progress < 1) {
      requestAnimationFrame(retreatAnimation);
    } else {
      boss.retreating = false;
      boss.invulnerable = false;
    }
  }
  requestAnimationFrame(retreatAnimation);

  setTimeout(() => (boss.flash = false), 150);
  boss.hitCooldown = true;
  setTimeout(() => (boss.hitCooldown = false), 300);

  // Check if boss is defeated
  if (boss.hitsRemaining <= 0) {
    boss.visible = false;
    boss.hitsRemaining = boss.hitsToDie;
    boss.playerHits = 0;
    nextBossSpawn = Date.now() + bossSpawnInterval;

    const drops = [];
    if (Math.random() <= 1.0) drops.push("ğŸ¦´ Skeleton Bones");
    if (Math.random() <= 0.30) drops.push("ğŸ“¿ Crossbones Relic");
    if (Math.random() <= 0.05) drops.push("â¬œğŸ’€ Skeleton Skin");
    if (Math.random() <= 0.01) drops.push("â¬œâ˜ ï¸ Crossbones Cube");

    bossDrops.push({
      x: boss.x + boss.w / 2,
      y: boss.y,
      items: drops,
      timer: 3000,
      opacity: 1
    });

    drops.forEach(item => {
      if (inventory[item] !== undefined) {
        inventory[item]++;
        dropCounters[item]++;
      }
    });
    updateInventoryDisplay();
  }
}
}


// ğŸ” Update slash effects
for (let i = slashes.length - 1; i >= 0; i--) {
  const s = slashes[i];
  s.life++;
  if (s.life > s.maxLife) slashes.splice(i, 1);
}
// In the update() function, find the boss drops cleanup section and modify it:
// ğŸ”„ Update boss loot fade timers
for (let i = bossDrops.length - 1; i >= 0; i--) {
  const drop = bossDrops[i];
  drop.timer -= dt * 1000;
  drop.opacity = Math.max(0, drop.timer / 3000);
  if (drop.timer <= 0) bossDrops.splice(i, 1);
}

// Add limit to prevent array from growing too large
if (bossDrops.length > MAX_BOSS_DROPS) {
  bossDrops.splice(0, bossDrops.length - MAX_BOSS_DROPS);
}
  checkCubeCollisions();
  checkHouseDeposit();
  
// CLEANUP: Remove old invisible specials to prevent memory leak
const invisibleCount = specials.filter(s => !s.visible && !s.isPurpleSpawn && !s.isGiftSpawn).length;
if (invisibleCount > MAX_SPECIALS) {
  specials = specials.filter(s => s.visible || s.isPurpleSpawn || s.isGiftSpawn);
}
}


function render() {
  
  
  // Apply earthquake shake
  if (currentAdminEvent && currentAdminEvent.animation === "earthquake") {
    ctx.save();
    ctx.translate(adminEventShakeX, adminEventShakeY);
  }

  ctx.clearRect(0, 0, W, H);
 
  const cycle = dayNightCycle[dayNightCycle.current];
  const gradient = ctx.createLinearGradient(0, 0, 0, H);
  
  const colors = cycle.canvasGradient;
  gradient.addColorStop(0, colors[0]);
  gradient.addColorStop(0.5, colors[1]);
  gradient.addColorStop(1, colors[2]);
  
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, W, H);
  
  // Draw stars at night and during sunrise (fading)
  if (dayNightCycle.current === "night" || dayNightCycle.current === "sunrise") {
    ctx.fillStyle = "white";
    dayNightStars.forEach(star => {
      let alpha = 0.3 + star.twinkle * 0.7;
      
      // Fade out stars during sunrise
      if (dayNightCycle.current === "sunrise") {
        alpha *= 0.4;
      }
      
      ctx.globalAlpha = alpha;
      ctx.fillRect(star.x, star.y, star.size, star.size);
    });
    ctx.globalAlpha = 1;
  }
  
  // Draw clouds during sunset and sunrise
  if (dayNightCycle.current === "sunset" || dayNightCycle.current === "sunrise") {
    sunsetClouds.forEach(cloud => {
      ctx.save();
      ctx.globalAlpha = cloud.opacity;
      
      // Cloud color varies by time
      if (dayNightCycle.current === "sunset") {
        ctx.fillStyle = "#FF6B6B";
      } else {
        ctx.fillStyle = "#FFB347";
      }
      
      // Draw simple cloud shape
      ctx.beginPath();
      ctx.ellipse(cloud.x, cloud.y, cloud.width / 2, cloud.height / 2, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(cloud.x + cloud.width / 3, cloud.y - cloud.height / 3, cloud.width / 3, cloud.height / 3, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(cloud.x - cloud.width / 3, cloud.y - cloud.height / 4, cloud.width / 3, cloud.height / 3, 0, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    });
  }
  
  // Draw celestial body (sun/moon) with appropriate position
  ctx.font = "48px sans-serif";
  ctx.textAlign = "right";
  ctx.textBaseline = "top";
  ctx.fillText(cycle.celestialBody, W - 20, cycle.celestialY);

  ctx.fillStyle = 'rgba(255,255,255,0.02)';
  ctx.fillRect(12, 8, W - 24, 110);

// ... existing rendering code for cubes, house, character ...

renderPets(ctx); // â† ADD THIS LINE

// ... boss rendering and rest of code ...
// ğŸ•’ Boss Timer Display
const now = Date.now();
ctx.fillStyle = 'white';
ctx.font = '16px Arial';
ctx.textAlign = 'left';
ctx.textBaseline = 'top';

if (!boss.visible) {
  const timeLeft = Math.max(0, nextBossSpawn - now);
  const minutes = Math.floor(timeLeft / 60000);
  const seconds = Math.floor((timeLeft % 60000) / 1000);
  ctx.fillText(`Boss in: ${minutes}:${seconds.toString().padStart(2, '0')}`, 20, 20);
} else {
  ctx.fillText(`Boss HP: ${boss.hitsRemaining}/${boss.hitsToDie}`, 20, 20);
  ctx.fillText(`Your HP: ${3 - boss.playerHits}/3`, 20, 40);
}

// Display day/night cycle timer
const timeUntilChange = Math.max(0, dayNightCycle.nextChange - now);
const minutes = Math.floor(timeUntilChange / 60000);
const seconds = Math.floor((timeUntilChange % 60000) / 1000);
const cycleName = dayNightCycle[dayNightCycle.current].name;

ctx.fillStyle = 'white';
ctx.font = '14px Arial';
ctx.textAlign = 'left';
ctx.fillText(`${cycleName} - Next: ${minutes}:${seconds.toString().padStart(2, '0')}`, 20, 60);

cubes.forEach(c => {
  const p = c.pos;
  ctx.fillStyle = c.color;
  ctx.fillRect(p.x, p.y, p.w, p.h);
  ctx.strokeStyle = 'rgba(0,0,0,0.6)';
  ctx.lineWidth = 2;
  ctx.strokeRect(p.x + 0.5, p.y + 0.5, p.w - 1, p.h - 1);
  ctx.fillStyle = (c.color === '#e9ecef' || c.color === '#fff1a8' || c.color === '#ffc89b' || c.color === '#7fffd4' || c.color === '#ffcc33') ? '#111' : '#fff';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  // Custom labels for tier 3 and 4 cubes
  let displayLabel = shortLabel(c.value);
  if (c.name === "Dark Red") displayLabel = "1SP";
  else if (c.name === "Neon Green") displayLabel = "10SP";
  else if (c.name === "Leafy Green") displayLabel = "100SP";
  else if (c.name === "Aquamarine") displayLabel = "1OC";
  else if (c.name === "Noir") displayLabel = "10OC";
  else if (c.name === "Bright Orange") displayLabel = "100OC";
  else if (c.name === "Sunny Orange") displayLabel = "1NO";
  else if (c.name === "Pink") displayLabel = "10NO";
  else if (c.name === "Dark Brown") displayLabel = "100NO";
  else if (c.name === "Neon Blue") displayLabel = "1DC";
  
  ctx.fillText(displayLabel, p.x + p.w / 2, p.y + p.h / 2);


  if (character.hasSword) {
    const swordEmoji =  swordicon ;  //'ğŸ—¡ï¸';
    const centerX = character.x + character.w + 12; // sword center x
    const centerY = character.y + character.h / 2;  // sword center y
    ctx.save();              // save current canvas state
    ctx.translate(centerX, centerY);   // move origin to sword center
    ctx.rotate(Math.PI);     // rotate 180 degrees (Ï€ radians)
    ctx.font = '24px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(swordEmoji, 0, 0);    // draw at new origin
    
          // if slashing, move it slightly forward or up for effect
        if (character.slashing) {
          //ctx.fillText(swordEmoji, character.x + character.w + 24, character.y + character.h/2 - 6);
              ctx.fillText(swordEmoji, -6, 7); // adjust these numbers as needed

        }
        ctx.restore();           // restore canvas state

  }

  });

  ctx.lineWidth = 3;
  ctx.strokeStyle = house.border;
  ctx.setLineDash([6, 6]);
  ctx.strokeRect(house.x + 1, house.y + 1, house.w - 2, house.h - 2);
  ctx.setLineDash([]);
  ctx.fillStyle = 'rgba(255,255,255,0.75)';
  ctx.font = '13px sans-serif';
  ctx.textAlign = 'right';
  ctx.fillText('HOUSE', house.x + house.w - 8, house.y - 6);

  ctx.fillStyle = character.color;
  ctx.fillRect(character.x, character.y, character.w, character.h);
  ctx.strokeStyle = 'rgba(0,0,0,0.6)';
  ctx.strokeRect(character.x + 0.5, character.y + 0.5, character.w - 1, character.h - 1);
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 12px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(character.assignedValue ? shortLabel(character.assignedValue) : 'â€”', character.x + character.w / 2, character.y + character.h / 2);

renderPets(ctx); // â† ADD THIS LINE HERE
  // âš¡ Draw slash effects
slashes.forEach(s => {
  const alpha = 1 - s.life / s.maxLife;
  ctx.save();
  ctx.translate(s.x, s.y);
  ctx.rotate(s.angle);
  ctx.globalAlpha = alpha;
  ctx.strokeStyle = 'white';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(0, 0, 30, 0, Math.PI / 2);
  ctx.stroke();
  ctx.restore();
});
ctx.globalAlpha = 1;


  if (character.assignedName) {
    ctx.font = '11px sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.fillText(character.assignedName, character.x + character.w / 2, character.y - 10);
  }


if (boss.visible) {
  // draw boss
  //ctx.fillStyle = boss.color;
  ctx.fillStyle = boss.flash ? "#a00" : boss.color;
  ctx.fillRect(boss.x, boss.y, boss.w, boss.h);
  ctx.strokeStyle = 'rgba(0,0,0,0.6)';
  ctx.strokeRect(boss.x + 0.5, boss.y + 0.5, boss.w - 1, boss.h - 1);
  ctx.font = '24px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(boss.emoji, boss.x + boss.w / 2, boss.y + boss.h / 2);

  // draw HP bars
  const barWidth = 200;
  ctx.fillStyle = '#222';
  ctx.fillRect(W/2 - barWidth/2, 20, barWidth, 10);
  ctx.fillStyle = '#f33';
  ctx.fillRect(W/2 - barWidth/2, 20, barWidth * (boss.hitsRemaining / boss.hitsToDie), 10);

  ctx.fillStyle = '#fff';
  ctx.font = '12px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(`Boss HP: ${boss.hitsRemaining}/${boss.hitsToDie}`, W/2, 15);

  // player HP bar
  ctx.fillStyle = '#222';
  ctx.fillRect(W/2 - barWidth/2, H - 30, barWidth, 10);
  ctx.fillStyle = '#0f0';
  ctx.fillRect(W/2 - barWidth/2, H - 30, barWidth * ((3 - boss.playerHits)/3), 10);
  ctx.fillStyle = '#fff';
  ctx.fillText(`Player HP: ${3 - boss.playerHits}/3`, W/2, H - 35);
}

specials.forEach(s => {
  if (!s.visible) return;
  ctx.fillStyle = s.color;
  ctx.fillRect(s.x, s.y, CUBE_SIZE, CUBE_SIZE);
  ctx.strokeStyle = 'rgba(0,0,0,0.6)';
  ctx.strokeRect(s.x + 0.5, s.y + 0.5, CUBE_SIZE - 1, CUBE_SIZE - 1);
  ctx.fillStyle = '#fff';
  ctx.font = '20px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  // Use gift emoji if it's a gift spawn, otherwise use normal emoji
  const displayEmoji = s.isGiftSpawn ? s.emoji : s.emoji;
  ctx.fillText(displayEmoji, s.x + CUBE_SIZE / 2, s.y + CUBE_SIZE / 2);
});
  
  // ğŸ’° Draw Boss Loot Drops
bossDrops.forEach(drop => {
  ctx.save();
  ctx.globalAlpha = drop.opacity;
  ctx.font = '20px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';
  ctx.fillStyle = '#fff';
  drop.items.forEach((item, i) => {
    ctx.fillText(item, drop.x, drop.y - i * 22);
  });  
  ctx.restore();
  });
    drawSnowflakes(ctx); // NEW: Draw Christmas snowflakes
  drawWeatherAnimation(ctx);
  drawAdminAnimation(ctx);

  // Reset earthquake shake
  if (currentAdminEvent && currentAdminEvent.animation === "earthquake") {
    ctx.restore();
  }
};


let lastTime = performance.now();

function initializeGame() {
  // Build cubes, legend, and UI
  cubes = buildCubes();
  renderLegendUI();
  updateInventoryDisplay();
  updateDisplays();
  updateTierButtons();
  updateEnchantUI(); // NEW
  // Schedule boss spawn
  setTimeout(spawnBoss, 600000);

  // Initialize slash list & specials
  specials.forEach(s => setTimeout(() => spawnSpecial(s), randomSpawnInterval(s.respawn)));
}

// Call it once after defining everything
initializeGame();


// Update pet positions and trigger abilities
function updatePets(dt) {
  const radius = 60;
  const rotationSpeed = 1;
  
  // Calculate total cooldown reduction
  let cooldownReduction = 0;
  equippedPets.forEach(pet => {
    if (pet.ability === "cooldown_reducer") {
      cooldownReduction += pet.abilityValue;
    }
  });
  
  equippedPets.forEach((pet, index) => {
    pet.offsetAngle += rotationSpeed * dt;
    pet.x = character.x + character.w/2 + Math.cos(pet.offsetAngle) * radius - 16;
    pet.y = character.y + character.h/2 + Math.sin(pet.offsetAngle) * radius - 16;
    
    // ONLY create timer if it doesn't exist
    if (!petTimers[pet.id]) {
      petTimers[pet.id] = { 
        lastTrigger: Date.now(), 
        cooldown: getPetCooldown(pet.ability) 
      };
    }
    
    const timer = petTimers[pet.id];
    const now = Date.now();
    
    // Apply cooldown reduction
    const effectiveCooldown = timer.cooldown * (1 - cooldownReduction);
    
    if (now - timer.lastTrigger >= effectiveCooldown) {
      try {
        triggerPetAbility(pet);
        timer.lastTrigger = now;
      } catch (err) {
        console.error(`Error triggering pet ability for ${pet.name}:`, err);
      }
    }
  });
  
  // CLEANUP: Remove timers for pets that no longer exist
  const validPetIds = new Set(playerPets.map(p => p.id));
  for (let petId in petTimers) {
    if (!validPetIds.has(Number(petId))) {
      delete petTimers[petId];
    }
  }
}

// Trigger a pet's special ability
function triggerPetAbility(pet) {
  const roll = Math.random();
  
  switch(pet.ability) {
    case "purple_spawn":
      if (roll < 0.20) { // 20% chance
        console.log(`${pet.name} spawned a purple cube!`);
        
        // Spawn a temporary purple cube
        const purpleCube = {
          x: Math.random() * (W - CUBE_SIZE),
          y: Math.random() * (H - CUBE_SIZE),
          w: CUBE_SIZE,
          h: CUBE_SIZE,
          color: "#8b3bff",
          value: money * 20n / 100n, // 20% of current money
          visible: true,
          isPurpleSpawn: true,
          emoji: "ğŸŸª"
        };
        
        specials.push(purpleCube);
        
        // Remove after 3 seconds
        setTimeout(() => {
          const index = specials.indexOf(purpleCube);
          if (index > -1) specials.splice(index, 1);
        }, 3000);
      }
      break;
      
    case "cube_grabber":
      const randomCube = cubes[Math.floor(Math.random() * cubes.length)];
      legendCounts[randomCube.name] = (legendCounts[randomCube.name] || 0n) + 1n;
      houseValue += randomCube.value;
      console.log(`${pet.name} grabbed a ${randomCube.name}!`);
      recomputeIncome();
      updateDisplays();
      break;
      
    case "day_trigger":
      if (roll < pet.abilityValue) {
        changeDayNightCycle("day", true);
        console.log(`${pet.name} triggered day time!`);
      }
      break;
      
    case "ember_mutator":
      if (roll < pet.abilityValue) {
        const randomPet = playerPets[Math.floor(Math.random() * playerPets.length)];
        if (randomPet && !randomPet.mutation) {
          randomPet.mutation = "Ember";
          console.log(`${pet.name} mutated ${randomPet.name} with Ember!`);
          updateInventoryDisplay();
        }
      }
      break;
      
    case "shooting_star":
      if (roll < pet.abilityValue) {
        const bonus = money * 40n / 100n;
        money += bonus;
        console.log(`${pet.name} spawned a shooting star! +${formatBigInt(bonus)}`);
        updateDisplays();
      }
      break;
      
    case "boss_spawn":
      if (roll < pet.abilityValue) {
        spawnBoss();
        console.log(`${pet.name} spawned the boss!`);
      }
      break;
      
    case "glitch_mutator":
      if (roll < pet.abilityValue) {
        const randomPet = playerPets[Math.floor(Math.random() * playerPets.length)];
        if (randomPet && !randomPet.mutation) {
          randomPet.mutation = "Glitched";
          console.log(`${pet.name} mutated ${randomPet.name} with Glitched!`);
          updateInventoryDisplay();
        }
      }
      break;
      
    case "ability_copy":
      const nearbyPet = equippedPets.find(p => p.id !== pet.id);
      if (nearbyPet) {
        console.log(`${pet.name} copied ${nearbyPet.name}'s ability!`);
        triggerPetAbility(nearbyPet);
      }
      break;
      
    case "egg_giver":
      if (roll < pet.abilityValue) {
        const eggTypes = ["Basic Egg", "Rare Egg", "Dragon Egg", "Mythic Egg", "Celestial Egg"];
        const randomEgg = eggTypes[Math.floor(Math.random() * eggTypes.length)];
        console.log(`${pet.name} gave you a ${randomEgg}!`);
        
        const existing = playerInventory.Eggs.find(i => i.name === randomEgg);
        if (existing) existing.count++;
        else playerInventory.Eggs.push({ icon: "ğŸ¥š", name: randomEgg, count: 1 });
        
        updateInventoryDisplay();
      }
      break;
      
    case "money_doubler":
      if (roll < pet.abilityValue) {
        money = money * 2n;
        console.log(`${pet.name} doubled your money!`);
        updateDisplays();
      }
      break;
      
    case "entity_spawner":
      const randomSpecial = specials[Math.floor(Math.random() * specials.length)];
      spawnSpecial(randomSpecial);
      console.log(`${pet.name} spawned ${randomSpecial.name}!`);
      break;
      
    case "glitch_event":
      if (roll < pet.abilityValue) {
        const glitchEvent = adminAbuseEvents.find(e => e.name === "Glitched");
        if (glitchEvent) triggerAdminEvent(glitchEvent);
        console.log(`${pet.name} started Glitch event!`);
      }
      break;
      
    case "weather_trigger":
      if (roll < pet.abilityValue) {
        triggerWeatherEvent();
        console.log(`${pet.name} triggered weather!`);
      }
      break;
      
    case "bone_giver":
      dropCounters["ğŸ¦´ Skeleton Bones"]++;
      inventory["ğŸ¦´ Skeleton Bones"]++;
      console.log(`${pet.name} gave you a skeleton bone!`);
      updateInventoryDisplay();
      break;
      
    case "blackhole_event":
      if (roll < pet.abilityValue) {
        const blackholeEvent = adminAbuseEvents.find(e => e.name === "Blackhole");
        if (blackholeEvent) triggerAdminEvent(blackholeEvent);
        console.log(`${pet.name} started Blackhole event!`);
      }
      break;
      
    case "cycle_changer":
      if (roll < pet.abilityValue) {
        // Change to next cycle
        const cycles = ["day", "sunset", "night", "sunrise"];
        const currentIndex = cycles.indexOf(dayNightCycle.current);
        const nextCycle = cycles[(currentIndex + 1) % cycles.length];
        changeDayNightCycle(nextCycle, true);
        console.log(`${pet.name} changed to ${nextCycle}!`);
      }
      break;
      
    case "timer_reducer":
      // Reduce all pet cooldowns by 5 minutes
      for (let petId in petTimers) {
        petTimers[petId].lastTrigger -= 5 * 60 * 1000;
      }
      console.log(`${pet.name} reduced all timers by 5 minutes!`);
      break;
      
    case "rain_event":
      const rainEvent = weatherEvents.find(e => e.name === "Rain");
      if (rainEvent && !currentWeather) {
        currentWeather = rainEvent.name;
        weatherMultiplier = rainEvent.incomeBoost;
        console.log(`${pet.name} started Rain!`);
        setTimeout(endWeatherEvent, rainEvent.duration);
      }
      break;
      
    case "earthquake_event":
      if (roll < pet.abilityValue) {
        const earthquakeEvent = adminAbuseEvents.find(e => e.name === "Earthquake");
        if (earthquakeEvent) triggerAdminEvent(earthquakeEvent);
        console.log(`${pet.name} started Earthquake!`);
      }
      break;
      
    case "random_event":
      const randomWeatherEvent = weatherEvents[Math.floor(Math.random() * weatherEvents.length)];
      if (!currentWeather) {
        currentWeather = randomWeatherEvent.name;
        weatherMultiplier = randomWeatherEvent.incomeBoost;
        console.log(`${pet.name} started ${randomWeatherEvent.name}!`);
        setTimeout(endWeatherEvent, randomWeatherEvent.duration);
      }
      break;
      
    case "galactic_event":
      const galacticEvent = adminAbuseEvents.find(e => e.name === "Galactic");
      if (galacticEvent) triggerAdminEvent(galacticEvent);
      console.log(`${pet.name} started Galactic event!`);
      break;
      
    case "day_income_boost":
      // Passive - handled in recomputeIncome
      break;
      
    case "day_speed_boost":
      // Passive - handled in recomputeIncome
      break;
      
    case "ember_giver":
      if (roll < pet.abilityValue) {
        const targetPet = equippedPets[Math.floor(Math.random() * equippedPets.length)];
        if (targetPet && !targetPet.mutation) {
          targetPet.mutation = "Ember";
          console.log(`${pet.name} gave ${targetPet.name} Ember mutation!`);
          updateInventoryDisplay();
        }
      }
      break;
      
    case "night_income_boost":
      // Passive - handled in recomputeIncome
      break;
      
    case "night_speed_boost":
      // Passive - handled in recomputeIncome
      break;
      
    case "cooldown_reducer":
      // Passive - handled in updatePets
      break;
      
    case "mutation_giver":
      if (roll < pet.abilityValue) {
        const mutationTypes = Object.keys(petMutations);
        equippedPets.forEach(p => {
          if (!p.mutation && Math.random() < 0.5) {
            const randomMutation = mutationTypes[Math.floor(Math.random() * mutationTypes.length)];
            p.mutation = randomMutation;
            console.log(`${pet.name} gave ${p.name} ${randomMutation} mutation!`);
          }
        });
        updateInventoryDisplay();
      }
      break;
      
    case "gift_multiplier":
      // Passive - handled in recomputeIncome
      break;
      
case "double_income_temp":
  if (roll < pet.abilityValue) {
    console.log(`${pet.name} activated 2x income burst for 20 seconds!`);
    
    const originalIncome = incomePerSec;
    incomePerSec = incomePerSec * 2n;
    updateDisplays();
    
    // Remove any existing indicator first
    const existingIndicator = document.querySelector('.income-boost-indicator');
    if (existingIndicator) existingIndicator.remove();
    
    const indicator = document.createElement('div');
    indicator.className = 'income-boost-indicator'; // Add class for easy cleanup
    indicator.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 0, 0, 0.9);
      color: white;
      padding: 20px 40px;
      border-radius: 15px;
      font-size: 24px;
      font-weight: bold;
      z-index: 10001;
      box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
    `;
    indicator.textContent = 'ğŸ¬ 2X INCOME! ğŸ¬';
    document.body.appendChild(indicator);
    
    setTimeout(() => {
      recomputeIncome();
      if (indicator.parentNode) indicator.remove(); // Check before removing
      console.log(`${pet.name}'s income burst ended`);
    }, 20000);
  }
  break;
      
    case "random_cube_spawn":
      if (roll < pet.abilityValue) {
        const currentTierCubes = currentCubes();
        const randomCube = currentTierCubes[Math.floor(Math.random() * currentTierCubes.length)];
        
        console.log(`${pet.name} spawned a ${randomCube.name} cube!`);
        
        const giftCube = {
          x: Math.random() * (W - CUBE_SIZE),
          y: Math.random() * (H - CUBE_SIZE),
          w: CUBE_SIZE,
          h: CUBE_SIZE,
          color: randomCube.color,
          value: randomCube.value,
          visible: true,
          isGiftSpawn: true,
          emoji: "ğŸ"
        };
        
        specials.push(giftCube);
        
        setTimeout(() => {
          const index = specials.indexOf(giftCube);
          if (index > -1) {
            specials.splice(index, 1);
            money += randomCube.value;
            console.log(`Auto-collected ${randomCube.name} cube`);
            updateDisplays();
          }
        }, 5000);
      }
      break;
      
    case "heal_boss_damage":
      if (roll < pet.abilityValue) {
        console.log(`${pet.name} prepared healing shield!`);
        
        window.healingShieldActive = true;
        
        const shield = document.createElement('div');
        shield.id = 'healingShield';
        shield.style.cssText = `
          position: fixed;
          top: 10px;
          left: 50%;
          transform: translateX(-50%);
          background: rgba(144, 238, 144, 0.9);
          color: white;
          padding: 10px 20px;
          border-radius: 10px;
          font-size: 16px;
          font-weight: bold;
          z-index: 10001;
          box-shadow: 0 0 15px rgba(144, 238, 144, 0.7);
        `;
        shield.textContent = 'â˜˜ï¸ HEALING SHIELD ACTIVE â˜˜ï¸';
        document.body.appendChild(shield);
      }
      break;
      
    case "lucky_star":
      if (roll < pet.abilityValue) {
        console.log(`${pet.name} activated Lucky Star! 2x drop rates for 30s!`);
        
        window.luckyStarActive = true;
        window.luckyStarMultiplier = pet.abilityValue;
        
        const star = document.createElement('div');
        star.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: rgba(255, 250, 205, 0.95);
          color: #FF8C00;
          padding: 30px 50px;
          border-radius: 20px;
          font-size: 28px;
          font-weight: bold;
          z-index: 10001;
          box-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
          animation: pulse 1s infinite;
        `;
        star.innerHTML = 'â­ LUCKY STAR! â­<br><span style="font-size:18px;">2X DROP RATES!</span>';
        document.body.appendChild(star);
        
        const style = document.createElement('style');
        style.textContent = `
          @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
          }
        `;
        document.head.appendChild(style);
        
        setTimeout(() => {
          window.luckyStarActive = false;
          window.luckyStarMultiplier = 1.0;
          star.remove();
          style.remove();
          console.log(`${pet.name}'s Lucky Star ended`);
        }, 30000);
      }
      break;
      
    case "galactic_income":
      // Passive - handled in recomputeIncome
      break;
      
    case "meteor_shower":
      if (roll < pet.abilityValue) {
        console.log(`${pet.name} summoned meteor shower!`);
        for (let i = 0; i < 5; i++) {
          setTimeout(() => {
            const bonus = money * 10n / 100n;
            money += bonus;
            console.log(`ğŸ’« Meteor hit! +${formatBigInt(bonus)}`);
            updateDisplays();
          }, i * 1000);
        }
      }
      break;
      
    case "warp_speed":
      // Passive - handled in recomputeIncome
      break;
      
    case "explosive_income":
      if (roll < pet.abilityValue) {
        console.log(`${pet.name} explosive income burst!`);
        const originalIncome = incomePerSec;
        incomePerSec = incomePerSec * 3n;
        updateDisplays();

        setTimeout(() => {
          recomputeIncome();
          console.log(`${pet.name}'s burst ended`);
        }, 15000);
      }
      break;
      
    case "gravity_well":
      if (roll < pet.abilityValue) {
        console.log(`${pet.name} pulled all cubes!`);
        cubes.forEach(c => {
          legendCounts[c.name] = (legendCounts[c.name] || 0n) + 1n;
          houseValue += c.value;
        });
        recomputeIncome();
        updateDisplays();
      }
      break;
      
    case "glitch_income":
      // Passive - handled in recomputeIncome
      break;
      
    case "duplicate_cube":
      if (roll < pet.abilityValue) {
        const nonZeroCubes = Object.keys(legendCounts).filter(k => legendCounts[k] > 0n);
        if (nonZeroCubes.length > 0) {
          const randomCubeName = nonZeroCubes[Math.floor(Math.random() * nonZeroCubes.length)];
          legendCounts[randomCubeName] = legendCounts[randomCubeName] + 1n;
          console.log(`${pet.name} duplicated a ${randomCubeName}!`);
          recomputeIncome();
          updateDisplays();
        }
      }
      break;
      
    case "corrupt_spawn":
      if (roll < pet.abilityValue) {
        console.log(`${pet.name} spawned corrupted entities!`);
        specials.forEach(s => {
          if (!s.visible && Math.random() < 0.3) {
            spawnSpecial(s);
          }
        });
      }
      break;
      
    case "unlock_tier":
      if (roll < pet.abilityValue && cubeTier < 3) {
        console.log(`${pet.name} unlocked next tier for 3 minutes!`);
        const originalTier = cubeTier;
        cubeTier++;
        cubes = buildCubes();
        renderLegendUI();
        updateDisplays();
        updateTierButtons();
        
        setTimeout(() => {
          cubeTier = originalTier;
          cubes = buildCubes();
          renderLegendUI();
          updateDisplays();
          updateTierButtons();
          console.log(`Tier reverted back to ${cubeTier + 1}`);
        }, 180000);
      }
      break;
      
    case "code_rain":
      if (roll < pet.abilityValue) {
        console.log(`${pet.name} activated code rain!`);
        const originalIncome = incomePerSec;
        incomePerSec = incomePerSec * 5n;
        updateDisplays();
        
        setTimeout(() => {
          recomputeIncome();
          console.log(`${pet.name}'s code rain ended`);
        }, 10000);
      }
      break;
      
    case "disco_income":
      // Passive - handled in recomputeIncome
      break;
      
    case "rhythm_boost":
      // Passive - handled in recomputeIncome
      break;
      
    case "party_mode":
      if (roll < pet.abilityValue) {
        console.log(`${pet.name} activated party mode!`);
        
        // Temporarily double all multipliers
        const originalWeather = weatherMultiplier;
        const originalRelic = equippedRelicSpecial;
        const originalRebirth = rebirthMultiplier;
        
        weatherMultiplier *= 2;
        equippedRelicSpecial *= 2;
        rebirthMultiplier *= 2;
        
        recomputeIncome();
        
        setTimeout(() => {
          weatherMultiplier = originalWeather;
          equippedRelicSpecial = originalRelic;
          rebirthMultiplier = originalRebirth;
          recomputeIncome();
          console.log(`${pet.name}'s party mode ended`);
        }, 20000);
      }
      break;
      
    case "disco_ball":
      if (roll < pet.abilityValue) {
        console.log(`${pet.name} spawned disco cubes!`);
        
        for (let i = 0; i < 3; i++) {
          const discoCube = {
            x: Math.random() * (W - CUBE_SIZE),
            y: Math.random() * (H - CUBE_SIZE),
            w: CUBE_SIZE,
            h: CUBE_SIZE,
            color: `hsl(${Math.random() * 360}, 100%, 50%)`,
            value: money * 15n / 100n,
            visible: true,
            emoji: "ğŸª©"
          };
          
          specials.push(discoCube);
          
          setTimeout(() => {
            const index = specials.indexOf(discoCube);
            if (index > -1) specials.splice(index, 1);
          }, 5000);
        }
      }
      break;
      
    case "strobe_effect":
      // Random positive effect every 30s
      const effects = [
        () => { money += money * 10n / 100n; console.log("Strobe: +10% money"); },
        () => { 
          incomePerSec = incomePerSec * 2n; 
          setTimeout(() => recomputeIncome(), 10000);
          console.log("Strobe: 2x income for 10s"); 
        },
        () => { spawnBoss(); console.log("Strobe: Spawned boss"); }
      ];
      
      const randomEffect = effects[Math.floor(Math.random() * effects.length)];
      randomEffect();
      break;
      
    case "bloodmoon_income":
      // Passive - handled in recomputeIncome
      break;
      
    case "shadow_strike":
      // Passive - damage boost handled in combat
      break;
      
    case "blood_ritual":
      if (roll < pet.abilityValue) {
        const sacrifice = money * 10n / 100n;
        money -= sacrifice;
        const gain = sacrifice * 15n / 10n;
        money += gain;
        console.log(`${pet.name} performed blood ritual! Sacrificed ${formatBigInt(sacrifice)}, gained ${formatBigInt(gain)}`);
        updateDisplays();
      }
      break;
      
    case "life_steal":
      // Passive - heals on boss hit
      break;
      
    case "blood_pact":
      // Passive - 2x drops during bloodmoon
      break;
      
    case "divine_income":
      // Passive - handled in recomputeIncome
      break;
      
    case "celestial_speed":
      // Passive - handled in recomputeIncome
      break;
      
    case "angel_blessing":
      if (roll < pet.abilityValue) {
        console.log(`${pet.name} activated Angel's Blessing! 10x income for 30s!`);
        
        const originalIncome = incomePerSec;
        incomePerSec = incomePerSec * 10n;
        updateDisplays();
        
        const blessing = document.createElement('div');
        blessing.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: rgba(255, 215, 0, 0.95);
          color: white;
          padding: 30px 50px;
          border-radius: 20px;
          font-size: 28px;
          font-weight: bold;
          z-index: 10001;
          box-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
        `;
        blessing.textContent = 'ğŸ‘¼ ANGEL\'S BLESSING! 10X INCOME! ğŸ‘¼';
        document.body.appendChild(blessing);
        
        setTimeout(() => {
          recomputeIncome();
          blessing.remove();
          console.log(`${pet.name}'s blessing ended`);
        }, 30000);
      }
      break;
      
    case "seraph_protection":
      // Passive - tracked globally
      if (!window.seraphShield) {
        window.seraphShield = 5;
      }
      break;
      
    case "archangel_power":
      // Passive - handled in combat calculations
      break;
      
    case "heavenly_king":
      // Passive - 3x all multipliers handled in recomputeIncome
      break;
      
    case "enchant_booster":
      if (roll < pet.abilityValue) {
        console.log(`${pet.name} gave free enchant!`);
        
        const randomPet = equippedPets[Math.floor(Math.random() * equippedPets.length)];
        if (randomPet && randomPet.id !== pet.id) {
          const freeEnchant = rollEnchantment();
          randomPet.enchantment = freeEnchant;
          
          enchantmentSystem.totalEnchants++;
          checkEnchantMilestones();
          
          const icon = enchantmentTypes[freeEnchant.type].icon;
          console.log(`ğŸ Free enchant: ${randomPet.name} got ${icon} ${freeEnchant.type} ${freeEnchant.tier}!`);
          
          updateInventoryDisplay();
        }
      }
      break;
      
    case "enchant_saver":
      // Passive - 50% refund handled in enchantPet function
      break;
      
    case "tier_upgrader":
      // Passive - checked in enchantPet function
      break;
      
    case "double_enchant":
      if (roll < pet.abilityValue) {
        console.log(`${pet.name} triggered double enchants for 30s!`);
        
        window.doubleEnchantActive = true;
        
        const indicator = document.createElement('div');
        indicator.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: rgba(147, 112, 219, 0.95);
          color: white;
          padding: 30px 50px;
          border-radius: 20px;
          font-size: 28px;
          font-weight: bold;
          z-index: 10001;
          box-shadow: 0 0 30px rgba(147, 112, 219, 0.8);
        `;
        indicator.textContent = 'ğŸ”® DOUBLE ENCHANTS! ğŸ”®';
        document.body.appendChild(indicator);
        
        setTimeout(() => {
          window.doubleEnchantActive = false;
          indicator.remove();
          console.log(`${pet.name}'s double enchant ended`);
        }, 30000);
      }
      break;
      
    case "enchant_keeper":
      // Passive - keeps enchantments on rebirth (handled in performRebirth)
      break;
      
    case "ultimate_enchanter":
      // Passive - 5% chance for Ultimate tier (handled in rollEnchantment)
      break;
      
    default:
      // Passive abilities or speed boost (handled elsewhere)
      break;
  }
}
/**
 * The main game loop. Called repeatedly by requestAnimationFrame.
 * Updates the game state (e.g. character movement, animations) and renders the game.
 * @param {number} t - The current time in milliseconds.
 */
function loop(t) {
  try {
    const dt = (t - lastTime) / 1000;
    lastTime = t;
    
    // Prevent huge dt values that can cause issues
    const safeDt = Math.min(dt, 0.1); // Cap at 100ms
    
    update(safeDt);
    updateWeatherAnimation(safeDt);
    updateAdminAnimation(safeDt);
    updateDayNightAnimation(safeDt);
    updateSnowflakes(safeDt);
    render();
    drawWeatherAnimation(ctx);
    drawAdminAnimation(ctx);
    drawSnowflakes(ctx);
  } catch (err) {
    console.error('Loop error:', err);
    // Don't crash, just log the error
  }
  
  requestAnimationFrame(loop);
}

function init() {
  cubes = buildCubes();
  renderLegendUI();
  recomputeIncome();
  updateDisplays();
    generateStars(); // â† ADD THIS LINE
      generateClouds(); // â† ADD THIS LINE

  requestAnimationFrame(loop);
}
// ========================================
// ADMIN PANEL FUNCTIONS
// ========================================

function toggleAdminPanel() {
  const panel = document.getElementById('adminPanel');
  panel.classList.toggle('active');
  updateAdminPanelStats();
}

function updateAdminPanelStats() {
  const adventDay = document.getElementById('adminAdventDay');
  const rebirthCount = document.getElementById('adminRebirthCount');
  const enchantCount = document.getElementById('adminEnchantCount'); // NEW
  
  if (adventDay) adventDay.textContent = adventCalendar.currentDay;
  if (rebirthCount) rebirthCount.textContent = window.rebirthCount || 0;
  if (enchantCount) enchantCount.textContent = enchantmentSystem.totalEnchants; // NEW
}

// Money Controls
function adminAddMoney(amount) {
  money += amount;
  updateDisplays();
  console.log(`ğŸ’° Added ${formatBigInt(amount)} money`);
}

function adminSetMoney(amount) {
  money = amount;
  updateDisplays();
  console.log(`ğŸ’° Set money to ${formatBigInt(amount)}`);
}

// Event Controls
function adminTriggerEvent(eventName) {
  const event = adminAbuseEvents.find(e => e.name === eventName);
  if (event) {
    triggerAdminEvent(event);
    console.log(`ğŸ® Triggered ${eventName} event`);
  }
}

// Boss Controls
function adminKillBoss() {
  if (boss.visible) {
    boss.hitsRemaining = 0;
    boss.visible = false;
    console.log('â˜ ï¸ Boss defeated');
  } else {
    console.log('âš ï¸ No boss active');
  }
}
// Enchantment Admin Functions
function adminUnlockEnchanting() {
  enchantmentSystem.unlocked = true;
  updateEnchantUI();
  console.log('ğŸ”® Enchanting unlocked');
}

function adminAddEnchants(amount) {
  enchantmentSystem.totalEnchants += amount;
  checkEnchantMilestones();
  updateEnchantUI();
  updateAdminPanelStats();
  console.log(`ğŸ”® Added ${amount} enchants`);
}

function adminGiveEnchantEgg() {
  const existing = playerInventory.Eggs.find(i => i.name === "Enchant Egg");
  if (existing) {
    existing.count++;
  } else {
    playerInventory.Eggs.push({
      icon: "ğŸ”®",
      name: "Enchant Egg",
      count: 1,
      special: 1
    });
  }
  updateInventoryDisplay();
  console.log('ğŸ”® Gave Enchant Egg');
}

function adminGiveEnchantRelic() {
  const existing = playerInventory.Relics.find(i => i.name === "Enchant Relic");
  if (existing) {
    existing.count++;
  } else {
    playerInventory.Relics.push({
      icon: "ğŸ€",
      name: "Enchant Relic",
      count: 1,
      special: 1.0
    });
  }
  updateInventoryDisplay();
  console.log('ğŸ€ Gave Enchant Relic');
}

function adminClearEnchants() {
  if (confirm('âš ï¸ Clear all pet enchantments?')) {
    playerPets.forEach(pet => {
      if (pet.enchantment) {
        delete pet.enchantment;
      }
    });
    updateInventoryDisplay();
    recomputeIncome();
    console.log('ğŸ—‘ï¸ Cleared all enchantments');
  }
}

// === CRAFTING MATERIAL ADMIN FUNCTIONS ===

function adminGiveMaterial(materialName, amount) {
  if (!craftingSystem.unlocked) {
    alert('âš ï¸ Crafting must be unlocked first! (Rebirth 1)\n\nUse "ğŸ”“ Unlock Crafting System" button.');
    return;
  }
  
  // Initialize materials object if it doesn't exist
  if (!craftingSystem.materials) {
    craftingSystem.materials = {};
  }
  
  // Add to materials - THIS WAS THE BUG
  if (!craftingSystem.materials[materialName]) {
    craftingSystem.materials[materialName] = 0;
  }
  
  craftingSystem.materials[materialName] += amount;
  const newCount = craftingSystem.materials[materialName];
  
  console.log(`âœ… Admin: Gave ${amount}x ${materialName}`);
  console.log(`   New count: ${newCount}`);
  console.log(`   All materials:`, craftingSystem.materials);
  
  // Update crafting display if open
  updateCraftingDisplay();
  
  // Show notification
  const notification = document.createElement('div');
  notification.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(34, 139, 34, 0.95);
    color: white;
    padding: 15px 25px;
    border-radius: 10px;
    font-size: 16px;
    font-weight: bold;
    z-index: 10002;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    animation: slideIn 0.3s ease-out;
  `;
  notification.innerHTML = `âœ… +${amount} ${materialName}<br><small>Total: ${newCount}</small>`;
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.style.animation = 'slideOut 0.3s ease-in';
    setTimeout(() => notification.remove(), 300);
  }, 2000);
}
function adminTestMaterials() {
  if (!craftingSystem.unlocked) {
    alert('âš ï¸ Unlock crafting first!');
    return;
  }
  
  // Give test materials
  craftingSystem.materials["Stick"] = 50;
  craftingSystem.materials["Stone"] = 50;
  craftingSystem.materials["Phoenix Feather"] = 10;
  craftingSystem.materials["Leviathan Scale"] = 10;
  
  console.log('ğŸ§ª Test materials added:');
  console.log(craftingSystem.materials);
  
  updateCraftingDisplay();
  
  alert('ğŸ§ª Test materials added!\n\nCheck the Materials tab in Crafting menu.');
}

window.adminTestMaterials = adminTestMaterials;
function adminMaxAllMaterials() {
  if (!confirm('âš ï¸ Give 999 of EVERY crafting material?')) {
    return;
  }
  
  if (!craftingSystem.unlocked) {
    alert('âš ï¸ Crafting must be unlocked first! (Rebirth 1)');
    return;
  }
  
  // All materials from merchantShop
  for (let materialName in merchantShop) {
    craftingSystem.materials[materialName] = 999;
  }
  
  // All craftable materials from recipes
  for (let recipeName in craftingSystem.recipes) {
    const recipe = craftingSystem.recipes[recipeName];
    if (recipe.type === "Materials" || recipe.type === "Miscellaneous" || recipe.type === "Totems") {
      craftingSystem.materials[recipeName] = 999;
    }
  }
  
  // Boss drops
  const bossDrops = [
    "Phoenix Feather", "Phoenix Ember",
    "Leviathan Scale", "Leviathan Heart", "Leviathan Fang",
    "Enchanted Leviathan Scale", "Enchanted Leviathan Heart", "Enchanted Leviathan Fang"
  ];
  
  bossDrops.forEach(drop => {
    craftingSystem.materials[drop] = 999;
  });
  
  console.log('ğŸ”¥ Maxed all crafting materials to 999');
  updateCraftingDisplay();
  
  alert('âœ… All crafting materials set to 999!');
}

// === CRAFTING MATERIAL ADMIN FUNCTIONS ===

function adminUnlockCrafting() {
  if (craftingSystem.unlocked) {
    alert('âœ… Crafting is already unlocked!');
    return;
  }
  
  craftingSystem.unlocked = true;
  
  // Auto-unlock all auto-unlock recipes
  for (let recipeName in craftingSystem.recipes) {
    const recipe = craftingSystem.recipes[recipeName];
    if (recipe.autoUnlock && !craftingSystem.unlockedRecipes.includes(recipeName)) {
      craftingSystem.unlockedRecipes.push(recipeName);
    }
  }
  
  console.log('ğŸ”“ Crafting system unlocked via admin');
  console.log(`ğŸ“œ Auto-unlocked ${craftingSystem.unlockedRecipes.length} recipes`);
  
  alert('âœ… Crafting System Unlocked!\n\nğŸ“œ All basic recipes have been unlocked.\n\nYou can now access the ğŸ”¨ Crafting button!');
}

function adminUnlockAllRecipes() {
  if (!craftingSystem.unlocked) {
    alert('âš ï¸ Crafting must be unlocked first!\n\nClick "ğŸ”“ Unlock Crafting System" first.');
    return;
  }
  
  let unlockedCount = 0;
  
  for (let recipeName in craftingSystem.recipes) {
    if (!craftingSystem.unlockedRecipes.includes(recipeName)) {
      craftingSystem.unlockedRecipes.push(recipeName);
      unlockedCount++;
    }
  }
  
  console.log(`ğŸ“œ Unlocked ${unlockedCount} recipes`);
  updateCraftingDisplay();
  
  alert(`âœ… Unlocked ${unlockedCount} recipes!\n\nTotal recipes: ${craftingSystem.unlockedRecipes.length}\n\nAll recipes are now available in the Crafting menu!`);
}
// Make functions globally accessible
window.adminUnlockCrafting = adminUnlockCrafting;
window.adminUnlockAllRecipes = adminUnlockAllRecipes;
window.adminGiveMaterial = adminGiveMaterial;
window.adminMaxAllMaterials = adminMaxAllMaterials;
window.adminClearAllMaterials = adminClearAllMaterials;
function adminClearAllMaterials() {
  if (!confirm('âš ï¸ Clear ALL crafting materials? This cannot be undone!')) {
    return;
  }
  
  craftingSystem.materials = {};
  console.log('ğŸ—‘ï¸ Cleared all crafting materials');
  updateCraftingDisplay();
  
  alert('âœ… All crafting materials cleared!');
}

// Make functions globally accessible
window.adminGiveMaterial = adminGiveMaterial;
window.adminMaxAllMaterials = adminMaxAllMaterials;
window.adminClearAllMaterials = adminClearAllMaterials;
// ğŸ—¡ï¸ Sword vs Boss collision check
if (boss.visible && character.slashing && !boss.retreating) {
  // ... existing boss code stays here ...
}

// ğŸ”¥ PHOENIX BOSS LOGIC
if (phoenixBoss.visible && !phoenixBoss.retreating) {
  const dx = character.x - phoenixBoss.x;
  const dy = character.y - phoenixBoss.y;
  const distance = Math.hypot(dx, dy);
  
  // Phoenix follows player slowly
  if (distance > 100) {
    phoenixBoss.x += (dx / distance) * phoenixBoss.speed * dt * 0.3;
    phoenixBoss.y += (dy / distance) * phoenixBoss.speed * dt * 0.3;
  }
  
  // Long range attack
  if (distance < phoenixBoss.longRangeRadius && !phoenixBoss.attackCooldown) {
    phoenixBoss.attackCooldown = true;
    
    // Phoenix IGNORES mistletoe shield
    phoenixBoss.playerHits++;
    
    console.log("ğŸ”¥ Phoenix hit you with long-range attack!");
    
    if (phoenixBoss.playerHits >= 3) {
      money = money / 2n;
      phoenixBoss.visible = false;
      phoenixBoss.playerHits = 0;
      alert("ğŸ”¥ Phoenix defeated you! Lost 50% money!");
    }
    
    setTimeout(() => (phoenixBoss.attackCooldown = false), 3000);
  }
}

// ğŸ—¡ï¸ Sword vs Phoenix Boss
// ğŸ—¡ï¸ Sword vs Phoenix Boss
if (phoenixBoss.visible && character.slashing && !phoenixBoss.retreating) {
  const swordRange = 40;
  let swordBox = { x: character.x, y: character.y, w: character.w, h: character.h };
  
  if (keys.w) swordBox.y -= swordRange;
  else if (keys.s) swordBox.y += swordRange;
  else if (keys.a) swordBox.x -= swordRange;
  else swordBox.x += swordRange;
  
  swordBox.w += swordRange / 2;
  swordBox.h += swordRange / 2;
  
  if (rectsOverlap(swordBox, phoenixBoss) && !phoenixBoss.hitCooldown) {
    let petDamageMultiplier = 1;
    equippedPets.forEach(pet => {
      if (pet.ability === "double_damage") {
        petDamageMultiplier *= pet.abilityValue;
      }
    });
    
    const enchantDmgBoost = window.enchantDamageBoost || 1;
    const bloodmoonBoost = window.bloodmoonDamageBoost || 1;
    const archangelBoost = window.archangelDamageBoost || 1;
    const heavenlyKingBoost = window.heavenlyKingDamageBoost || 1;
    
    const totalDmgBoost = enchantDmgBoost * bloodmoonBoost * archangelBoost * heavenlyKingBoost;
    const dmg = Math.max(1, Math.floor(equippedSwordSpecial * petDamageMultiplier * totalDmgBoost));
    
    phoenixBoss.hitsRemaining -= dmg;
    
    console.log(`ğŸ”¥ Hit Phoenix for ${dmg} damage! HP: ${phoenixBoss.hitsRemaining}/${phoenixBoss.hitsToDie}`);
    
    phoenixBoss.flash = true;
    spawnSlash(phoenixBoss.x + phoenixBoss.w / 2, phoenixBoss.y + phoenixBoss.h / 2, Math.random() * Math.PI * 2);
    
    phoenixBoss.retreating = true;
    
    setTimeout(() => {
      phoenixBoss.flash = false;
      phoenixBoss.retreating = false;
    }, 500);
    
    phoenixBoss.hitCooldown = true;
    setTimeout(() => (phoenixBoss.hitCooldown = false), 300);
    
    // Check if phoenix is defeated
    if (phoenixBoss.hitsRemaining <= 0) {
      phoenixBoss.visible = false;
      phoenixBoss.hitsRemaining = phoenixBoss.hitsToDie;
      phoenixBoss.playerHits = 0;
      
      console.log("ğŸ”¥ Phoenix Boss defeated!");
      
      // Apply lucky star and blood pact multipliers
      const dropMultiplier = (window.luckyStarActive ? window.luckyStarMultiplier : 1.0) * 
                            (window.bloodPactActive ? window.bloodPactMultiplier : 1.0);
      
      const dropNames = [];
      
      // 100% Phoenix Feather
      const featherAmount = Math.floor(1 * dropMultiplier);
      craftingSystem.materials["Phoenix Feather"] = (craftingSystem.materials["Phoenix Feather"] || 0) + featherAmount;
      dropNames.push(`ğŸª¶ Phoenix Feather x${featherAmount}`);
      
      // 10% Phoenix Ember
      if (Math.random() <= 0.10 * dropMultiplier) {
        craftingSystem.materials["Phoenix Ember"] = (craftingSystem.materials["Phoenix Ember"] || 0) + 1;
        dropNames.push("ğŸ”¥ Phoenix Ember");
      }
      
      // Show drops on screen
      bossDrops.push({
        x: phoenixBoss.x + phoenixBoss.w / 2,
        y: phoenixBoss.y,
        items: dropNames,
        timer: 5000,
        opacity: 1
      });
      
      updateCraftingDisplay();
      alert(`ğŸ”¥ Phoenix defeated!\n\nDrops:\n${dropNames.join('\n')}`);
    }
  }
}

// ğŸŒªï¸ TORNADO LOGIC
if (tornado.visible) {
  const dx = character.x - tornado.x;
  const dy = character.y - tornado.y;
  const distance = Math.hypot(dx, dy);
  
  if (distance > 5) {
    tornado.x += (dx / distance) * tornado.speed * dt;
    tornado.y += (dy / distance) * tornado.speed * dt;
  }
  
  tornado.angle += dt * 10;
  
  // Check collision with player
  if (rectsOverlap(tornado, character)) {
    tornado.visible = false;
    endAdminEvent();
    money = money / 2n;
    alert("ğŸŒªï¸ Tornado hit you! Lost 50% money!");
  }
}

checkCubeCollisions();
checkHouseDeposit();

// Advent Calendar Controls
function adminAdventSkipDay() {
  if (!adventCalendar.debugOffset) adventCalendar.debugOffset = 0;
  adventCalendar.debugOffset++;
  if (adventCalendar.debugOffset > 24) adventCalendar.debugOffset = 24;
  updateAdventDay();
  updateAdminPanelStats();
  console.log(`ğŸ“… Skipped to advent day ${adventCalendar.debugOffset + 1}`);
}

function adminAdventBackDay() {
  if (!adventCalendar.debugOffset) adventCalendar.debugOffset = 0;
  adventCalendar.debugOffset--;
  if (adventCalendar.debugOffset < 0) adventCalendar.debugOffset = 0;
  updateAdventDay();
  updateAdminPanelStats();
  console.log(`ğŸ“… Went back to advent day ${adventCalendar.debugOffset + 1}`);
}

function adminAdventReset() {
  adventCalendar.debugOffset = 0;
  updateAdventDay();
  updateAdminPanelStats();
  console.log('ğŸ“… Reset advent calendar to current date');
}

// Pet Controls
function adminGiveRandomEgg() {
  const eggTypes = ["Basic Egg", "Rare Egg", "Dragon Egg", "Mythic Egg", "Celestial Egg", "Sunny Egg", "Night Egg", "Gift Egg"];
  const randomEgg = eggTypes[Math.floor(Math.random() * eggTypes.length)];
  
  const existing = playerInventory.Eggs.find(i => i.name === randomEgg);
  if (existing) existing.count++;
  else playerInventory.Eggs.push({ icon: "ğŸ¥š", name: randomEgg, count: 1 });
  
  updateInventoryDisplay();
  console.log(`ğŸ¥š Gave ${randomEgg}`);
}

function adminClearAllPets() {
  if (confirm('âš ï¸ Delete ALL pets? This cannot be undone!')) {
    playerPets = [];
    equippedPets = [];
    petTimers = {};
    updateInventoryDisplay();
    recomputeIncome();
    console.log('ğŸ—‘ï¸ Cleared all pets');
  }
}

function adminMaxPetSlots() {
  maxPetSlots = 10;
  updateRebirthUI();
  console.log('â¬†ï¸ Set pet slots to 10');
}

// Rebirth Controls
function adminCompleteRebirth() {
  if (rebirthCount >= rebirthLevels.length) {
    alert('Already at max rebirth level');
    return;
  }
  
  const nextRebirth = rebirthLevels[rebirthCount];
  
  // Give rewards without reset
  rebirthCount++;
  
  rebirthMultiplier += nextRebirth.incomeMultiplier;
  
  if (nextRebirth.petSlotReward) {
    maxPetSlots += nextRebirth.petSlotReward;
  }
  
  if (nextRebirth.goldenSwordReward) {
    const existing = playerInventory.Swords.find(i => i.name === "Golden Sword");
    if (!existing) {
      playerInventory.Swords.push({
        icon: "ğŸ†",
        name: "Golden Sword",
        count: 1,
        special: 6
      });
    }
  }
  
  recomputeIncome();
  updateDisplays();
  updateInventoryDisplay();
  updateRebirthUI();
  updateAdminPanelStats();
  
  console.log(`ğŸ”„ Completed rebirth ${rebirthCount}`);
}

function adminResetRebirths() {
  if (confirm('âš ï¸ Reset all rebirths? This will keep your items.')) {
    rebirthCount = 0;
    rebirthMultiplier = 1.0;
    maxPetSlots = 3;
    updateRebirthUI();
    recomputeIncome();
    updateAdminPanelStats();
    console.log('ğŸ”„ Reset all rebirths');
  }
}

// Cube Controls
function adminMaxAllCubes() {
  for (let key in legendCounts) {
    legendCounts[key] = 999n;
  }
  recomputeIncome();
  updateDisplays();
  console.log('ğŸ² Maxed all cubes to 999');
}

function adminClearAllCubes() {
  if (confirm('âš ï¸ Clear all cubes?')) {
    for (let key in legendCounts) {
      legendCounts[key] = 0n;
    }
    houseValue = 0n;
    recomputeIncome();
    updateDisplays();
    console.log('ğŸ² Cleared all cubes');
  }
}

// Shop Controls
function adminUnlockAllShop() {
  // Give one of each sword
  const allSwords = [
    ...shopItems.Swords,
    ...(eventShops.day?.items?.Swords || []),
    ...(eventShops.night?.items?.Swords || []),
    ...(christmasShopItems?.Swords || [])
  ];
  // Enchantment Admin Functions
  allSwords.forEach(item => {
    const existing = playerInventory.Swords.find(i => i.name === item.name);
    if (!existing) {
      playerInventory.Swords.push({
        icon: item.icon,
        name: item.name,
        count: 1,
        special: item.special
      });
    }
  });
  
  // Similar for relics, skins
  const allRelics = [...shopItems.Relics, ...(christmasShopItems?.Relics || [])];
  allRelics.forEach(item => {
    const existing = playerInventory.Relics.find(i => i.name === item.name);
    if (!existing) {
      playerInventory.Relics.push({
        icon: item.icon,
        name: item.name,
        count: 1,
        special: item.special
      });
    }
  });
  
  const allSkins = [
    ...shopItems.Skins,
    ...(eventShops.day?.items?.Skins || []),
    ...(eventShops.night?.items?.Skins || []),
    ...(christmasShopItems?.Skins || [])
  ];
  
  allSkins.forEach(item => {
    const existing = playerInventory.Skins.find(i => i.name === item.name);
    if (!existing) {
      playerInventory.Skins.push({
        icon: item.icon,
        name: item.name,
        count: 1,
        special: item.special
      });
    }
  });
  
  updateInventoryDisplay();
  console.log('ğŸ›’ Unlocked all shop items');
}

// Make function globally accessible
window.toggleAdminPanel = toggleAdminPanel;
init();
</script>

</body>
</html>
