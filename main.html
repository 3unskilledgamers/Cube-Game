<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Cubes Game â€” Specials</title>
<style>
  :root{
    --bg:#111;
    --panel:#0f1720;
    --text:#e6eef6;
    --muted:#9aa8b7;
    --accent:#ff3b3b;
  }
  html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,system-ui,-apple-system,Arial}
  body{background:linear-gradient(180deg,#07101a,#051017);color:var(--text);display:flex;align-items:center;justify-content:center;padding:20px}
  .wrap{width:1000px;max-width:98vw}
  .hud{display:flex;gap:16px;align-items:center;margin-bottom:8px}
  .stat{background:rgba(255,255,255,0.03);padding:8px 12px;border-radius:8px;font-weight:600;color:var(--text)}
  .muted{color:var(--muted);font-weight:400}
  .game{background:var(--panel);padding:12px;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,0.6)}
  canvas{background:linear-gradient(180deg,#0b2330,#08202a);display:block;border-radius:12px;cursor:crosshair}
  .bottom-row{display:flex;align-items:flex-start;gap:24px;margin-top:12px}
  .legend{display:flex;flex-direction:column;gap:8px}
  .legend-row{display:flex;align-items:center;gap:8px}
  .swatch{width:20px;height:20px;border-radius:4px;border:1px solid rgba(0,0,0,0.4)}
  .legend-label{min-width:150px;color:var(--muted);font-size:13px}
  .counter{background:rgba(255,255,255,0.03);padding:4px 8px;border-radius:6px;min-width:40px;text-align:center;font-weight:700}
  .controls{display:flex;flex-direction:column;gap:8px}
  button{background:#123;color:var(--text);padding:6px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);cursor:pointer;font-size:14px}
  button:active{transform:translateY(1px)}
  button:disabled{opacity:0.5;cursor:not-allowed}
  .hint{font-size:12px;color:var(--muted)}
  .topline{display:flex;gap:10px;align-items:center;margin-bottom:10px}
  .small{font-size:12px;color:var(--muted)}

  #bossDropsContainer {
    position: fixed;
    top: 20px;
    right: 20px;     /* move anywhere you want */
    z-index: 10000;

    background: rgba(15, 15, 20, 0.85);
    padding: 10px 12px;
    border-radius: 10px;
    box-shadow: 0 0 12px rgba(0,0,0,0.5);
    backdrop-filter: blur(4px);
    color: #cdeaff;
    font-family: sans-serif;
    min-width: 220px;
  }

  #bossDropsContainer summary {
  cursor: pointer;
  font-weight: bold;
  font-size: 16px;
  color: #00ccff;
  }

  #bossDropsContainer details[open] summary {
  color: #00ffff;
  }


#shopPurchasesContainer {
  position: fixed;
  top: 20px;
  left: 20px;      /* Put shop on left, boss on right */
  z-index: 10000;

  background: rgba(20, 15, 0, 0.85);
  padding: 10px 12px;
  border-radius: 10px;
  box-shadow: 0 0 12px rgba(0,0,0,0.5);
  backdrop-filter: blur(4px);
  color: #ffe9a3;
  font-family: sans-serif;
  min-width: 220px;
}

#shopPurchasesContainer summary {
  cursor: pointer;
  font-weight: bold;
  font-size: 16px;
  color: #ffcc00;
}

#shopPurchasesContainer details[open] summary {
  color: #ffe066;
}


</style>
</head>
<body>
<div class="wrap">
  <div class="hud topline">
    <div class="stat" id="moneyDisplay">Money: 0</div>
    <div class="stat" id="incomeDisplay">Income/sec: 0</div>
    <div class="stat" id="houseDisplay">House value: 0</div>
    <div style="flex:1"></div>
<div class="small muted">Move: WASD or click to set target</div>
  </div>

  <div class="game">
    <canvas id="gameCanvas" width="960" height="540"></canvas>

    <div class="bottom-row">
      <div class="legend" id="legendContainer"></div>

<div class="controls">
  <div style="display:flex;gap:8px;align-items:center;">
    <button id="upgradeBtn" style="flex:1;">â¬†ï¸ Upgrade Cubes</button>
       <div id="eventIndicator" style="font-size:24px;width:40px;text-align:center;flex-shrink:0;" title="No active event">â€”</div>
  </div>
  <button id="downgradeBtn">â¬‡ï¸ Downgrade Cubes</button>
  <button id="saveBtn">ğŸ’¾ Save</button>
  <button id="loadBtn">ğŸ“‚ Load</button>
  <button id="rebirthBtn">ğŸ”„ Rebirth</button>
  <div class="hint" id="tierHint">Current Tier: 1</div>
  <div class="hint" id="rebirthHint">Rebirths: 0 (1x)</div>
</div>

      <!-- ğŸ§­ Inventory / Drop Counter -->
    <div id="inventoryContainer" style="color:white;">
      <div class="legend-label"></div>
      <div id="inventoryList" style="margin-top:6px; line-height:1.5;"></div>
    </div>

    <!-- ğŸª SHOP AREA (hidden until inside house) -->
    <div id="shopContainer" style="display:none; color:white;">
      <div class="legend-label">ğŸª SHOP</div>
      <div id="shopItems" style="margin-top:6px; line-height:1.5;"></div>
    </div>

 </div>
 </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');


// === ADMIN ABUSE EVENTS CONFIGURATION ===
const adminAbuseEvents = [
  {
    name: "Blackhole",
    key: "!",
    duration: 120000, // 2 minutes in ms
    incomeBoost: 1.30, // 30% boost
    bg: "radial-gradient(circle at center, #000000 0%, #1a0033 30%, #330066 60%, #000000 100%)",
    overlay: "rgba(0,0,0,0.3)",
    animation: "blackhole"
  },
  {
    name: "Hurricane",
    key: "@",
    duration: 60000, // 1 minute
    incomeBoost: 1.15,
    bg: "radial-gradient(circle, #334455 0%, #1a2a3a 50%, #0d1520 100%)",
    overlay: "rgba(100,120,150,0.25)",
    animation: "hurricane"
  },
  {
    name: "Disco",
    key: "#",
    duration: 95000, // 1 min 35 sec
    incomeBoost: 1.25,
    bg: "linear-gradient(45deg, #ff00ff 0%, #00ffff 25%, #ffff00 50%, #ff00ff 75%, #00ffff 100%)",
    overlay: "rgba(255,255,255,0.1)",
    animation: "disco"
  },
  {
    name: "Volcano",
    key: "$",
    duration: 45000, // 45 seconds
    incomeBoost: 1.35,
    bg: "linear-gradient(180deg, #330000 0%, #660000 30%, #ff4400 60%, #ff8800 100%)",
    overlay: "rgba(255,100,0,0.3)",
    animation: "volcano"
  },
  {
    name: "Earthquake",
    key: "%",
    duration: 15000, // 15 seconds
    incomeBoost: 1.50,
    bg: "linear-gradient(180deg, #2a2520 0%, #3a2a20 50%, #2a2520 100%)",
    overlay: "rgba(100,80,60,0.2)",
    animation: "earthquake"
  },
  {
    name: "Glitched",
    key: "^",
    duration: 60000, // 1 minute
    incomeBoost: 1.35,
    bg: "linear-gradient(90deg, #000 0%, #0f0 2%, #000 4%, #f0f 6%, #000 8%, #0ff 10%, #000 100%)",
    overlay: "rgba(0,255,0,0.15)",
    animation: "glitched"
  },
  {
    name: "Galactic",
    key: "&",
    duration: 180000, // 3 minutes
    incomeBoost: 1.20,
    bg: "radial-gradient(circle at 20% 30%, #4a0080 0%, #000033 40%, #000000 100%)",
    overlay: "rgba(80,60,150,0.2)",
    animation: "galactic"
  }
];
// === DAY/NIGHT CYCLE CONFIGURATION ===
const dayNightCycle = {
  current: "day", // "day", "night", "sunrise", "sunset"
  duration: 15 * 60 * 1000, // 15 minutes in milliseconds
  transitionDuration: 5 * 60 * 1000, // 5 minutes for sunrise/sunset
  nextChange: Date.now() + 10 * 60 * 1000, // 10 min until sunset starts
  transitioning: false,
  transitionProgress: 0,
  
  day: {
    background: "linear-gradient(180deg, #87CEEB 0%, #E0F6FF 50%, #87CEEB 100%)",
    canvasGradient: ["#B0E0FF", "#D0F0FF", "#B0E0FF"],
    overlay: "rgba(255, 255, 150, 0.1)",
    emoji: "â˜€ï¸",
    name: "Day",
    celestialBody: "â˜€ï¸",
    celestialY: 80
  },
  
  sunset: {
    background: "linear-gradient(180deg, #FF6B35 0%, #FF8C42 30%, #FFA756 60%, #87CEEB 100%)",
    canvasGradient: ["#FF6B35", "#FF8C42", "#FFA756"],
    overlay: "rgba(255, 100, 50, 0.2)",
    emoji: "ğŸŒ…",
    name: "Sunset",
    celestialBody: "ğŸŒ‡",
    celestialY: 200
  },
  
  night: {
    background: "linear-gradient(180deg, #0A1128 0%, #1A2238 50%, #0A1128 100%)",
    canvasGradient: ["#0b2330", "#08202a", "#0b2330"],
    overlay: "rgba(0, 0, 50, 0.4)",
    emoji: "ğŸŒ™",
    name: "Night",
    celestialBody: "ğŸŒ™",
    celestialY: 80
  },
  
  sunrise: {
    background: "linear-gradient(180deg, #1A2238 0%, #FF6B35 40%, #FFB347 70%, #87CEEB 100%)",
    canvasGradient: ["#1A2238", "#FF6B35", "#FFB347"],
    overlay: "rgba(255, 150, 100, 0.2)",
    emoji: "ğŸŒ„",
    name: "Sunrise",
    celestialBody: "ğŸŒ…",
    celestialY: 200
  }
};

let dayNightStars = []; // for night time stars
let sunsetClouds = []; // for sunset/sunrise clouds

// Generate stars for night time
function generateStars() {
  dayNightStars = [];
  for (let i = 0; i < 100; i++) {
    dayNightStars.push({
      x: Math.random() * W,
      y: Math.random() * H * 0.6, // only in top 60% of screen
      size: 1 + Math.random() * 2,
      twinkle: Math.random(),
      twinkleSpeed: 0.5 + Math.random() * 1.5
    });
  }
}

// Generate clouds for sunset/sunrise
function generateClouds() {
  sunsetClouds = [];
  for (let i = 0; i < 8; i++) {
    sunsetClouds.push({
      x: Math.random() * W,
      y: 100 + Math.random() * 150,
      width: 60 + Math.random() * 80,
      height: 30 + Math.random() * 20,
      speed: 10 + Math.random() * 20,
      opacity: 0.3 + Math.random() * 0.4
    });
  }
}

// Change day/night cycle
// Change day/night cycle
function changeDayNightCycle(newCycle, isManual = false) {
  if (dayNightCycle.current === newCycle && !isManual) return;
  
  const oldCycle = dayNightCycle.current;
  dayNightCycle.current = newCycle;
  
  // Set next change time based on cycle
  if (isManual) {
    // Manual trigger - set appropriate next auto change
    if (newCycle === "day") {
      dayNightCycle.nextChange = Date.now() + 10 * 60 * 1000; // 10 min until sunset
    } else if (newCycle === "sunset") {
      dayNightCycle.nextChange = Date.now() + 5 * 60 * 1000; // 5 min until night
    } else if (newCycle === "night") {
      dayNightCycle.nextChange = Date.now() + 10 * 60 * 1000; // 10 min until sunrise
    } else if (newCycle === "sunrise") {
      dayNightCycle.nextChange = Date.now() + 5 * 60 * 1000; // 5 min until day
    }
  } else {
    // Auto progression
    if (newCycle === "sunset") {
      dayNightCycle.nextChange = Date.now() + 5 * 60 * 1000; // 5 min until night
    } else if (newCycle === "night") {
      dayNightCycle.nextChange = Date.now() + 10 * 60 * 1000; // 10 min until sunrise
    } else if (newCycle === "sunrise") {
      dayNightCycle.nextChange = Date.now() + 5 * 60 * 1000; // 5 min until day
    } else if (newCycle === "day") {
      dayNightCycle.nextChange = Date.now() + 10 * 60 * 1000; // 10 min until sunset
    }
  }
  
  console.log(`ğŸŒ ${dayNightCycle[newCycle].name} started! Next change in ${Math.round((dayNightCycle.nextChange - Date.now()) / 60000)} minutes`);
  
  // Generate appropriate particles
  if (newCycle === "night" || newCycle === "sunrise") {
    generateStars();
  }
  if (newCycle === "sunset" || newCycle === "sunrise") {
    generateClouds();
  }
  
  updateEventIndicator();
    // Update shop display if player is in house
  if (insideHouse) {
    updateShopDisplay();
  }
}


// Auto cycle with transitions
function checkDayNightCycle() {
  if (Date.now() >= dayNightCycle.nextChange) {
    const current = dayNightCycle.current;
    
    // Progression: day -> sunset -> night -> sunrise -> day
    if (current === "day") {
      changeDayNightCycle("sunset");
    } else if (current === "sunset") {
      changeDayNightCycle("night");
    } else if (current === "night") {
      changeDayNightCycle("sunrise");
    } else if (current === "sunrise") {
      changeDayNightCycle("day");
    }
  }
}

// Check cycle every second
setInterval(checkDayNightCycle, 1000);

// Auto cycle every 15 minutes
function checkDayNightCycle() {
  if (Date.now() >= dayNightCycle.nextChange) {
    const newCycle = dayNightCycle.current === "day" ? "night" : "day";
    changeDayNightCycle(newCycle);
  }
}

// Check cycle every second
setInterval(checkDayNightCycle, 1000);
const rebirthLevels = [
  {
    level: 1,
    cost: 1_000_000_000n, // 1B
    requiredCube: "Red",
    requiredCount: 10,
    incomeMultiplier: 0.5,
    description: "Rebirth 1: +0.5x Income"
  },
  {
    level: 2,
    cost: 1_000_000_000_000n, // 1T
    requiredCube: "Light Blue",
    requiredCount: 10,
    incomeMultiplier: 0.5,
    petSlotReward: 1,
    description: "Rebirth 2: +0.5x Income, +1 Pet Slot"
  },
  {
    level: 3,
    cost: 1_000_000_000_000_000n, // 1QA
    requiredCube: "Light Orange",
    requiredCount: 10,
    incomeMultiplier: 0.5,
    description: "Rebirth 3: +0.5x Income"
  },
  {
    level: 4,
    cost: 1_000_000_000_000_000_000n, // 1QI
    requiredCube: "Light Gray",
    requiredCount: 10,
    incomeMultiplier: 0.5,
    petSlotReward: 1,
    description: "Rebirth 4: +0.5x Income, +1 Pet Slot"
  },
  {
    level: 5,
    cost: 1_000_000_000_000_000_000_000n, // 1SX
    requiredCube: "Indigo",
    requiredCount: 10,
    incomeMultiplier: 0.5,
    description: "Rebirth 5: +0.5x Income"
  },
  {
    level: 6,
    cost: 1_000_000_000_000_000_000_000_000n, // 1SP
    requiredCube: "Dark Purple",
    requiredCount: 10,
    incomeMultiplier: 0.5,
    description: "Rebirth 6: +0.5x Income"
  },
  {
    level: 7,
    cost: 1_000_000_000_000_000_000_000_000_000n, // 1OC
    requiredCube: "Neon Green",
    requiredCount: 10,
    incomeMultiplier: 0.5,
    petSlotReward: 1,
    description: "Rebirth 7: +0.5x Income, +1 Pet Slot"
  },
  {
    level: 8,
    cost: 100_000_000_000_000_000_000_000_000_000n, // 100OC (1NO)
    requiredCube: "Bright Orange",
    requiredCount: 10,
    incomeMultiplier: 0.5,
    description: "Rebirth 8: +0.5x Income"
  },
  {
    level: 9,
    cost: 100_000_000_000_000_000_000_000_000_000_000n, // 1DC
    requiredCube: "Dark Brown",
    requiredCount: 10,
    incomeMultiplier: 0.5,
    petSlotReward: 2,
    goldenSwordReward: true,
    description: "Rebirth 9: +0.5x Income, +2 Pet Slots, Golden Sword (MAX)"
  }
];

let rebirthCount = 0;
let rebirthMultiplier = 1.0;
let maxPetSlots = 3; // NEW: Track max pet slots

const rebirthBtn = document.getElementById('rebirthBtn');
const rebirthHint = document.getElementById('rebirthHint');

// Admin Abuse event state
let currentAdminEvent = null;
let adminEventTimer = null;
let adminEventParticles = [];
let adminEventOverlayAlpha = 0;
let adminEventShakeX = 0;
let adminEventShakeY = 0;

const ctx = canvas.getContext('2d');

const W = canvas.width, H = canvas.height;
const CUBE_SIZE = 48;
const CUBE_SPACING = 18;
const CUBE_COUNT = 8;
const TOP_Y = 30;

const moneyDisplay = document.getElementById('moneyDisplay');
const incomeDisplay = document.getElementById('incomeDisplay');
const houseDisplay = document.getElementById('houseDisplay');
const legendContainer = document.getElementById('legendContainer');
const upgradeBtn = document.getElementById('upgradeBtn');
const downgradeBtn = document.getElementById('downgradeBtn');
const tierHint = document.getElementById('tierHint');

let cubeTier = 0; // 0 = base, 1 = tier 2, 2 = tier 3

let currentWeather = null;
let weatherTimer = null;
let weatherMultiplier = 1; // affects income
let speedMultiplier = 1;   // affects movement
let weatherOverlayAlpha = 0;

let weatherParticles = [];

// put this at top-level, once
let equippedCategory = null;

// make equipCategory callable from inline onclick in the generated HTML
window.equipCategory = function(cat) {
  // toggle: equip if different, unequip if same
  equippedCategory = (equippedCategory === cat) ? null : cat;
  // refresh inventory UI
  updateInventoryDisplay();
};

let equippedItems = {}; // e.g. { Swords: "Iron Sword", Relics: "Magic Relic" }


let equippedSwordSpecial = 0;
let equippedRelicSpecial = 1;
let equippedEggSpecial = 0;
let equippedSkinSpecial = 1;
let equippedPotionSpecial = 1;

// Potion event state
let potionActive = false;
let potionMultiplier = 1;
let potionEndTime = 0;

let swordicon ="";

const skins = {
  1:   { color: "#ff2b2b" },
  2:  { color: "#4d7cff" },
  3: { color: "#a45ee5" },
  4:  { color: "#ffd700" },
  5:  { color: "#e9ecef" }
};


window.equipItem = function equipItem(category, itemName) {
  // Find item in player inventory
  const inventoryCategory = playerInventory[category];
  if (!inventoryCategory) {
    console.error("Category not found:", category);
    return;
  }
  
  const item = inventoryCategory.find(i => i.name === itemName);
  if (!item) {
    console.error("Item not found:", itemName);
    return;
  }

  // Assign special values to corresponding global variable
  switch (category) {
    case "Swords":
      equippedSwordSpecial = item.special || 0;
      swordicon = item.icon;
      break;
    case "Relics":
      equippedRelicSpecial = item.special || 1;
      break;
    case "Eggs":
      equippedEggSpecial = item.special || 0;
      break;
    case "Skins":
      equippedSkinSpecial = item.special || 1;
      // Update character color based on skin
      if (skins[equippedSkinSpecial]) {
        character.color = skins[equippedSkinSpecial].color;
      }
      break;
    case "Potions":
      equippedPotionSpecial = item.special || 1;
      activatePotionEvent(item.special);
      break;
  }

  // Mark as equipped in inventory
  playerInventory[category].forEach(i => i.equipped = (i.name === itemName));

  console.log(`âœ… Equipped ${item.name} (${category}) â€” special: ${item.special}`);
  recomputeIncome(); // Recalculate with new equipment
  updateInventoryDisplay();
  html += `<span style="color:#aaa;">Equipped: ${equippedPets.length}/${maxPetSlots}</span>`;
}

// Draw pets following the character
function renderPets(ctx) {
  equippedPets.forEach(pet => {
    // Draw pet body
    ctx.fillStyle = pet.color;
    ctx.fillRect(pet.x, pet.y, 32, 32); // Smaller than character (48x48)
    
    // Draw pet icon
    ctx.font = '20px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(pet.icon, pet.x + 16, pet.y + 16);
    
    // Draw mutation indicator if exists
    if (pet.mutation) {
      const mut = petMutations[pet.mutation];
      ctx.font = '12px sans-serif';
      ctx.fillText(mut.emoji, pet.x + 26, pet.y + 6);
    }
  });
}


// === WEATHER LIST ===
const weatherEvents = [
  {
    name: "Rain",
    duration: 60_000, // lasts 1 min
    incomeBoost: 1.05,
    speedBoost: 1.0,
    bg: "linear-gradient(#445, #223)",
    overlay: "rgba(100,150,255,0.2)"
  },
  {
    name: "Wind",
    duration: 60_000,
    incomeBoost: 1.0,
    speedBoost: 1.05,
    bg: "linear-gradient(#ccd, #889)",
    overlay: "rgba(200,200,255,0.15)"
  },
  {
    name: "Thunder",
    duration: 60_000,
    incomeBoost: 1.10,
    speedBoost: 1.0,
    bg: "linear-gradient(#222, #000)",
    overlay: "rgba(255,255,150,0.25)"
  }
];
// Event emoji mapping
const eventEmojis = {
  "Wind": "ğŸ’¨",
  "Rain": "ğŸŒ§ï¸",
  "Thunder": "â›ˆï¸",
  "Blackhole": "âš«",
  "Hurricane": "ğŸŒ€",
  "Disco": "ğŸª©",
  "Volcano": "ğŸŒ‹",
  "Earthquake": "ğŸ«¨",
  "Glitched": "âšœï¸",
  "Galactic": "ğŸš€"
};
function nvl(value, defaultValue) {
return value == null ? defaultValue : value;
}




/**
Purpose:
Updates the HTML inventory UI (#inventoryList) to show:
Playerâ€™s current drops (bones, relics, skins, cubes).
All purchased shop items by category.
Key Behavior:

Builds HTML dynamically with item icons and current counts.
Pulls data from dropCounters, dropLimits, and playerInventory.
 * @returns {void}
 */
function updateInventoryDisplay() {
  //const inv = document.getElementById('inventoryDisplay');
  const inv = document.getElementById("inventoryList");

  const bossOpen = document.getElementById("detailsBossDrops")?.open ?? true;
  const shopOpen = document.getElementById("detailsShopPurchases")?.open ?? true;

  if (!inv) return;

  
  // --- Existing inventory (drops) ---
let html = `
   <div id="bossDropsContainer">
  <details id="detailsBossDrops" open style="margin-top:8px;">
    <summary style="cursor:pointer; font-weight:bold; color:#00ccff;">ğŸ“¦ Boss Drops</summary>
    <div style="margin-left:10px; margin-top:5px;">
      ğŸ¦´ Skeleton Bones: ${nvl(dropCounters["ğŸ¦´ Skeleton Bones"],0)}/${dropLimits.bones}<br>
      ğŸ“¿ Crossbones Relic: ${nvl(dropCounters["ğŸ“¿ Crossbones Relic"],0)}/${dropLimits.relic}<br>
      â¬œğŸ’€ Skeleton Skin: ${nvl(dropCounters["â¬œğŸ’€ Skeleton Skin"],0)}/${dropLimits.skin}<br>
      â¬œâ˜ ï¸ Crossbones Cube: ${nvl(dropCounters["â¬œâ˜ ï¸ Crossbones Cube"],0)}/${dropLimits.cube}<br>
    </div>
  </details>
   </div>
`;


  // --- Shop Inventory ---
  //html += `<b>Shop Purchases</b><br>`;
  html += '<div id="shopPurchasesContainer"><details id="detailsShopPurchases" open style="margin-top:8px;"><summary style="cursor:pointer; font-weight:bold; color:#ffcc00;">ğŸ›’ Shop Purchases</summary><div style="margin-left:10px; margin-top:5px;"><div>';
  
  const categories = ["Swords", "Relics", "Eggs", "Skins", "Potions"];

  categories.forEach(cat => {
    const items = playerInventory[cat];
    if (!items || items.length === 0) return;

    html += `<u>${cat}</u><br>`;

playerInventory[cat].forEach(item => {
  const limit = (cat === "Eggs" || cat === "Potions") ? 999 : 1;
  const isEquipped = !!item.equipped;

  // Get the correct special value for this category
  let equippedSpecial = 0;
  switch (cat) {
    case "Swords":   equippedSpecial = equippedSwordSpecial; break;
    case "Relics":   equippedSpecial = equippedRelicSpecial; break;
    case "Eggs":     equippedSpecial = equippedEggSpecial; break;
    case "Skins":    equippedSpecial = equippedSkinSpecial; break;
    case "Potions":  equippedSpecial = equippedPotionSpecial; break;
  }

  // Use item.special if it exists, otherwise show equipped value
  const displaySpecial = item.special || equippedSpecial;

  // Build the button label
  const btnLabel = isEquipped ? `Equipped (â­${displaySpecial})` : 'Equip';

  // Append to HTML string
  html += `${item.icon} ${item.name}: ${item.count}/${limit}`;
  
  // Add Equip button for non-eggs
  if (cat !== "Eggs") {
    html += `
      <button
        onclick="equipItem('${cat}', '${item.name}')"
        style="
          margin-left:5px; 
          padding:2px 6px; 
          border-radius:5px; 
          background:${isEquipped ? '#28a745' : '#333'}; 
          color:white; 
          border:none; 
          cursor:pointer;
        ">
        ${btnLabel}
      </button>`;
  }
  
  // Add Open buttons for eggs
  if (cat === "Eggs" && item.count > 0) {
    html += `
      <button
        onclick="openEggFromInventory('${item.name}', 1)"
        style="
          margin-left:5px; 
          padding:2px 6px; 
          border-radius:5px; 
          background:#FFA500; 
          color:white; 
          border:none; 
          cursor:pointer;
        ">
        Open 1
      </button>`;
    
    if (item.count >= 10) {
      html += `
        <button
          onclick="openEggFromInventory('${item.name}', 10)"
          style="
            margin-left:5px; 
            padding:2px 6px; 
            border-radius:5px; 
            background:#FF8C00; 
            color:white; 
            border:none; 
            cursor:pointer;
          ">
          Open 10
        </button>`;
    }
  }
  
  html += `<br>`;
});



    html += `<br>`;
  });
// --- Pet Inventory (ONLY ONE SECTION) ---
html += '<div style="margin-top:15px;"><u>ğŸ¾ Pets</u><br>';

if (playerPets.length === 0) {
  html += '<span style="color:#888;">No pets yet. Buy eggs to hatch pets!</span><br>';
} else {
  html += `<span style="color:#aaa;">Equipped: ${equippedPets.length}/${maxPetSlots}</span>`;
  
  // Add bulk delete button
  html += `<button onclick="bulkDeletePets()" style="margin-left:10px;padding:2px 8px;border-radius:5px;background:#dc3545;color:white;border:none;cursor:pointer;">ğŸ—‘ï¸ Delete All Unequipped</button><br>`;
  
// Add search bar with tips
html += `
  <div style="margin-top:8px;margin-bottom:8px;">
    <input 
      type="text" 
      id="petSearchInput" 
      placeholder="ğŸ” Search pets..." 
      style="padding:4px 8px;border-radius:5px;border:1px solid #555;background:#222;color:white;width:200px;"
      oninput="filterPets(this.value)"
    />
    <button 
      onclick="clearPetSearch()" 
      style="margin-left:5px;padding:4px 8px;border-radius:5px;background:#555;color:white;border:none;cursor:pointer;">
      Clear
    </button>
    <br>
    <span style="font-size:10px;color:#888;margin-left:2px;">
      ğŸ’¡ Tips: Search by name, ability, mutation, or try: "equipped", "unequipped", "mutated"
    </span>
  </div>
`;
  
  // Pet list container
  html += '<div id="petListContainer">';
  
  playerPets.forEach(pet => {
    const mutationText = pet.mutation ? ` [${petMutations[pet.mutation].emoji} ${pet.mutation}]` : '';
    const equippedBtn = pet.equipped 
      ? '<button onclick="togglePetEquip(' + pet.id + ')" style="margin-left:5px;padding:2px 6px;border-radius:5px;background:#28a745;color:white;border:none;cursor:pointer;">âœ“ Equipped</button>'
      : '<button onclick="togglePetEquip(' + pet.id + ')" style="margin-left:5px;padding:2px 6px;border-radius:5px;background:#333;color:white;border:none;cursor:pointer;">Equip</button>';
    
    const deleteBtn = '<button onclick="deletePet(' + pet.id + ')" style="margin-left:5px;padding:2px 6px;border-radius:5px;background:#dc3545;color:white;border:none;cursor:pointer;">ğŸ—‘ï¸</button>';
    
    html += `<div class="pet-item" data-pet-name="${pet.name.toLowerCase()}" data-pet-ability="${pet.ability.toLowerCase()}" data-pet-mutation="${(pet.mutation || '').toLowerCase()}">`;
    html += `${pet.icon} ${pet.name}${mutationText} ${equippedBtn} ${deleteBtn}<br>`;
    html += `<span style="font-size:11px;color:#888;margin-left:20px;">${pet.description}</span><br>`;
    html += `</div>`;
  });
  
  html += '</div>'; // Close petListContainer
}

html += '</div>';
  html += '</div></details>';
  inv.innerHTML = html;
  document.getElementById("detailsBossDrops").open = bossOpen;
  document.getElementById("detailsShopPurchases").open = shopOpen;


}

// --- Equip logic ---
function equipCategory(cat) {
  equippedCategory = (equippedCategory === cat) ? null : cat;
  updateInventoryDisplay();
}

/**
 * Adds one item of the specified type to the player's inventory.
 * If the item does not already exist in the player's inventory, it will be added with a count of 1.
 * If the item already exists, its count will be incremented by 1.
 * The function will also update the inventory display in the game UI after adding the item.
 * @param {string} itemName - The name of the item to add to the player's inventory.
 * @returns {void}
 */
function addToInventory(itemName) {
  if (!drops[itemName]) drops[itemName] = 0; // ensure item exists
  const limits = {
    "ğŸ—¡ï¸ Sword I": 999n,
    "ğŸ—¡ï¸ Sword II": 999n,
    "ğŸ—¡ï¸ Sword III": 999n,
    "ğŸ—¡ï¸ Sword IV": 999n,
    "ğŸ—¡ï¸ Sword V": 999n,
    "ğŸ“¿ Relic I": 1n,
    "ğŸ“¿ Relic II": 1n,
    "ğŸ“¿ Relic III": 1n,
    "ğŸ“¿ Relic IV": 1n,
    "ğŸ“¿ Relic V": 1n,
    "ğŸ¥š Egg I": 999n,
    "ğŸ¥š Egg II": 999n,
    "ğŸ¥š Egg III": 999n,
    "ğŸ¥š Egg IV": 999n,
    "ğŸ¥š Egg V": 999n,
    "ğŸ’ Skin I": 1n,
    "ğŸ’ Skin II": 1n,
    "ğŸ’ Skin III": 1n,
    "ğŸ’ Skin IV": 1n,
    "ğŸ’ Skin V": 1n,
    "ğŸ§ª Potion I": 999n,
    "ğŸ§ª Potion II": 999n,
    "ğŸ§ª Potion III": 999n,
    "ğŸ§ª Potion IV": 999n,
    "ğŸ§ª Potion V": 999n,
  };
  
  const limit = limits[itemName] ?? 999n;
  if (BigInt(drops[itemName]) < limit) {
    drops[itemName] = BigInt(drops[itemName]) + 1n;
    updateInventoryDisplay();
  }
}
// ADD THIS ENTIRE FUNCTION HERE (before updateShopDisplay)
function buyItem(category, index, skipOdds = false) {
  const item = shopItems[category][index];
  if (!item) {
    console.error("Item not found:", category, index);
    return;
  }

  const limit = (category === "Eggs" || category === "Potions") ? 999n : 1n;
  
  const inventoryKey = item.name;
  const owned = BigInt(inventory[inventoryKey] || 0n);

  if (owned >= limit) {
    alert(`You already own the maximum number of ${item.name}s!`);
    return;
  }

  if (money < item.price) {
    alert(`Not enough money to buy ${item.name}!`);
    return;
  }

  // === EGGS: Show odds before purchase (unless shift is held) ===
  if (category === "Eggs" && !skipOdds) {
    const oddsInfo = showEggOdds(item.name);
    const confirmPurchase = confirm(`${oddsInfo}\nPurchase ${item.name} for ${formatBigInt(item.price)}?`);
    
    if (!confirmPurchase) {
      return; // User cancelled
    }
  }

  money -= item.price;
  inventory[inventoryKey] = owned + 1n;

  const existing = playerInventory[category].find(i => i.name === item.name);
  if (existing) {
    existing.count++;
  } else {
    playerInventory[category].push({
      icon: item.icon,
      name: item.name,
      count: 1,
      special: item.special
    });
  }

  updateDisplays();
  updateInventoryDisplay();
}

// Show egg odds before purchase
// Display pet odds for an egg type
function showEggOdds(eggType) {
  const pets = petDatabase[eggType];
  if (!pets) {
    return "Unknown egg type";
  }
  
  let oddsText = `ğŸ¥š ${eggType} Contents:\n\n`;
  
  // Sort pets by chance descending for better display
  const sortedPets = [...pets].sort((a, b) => b.chance - a.chance);
  
  sortedPets.forEach(pet => {
    const percentage = (pet.chance * 100).toFixed(2);
    oddsText += `${pet.icon} ${pet.name}\n`;
    oddsText += `   ${pet.description}\n`;
    oddsText += `   Chance: ${percentage}%\n\n`;
  });
  
  return oddsText;
}
function updateShopDisplay() {
  const shopContainer = document.getElementById('shopContainer');
  if (!shopContainer) return;
  shopContainer.innerHTML = "<div class='legend-label'>ğŸª SHOP</div>";

  const purchaseLimits = {
    Swords: 1,
    Relics: 1,
    Eggs: 999,
    Skins: 1,
    Potions: 999
  };

  // Regular shop items
  for (const [category, items] of Object.entries(shopItems)) {
    const row = document.createElement('div');
    row.style.display = "flex";
    row.style.gap = "10px";
    row.style.marginTop = "8px";
    row.innerHTML = `<strong style='min-width:70px'>${category}:</strong>`;

items.forEach((item, index) => {
  const btn = document.createElement('button');
  btn.innerText = `${item.icon} ${item.name}\nğŸ’°${shortLabel(item.price)}`;
  btn.style.display = "flex";
  btn.style.flexDirection = "column";
  btn.style.alignItems = "center";
  btn.style.justifyContent = "center";
  btn.style.fontSize = "10px";
  btn.style.padding = "4px 6px";
  btn.style.background = "#4a3000";
  btn.style.border = "1px solid #FFD700";

  // FIX: Use buyItem for regular shop, not buyEventItem
  btn.onclick = (e) => {
    if (category === "Eggs" && e.shiftKey) {
      buyItem(category, index, true); // Skip odds with shift
    } else {
      buyItem(category, index, false); // Show odds normally
    }
  };

  row.appendChild(btn);
});
    shopContainer.appendChild(row);
  }

  // === EVENT SHOPS ===
  for (const [eventKey, eventShop] of Object.entries(eventShops)) {
    if (eventShop.activeWhen()) {
      const separator = document.createElement('div');
      separator.style.marginTop = "15px";
      separator.style.borderTop = "2px solid rgba(255,255,255,0.2)";
      separator.style.paddingTop = "10px";
      shopContainer.appendChild(separator);

      const eventTitle = document.createElement('div');
      eventTitle.className = 'legend-label';
      eventTitle.textContent = eventShop.displayName;
      eventTitle.style.color = "#FFD700";
      shopContainer.appendChild(eventTitle);

      for (const [category, items] of Object.entries(eventShop.items)) {
        const row = document.createElement('div');
        row.style.display = "flex";
        row.style.gap = "10px";
        row.style.marginTop = "8px";
        row.innerHTML = `<strong style='min-width:70px;color:#FFD700'>${category}:</strong>`;

        items.forEach((item) => {
          const btn = document.createElement('button');
          btn.innerText = `${item.icon} ${item.name}\nğŸ’°${shortLabel(item.price)}`;
          btn.style.display = "flex";
          btn.style.flexDirection = "column";
          btn.style.alignItems = "center";
          btn.style.justifyContent = "center";
          btn.style.fontSize = "10px";
          btn.style.padding = "4px 6px";
          btn.style.background = "#4a3000";
          btn.style.border = "1px solid #FFD700";

          btn.onclick = () => buyEventItem(eventKey, category, item);

          row.appendChild(btn);
        });

        shopContainer.appendChild(row);
      }
    }
  }
}

function buyEventItem(eventKey, category, item) {
  const limit = (category === "Eggs" || category === "Potions") ? 999n : 1n;
  const inventoryKey = item.name;
  const owned = BigInt(inventory[inventoryKey] || 0n);

  if (owned >= limit) {
    alert(`You already own the maximum number of ${item.name}s!`);
    return;
  }

  if (money < item.price) {
    alert(`Not enough money to buy ${item.name}!`);
    return;
  }

  // === EGGS: Show odds before purchase ===
  if (category === "Eggs") {
    const oddsInfo = showEggOdds(item.name);
    const confirmPurchase = confirm(`${oddsInfo}\nPurchase ${item.name} for ${formatBigInt(item.price)}?`);
    
    if (!confirmPurchase) {
      return; // User cancelled
    }
  }

  money -= item.price;
  inventory[inventoryKey] = owned + 1n;

  const existing = playerInventory[category].find(i => i.name === item.name);
  if (existing) {
    existing.count++;
  } else {
    playerInventory[category].push({
      icon: item.icon,
      name: item.name,
      count: 1,
      special: item.special
    });
  }

  // Eggs: Open immediately and hatch a pet
  if (category === "Eggs") {
    const pet = openEgg(item.name);
    if (pet) {
      const mutationText = pet.mutation ? `\n\nğŸ‰ MUTATION: ${pet.mutation} ${petMutations[pet.mutation].emoji}` : '';
      alert(`ğŸ‰ Hatched ${pet.icon} ${pet.name}!\n${pet.description}${mutationText}`);
    }
  }

  updateDisplays();
  updateInventoryDisplay();
  updateShopDisplay();
}



/**
 * Format a BigInt as a string with commas for readability.
 * @param {BigInt} b - The BigInt to format.
 * @returns {string} The formatted string.
 */

 function formatBigInt2(b) {
  if (typeof b === 'number') b = BigInt(Math.floor(b));
  const s = b.toString();
  return s.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}


function formatBigInt(b) {
  if (typeof b === 'number') b = BigInt(Math.floor(b));
  if (typeof b !== 'bigint') return b;

  const isNegative = b < 0n;
  b = isNegative ? -b : b;

  const UNITS = [
  { value: 1_000_000_000_000_000_000_000_000_000_000_000n, symbol: "DC" }, // decilion (10^24)
  { value: 1_000_000_000_000_000_000_000_000_000_000n, symbol: "NO" }, // nonnilion (10^24) 
  { value: 1_000_000_000_000_000_000_000_000_000n, symbol: "OC" }, // octilion (10^24)  
  { value: 1_000_000_000_000_000_000_000_000n, symbol: "SP" }, // septilion (10^24)
    { value: 1_000_000_000_000_000_000_000n, symbol: "SX" }, // sextilion (10^21)
    { value: 1_000_000_000_000_000_000n, symbol: "QI" }, // quintilion (10^18)
    { value: 1_000_000_000_000_000n, symbol: "QA" }, // quadrilion (10^15)
    { value: 1_000_000_000_000n, symbol: "T" }, // trillion (10^12)
    { value: 1_000_000_000n, symbol: "B" }, // billion (10^9)
    { value: 1_000_000n, symbol: "M" }, // million (10^6)
    { value: 1_000n, symbol: "K" } // thousand (10^3)
  ];

  for (const unit of UNITS) {
    if (b >= unit.value) {
      // Compute with BigInt precision safely
      const whole = Number(b / unit.value);
      const frac = Number(b % unit.value) / Number(unit.value);
      const formatted = (whole + frac).toFixed(1).replace(/\.0$/, "");
      return (isNegative ? "-" : "") + formatted + unit.symbol;
    }
  }

  // Fallback for small numbers
  return (isNegative ? "-" : "") + b.toString();
}



/**
 * Format a BigInt as a string with commas for readability and
 * optionally display a unit at the end (e.g. "K" for thousands, "M" for millions, etc.)
 * @param {BigInt} n - The number to format
 * @returns {string} The formatted string
 */
function shortLabel(n) {
  const num = BigInt(n);
  const abs = num < 0n ? -num : num;
const units = [
  [1_000_000_000_000_000_000_000_000_000_000_000n, "DC"], // decillion
  [1_000_000_000_000_000_000_000_000_000_000n, "NO"], // nonillion
  [1_000_000_000_000_000_000_000_000_000n, "OC"], // octillion
  [1_000_000_000_000_000_000_000_000n, "SP"], // septillion
  [1_000_000_000_000_000_000_000n, "SX"], // sextillion
  [1_000_000_000_000_000_000n, "QI"], // quintillion
  [1_000_000_000_000_000n, "QA"], // quadrillion
  [1_000_000_000_000n, "T"], // trillion
  [1_000_000_000n, "B"], // billion
  [1_000_000n, "M"], // million
  [1_000n, "K"] // thousand
];

  for (let [v, l] of units) if (abs >= v) return (num < 0n ? "-" : "") + Number(abs / v) + l;
  return num.toString();
}

const tier1Cubes = [
  { name: "Green", color: "#3bbf6e", value: 100n },
  { name: "Blue", color: "#3b8ebf", value: 1000n },
  { name: "Black", color: "#222222", value: 10000n },
  { name: "Yellow", color: "#e6d44a", value: 100000n },
  { name: "Orange", color: "#ff8a2b", value: 1000000n },
  { name: "Purple", color: "#8b3bff", value: 10000000n },
  { name: "Red", color: "#c53030", value: 100000000n },
  { name: "White", color: "#e9ecef", value: 1000000000n },
];
const tier2Cubes = [
  { name: "Light Green", color: "#9be6b8", value: 10000000000n },
  { name: "Light Blue", color: "#9bd3e6", value: 100000000000n },
  { name: "Dark Grey", color: "#6b6b6b", value: 1000000000000n },
  { name: "Light Yellow", color: "#fff1a8", value: 10000000000000n },
  { name: "Light Orange", color: "#ffc89b", value: 100000000000000n },
  { name: "Light Purple", color: "#d8b8ff", value: 1000000000000000n },
  { name: "Light Red", color: "#ffb8b8", value: 10000000000000000n },
  { name: "Light Gray", color: "#d0d0d0", value: 100000000000000000n },
];
const tier3Cubes = [
  { name: "Dark Green", color: "#0a5f38", value: 1000000000000000000n }, // 1QI
  { name: "Dark Blue", color: "#1a4d7a", value: 10000000000000000000n }, // 10QI
  { name: "Indigo", color: "#4b0082", value: 100000000000000000000n }, // 100QI
  { name: "Dark Yellow", color: "#9b870c", value: 1000000000000000000000n }, // 1SX
  { name: "Dark Orange", color: "#cc5500", value: 10000000000000000000000n }, // 10SX
  { name: "Dark Purple", color: "#5a1d5a", value: 100000000000000000000000n }, // 100SX
  { name: "Dark Red", color: "#8b0000", value: 1000000000000000000000000n }, // 1SP âœ…
  { name: "Neon Green", color: "#39ff14", value: 10000000000000000000000000n }, // 10SP âœ…
];
const tier4Cubes = [
  { name: "Leafy Green", color: "#7cb342", value: 100000000000000000000000000n }, // 100SP âœ…
  { name: "Aquamarine", color: "#7fffd4", value: 1000000000000000000000000000n }, // 1OC âœ…
  { name: "Noir", color: "#0a0a0a", value: 10000000000000000000000000000n }, // 10OC âœ…
  { name: "Bright Orange", color: "#ff9500", value: 100000000000000000000000000000n }, // 100OC âœ…
  { name: "Sunny Orange", color: "#ffcc33", value: 1000000000000000000000000000000n }, // 1NO âœ…
  { name: "Pink", color: "#ff69b4", value: 10000000000000000000000000000000n }, // 10NO âœ…
  { name: "Dark Brown", color: "#5c4033", value: 100000000000000000000000000000000n }, // 1DC âœ…
  { name: "Neon Blue", color: "#1b03a3", value: 1000000000000000000000000000000000n }, // 10DC âœ…
];

const incomeRates = {
  // Tier 1
  "Green": 2n, "Blue": 20n, "Black": 200n, "Yellow": 2000n, 
  "Orange": 20000n, "Purple": 200000n, "Red": 2000000n, "White": 20000000n,
  // Tier 2
  "Light Green": 200000000n, "Light Blue": 2000000000n, "Dark Grey": 20000000000n,
  "Light Yellow": 200000000000n, "Light Orange": 2000000000000n, "Light Purple": 20000000000000n,
  "Light Red": 200000000000000n, "Light Gray": 2000000000000000n,
  // Tier 3
  "Dark Green": 20000000000000000n, "Dark Blue": 200000000000000000n, "Indigo": 2000000000000000000n,
  "Dark Yellow": 20000000000000000000n, "Dark Orange": 200000000000000000000n, 
  "Dark Purple": 2000000000000000000000n, "Dark Red": 20000000000000000000000n,
  "Neon Green": 200000000000000000000000n,
  // Tier 4
  "Leafy Green": 2000000000000000000000000n, "Aquamarine": 20000000000000000000000000n,
  "Noir": 200000000000000000000000000n, "Bright Orange": 2000000000000000000000000000n,
  "Sunny Orange": 20000000000000000000000000000n, "Pink": 200000000000000000000000000000n,
  "Dark Brown": 2000000000000000000000000000000n, "Neon Blue": 20000000000000000000000000000000n,
};

function computeCubePositions() {
  const totalWidth = (CUBE_COUNT * CUBE_SIZE) + ((CUBE_COUNT - 1) * CUBE_SPACING);
  const startX = Math.round((W - totalWidth) / 2);
  const arr = [];
  for (let i = 0; i < CUBE_COUNT; i++) {
    arr.push({ x: startX + i * (CUBE_SIZE + CUBE_SPACING), y: TOP_Y, w: CUBE_SIZE, h: CUBE_SIZE });
  }
  return arr;
}
const cubePositions = computeCubePositions();
function currentCubes() {
  if (cubeTier === 0) return tier1Cubes;
  if (cubeTier === 1) return tier2Cubes;
  if (cubeTier === 2) return tier3Cubes;
  return tier4Cubes;
}
function buildCubes() { return currentCubes().map((c, i) => ({ ...c, pos: cubePositions[i], visible: true })); }

let cubes = buildCubes();

// const character = { x: W / 2 - CUBE_SIZE / 2, y: H / 2 - CUBE_SIZE / 2, w: CUBE_SIZE, h: CUBE_SIZE, color: "#ff2b2b", speed: 250, target: null, assignedName: null, assignedValue: 0n };
const character = {
  x: W / 2 - CUBE_SIZE / 2,
  y: H / 2 - CUBE_SIZE / 2,
  w: CUBE_SIZE,
  h: CUBE_SIZE,
  color: skins[equippedSkinSpecial].color,
  speed: 250,
  target: null,
  assignedName: null,
  assignedValue: 0n,
  hasSword: false,       // Q toggles this
  slashing: false,       // true when space pressed
  slashDuration: 200     // ms duration of slash animation
};

const house = { w: 140, h: 140, x: W - 160, y: H - 160, border: "#ff3b3b" };

let bossDrops = [];

const inventory = {
  "ğŸ¦´ Skeleton Bones": 0,
  "ğŸ“¿ Crossbones Relic": 0,
  "â¬œğŸ’€ Skeleton Skin": 0,
  "â¬œâ˜ ï¸ Crossbones Cube": 0
};

// ğŸ’° Track how many total drops of each type (separate counters)
const dropCounters = {
  "ğŸ¦´ Skeleton Bones": 0,
  "ğŸ“¿ Crossbones Relic": 0,
  "â¬œğŸ’€ Skeleton Skin": 0,
  "â¬œâ˜ ï¸ Crossbones Cube": 0
  //,
  //"bones": 0,
  //"relic": 0,
  //"skin": 0,
  //"cube": 0
};



let money = 1000n, incomePerSec = 0n, houseValue = 0n;

let bossSpawnInterval = 10 * 60 * 1000; // 10 minutes in ms
let nextBossSpawn = Date.now() + bossSpawnInterval;

const legendCounts = {};
[...tier1Cubes, ...tier2Cubes, ...tier3Cubes, ...tier4Cubes].forEach(c => legendCounts[c.name] = 0n);
let insideHouse = false;

// === ğŸ›’ SHOP CONFIGURATION ===
const shopItems = {
  Swords: [
    { icon: "âš”ï¸", price: 100_000_000n, name: "Iron Sword", limit: 1, special: 2 },
    { icon: "ğŸ—¡ï¸", price: 100_000_000_000n, name: "Steel Sword", limit: 1, special: 3 },
    { icon: "ğŸ’", price: 10_000_000_000_000n, name: "Crystal Sword", limit: 1, special: 4 },
    { icon: "ğŸ”¥", price: 100_000_000_000_000_000n, name: "Flame Blade", limit: 1, special: 3 },
    { icon: "âš¡", price: 100_000_000_000_000_000_000n, name: "Thunder Edge", limit: 1, special: 5 },
    { icon: "ğŸ†", price: 999_999_999_999_999_999_999_999_999_999_999n, name: "Golden Sword", limit: 1, special: 6, rebirthLocked: 9 }, // NEW
  ],
  // ... rest of shop items
  Relics: [
    { icon: "ğŸ“¿", price: 100_000_000n, name: "Relic of Light", limit: 1, special: 1.1 },
    { icon: "ğŸª¶", price: 100_000_000_000n, name: "Relic of Wind", limit: 1, special: 1.15 },
    { icon: "ğŸ’€", price: 100_000_000_000_000n, name: "Relic of Death", limit: 1, special: 1.20 },
    { icon: "ğŸŒ™", price: 1_000_000_000_000_000_000n, name: "Relic of Night", limit: 1, special: 1.25 },
    { icon: "â˜€ï¸", price: 100_000_000_000_000_000_000n, name: "Relic of Sun", limit: 1, special: 1.30 },
  ],
  Eggs: [
    { icon: "ğŸ¥š", price: 100_000_000n, name: "Basic Egg", limit: 999, special: 1 },
    { icon: "ğŸ£", price: 100_000_000_000n, name: "Rare Egg", limit: 999, special: 1 },
    { icon: "ğŸ‰", price: 100_000_000_000_000n, name: "Dragon Egg", limit: 999, special: 1 },
    { icon: "âœ¨", price: 1_000_000_000_000_000_000n, name: "Mythic Egg", limit: 999, special: 1 },
    { icon: "ğŸªº", price: 10_000_000_000_000_000_000_000n, name: "Celestial Egg", limit: 999, special: 1 },
  ],
  Skins: [
    { icon: "ğŸŸ¥", price: 1_000_000_000n, name: "Red Skin", limit: 1, special: 1 },
    { icon: "ğŸŸ¦", price: 1_000_000_000_000n, name: "Blue Skin", limit: 1, special: 2 },
    { icon: "ğŸŸª", price: 1_000_000_000_000_000n, name: "Purple Skin", limit: 1, special: 3 },
    { icon: "ğŸŸ¨", price: 10_000_000_000_000_000_000n, name: "Gold Skin", limit: 1, special: 4 },
    { icon: "â¬œ", price: 1_000_000_000_000_000_000_000n, name: "Diamond Skin", limit: 1, special: 5 },
  ],
  Potions: [
    { icon: "ğŸ§ª", price: 1_000_000n, name: "Health Potion", limit: 999, special: 2 },
    { icon: "ğŸ’Š", price: 10_000_000_000n, name: "Energy Potion", limit: 999, special: 3 },
    { icon: "âš—ï¸", price: 100_000_000_000_000n, name: "Alchemy Potion", limit: 999, special: 4 },
    { icon: "ğŸ§‰", price: 1_000_000_000_000_000_000n, name: "Mystic Potion", limit: 999, special: 5 },
    { icon: "ğŸ¥¤", price: 10_000_000_000_000_000_000_000n, name: "Divine Potion", limit: 999, special: 6 },
  ]
};
// === PET SYSTEM CONFIGURATION ===
const petDatabase = {
  "Basic Egg": [
    { name: "Blue Cube", color: "#3b8ebf", icon: "ğŸŸ¦", ability: "passive_income", value: 1.05, chance: 0.40, description: "+5% income" },
    { name: "Orange Cube", color: "#ff8a2b", icon: "ğŸŸ§", ability: "speed_boost", value: 1.10, chance: 0.30, description: "+10% speed" },
    { name: "Purple Cube", color: "#8b3bff", icon: "ğŸŸª", ability: "purple_spawn", value: 1.20, chance: 0.15, description: "Spawns purple cube (5min)" },
    { name: "Green Cube", color: "#3bbf6e", icon: "ğŸŸ©", ability: "cube_grabber", value: 1, chance: 0.10, description: "Grabs random cube (15min)" },
    { name: "Yellow Cube", color: "#e6d44a", icon: "ğŸŸ¨", ability: "day_trigger", value: 0.10, chance: 0.04, description: "Triggers day event (5min)" },
    { name: "Red Cube", color: "#c53030", icon: "ğŸŸ¥", ability: "ember_mutator", value: 0.10, chance: 0.01, description: "Mutates pets with Ember (30min)" }
  ],
  "Rare Egg": [
    { name: "Light Green Cube", color: "#9be6b8", icon: "ğŸŸ©âœ¨", ability: "double_damage", value: 2, chance: 0.50, description: "2x sword damage" },
    { name: "Light Purple Cube", color: "#d8b8ff", icon: "ğŸŸªâœ¨", ability: "passive_income", value: 1.15, chance: 0.30, description: "+15% income" },
    { name: "Light Yellow Cube", color: "#fff1a8", icon: "ğŸŸ¨âœ¨", ability: "shooting_star", value: 0.40, chance: 0.10, description: "Spawns shooting star (15min)" },
    { name: "Light Orange Cube", color: "#ffc89b", icon: "ğŸŸ§âœ¨", ability: "boss_spawn", value: 0.15, chance: 0.05, description: "Spawns boss (15min)" },
    { name: "Light Blue Cube", color: "#9bd3e6", icon: "ğŸŸ¦âœ¨", ability: "glitch_mutator", value: 0.05, chance: 0.045, description: "Mutates with Glitched (10min)" },
    { name: "Light Red Cube", color: "#ffb8b8", icon: "ğŸŸ¥âœ¨", ability: "ability_copy", value: 1, chance: 0.005, description: "Copies nearby pet ability (20min)" }
  ],
  "Dragon Egg": [
    { name: "Dark Yellow Cube", color: "#9b870c", icon: "ğŸŸ¨ğŸ’", ability: "egg_giver", value: 0.20, chance: 0.55, description: "Gives random egg (70s)" },
    { name: "Dark Orange Cube", color: "#cc5500", icon: "ğŸŸ§ğŸ’", ability: "money_doubler", value: 0.10, chance: 0.20, description: "Doubles money (5min)" },
    { name: "Dark Blue Cube", color: "#1a4d7a", icon: "ğŸŸ¦ğŸ’", ability: "double_damage", value: 2, chance: 0.15, description: "2x sword damage" },
    { name: "Dark Purple Cube", color: "#5a1d5a", icon: "ğŸŸªğŸ’", ability: "entity_spawner", value: 1, chance: 0.05, description: "Spawns random entity (15min)" },
    { name: "Dark Green Cube", color: "#0a5f38", icon: "ğŸŸ©ğŸ’", ability: "glitch_event", value: 0.02, chance: 0.049, description: "Starts Glitch event (5min)" },
    { name: "Dark Red Cube", color: "#8b0000", icon: "ğŸŸ¥ğŸ’", ability: "weather_trigger", value: 0.10, chance: 0.001, description: "Random weather (10min)" }
  ],
  "Mythic Egg": [
    { name: "Teal Cube", color: "#008080", icon: "ğŸ”·", ability: "bone_giver", value: 1, chance: 0.60, description: "Gives skeleton bone (10min)" },
    { name: "Indigo Cube", color: "#4b0082", icon: "ğŸŸ£", ability: "blackhole_event", value: 0.10, chance: 0.30, description: "Starts Blackhole (5min)" },
    { name: "Neon Green Cube", color: "#39ff14", icon: "ğŸŸ¢", ability: "cycle_changer", value: 0.60, chance: 0.098, description: "Changes day/night cycle (3min)" },
    { name: "Neon Blue Cube", color: "#1b03a3", icon: "ğŸ”µ", ability: "timer_reducer", value: 5, chance: 0.002, description: "Reduces all timers -5min" }
  ],
  "Celestial Egg": [
   
    { name: "Aquamarine Cube", color: "#7fffd4", icon: "ğŸ’ ", ability: "earthquake_event", value: 0.30, chance: 0.20, description: "Starts Earthquake (10min)" },
    { name: "Bright Orange Cube", color: "#ff9500", icon: "ğŸŸ ", ability: "random_event", value: 1, chance: 0.15, description: "Random event (5min)" },
    { name: "Sunny Orange Cube", color: "#ffcc33", icon: "â˜€ï¸", ability: "passive_income", value: 1.30, chance: 0.10, description: "+30% income" },
   { name: "Noir Cube", color: "#0a0a0a", icon: "â¬›", ability: "night_bonus", value: 1.50, chance: 0.9, description: "+50% income at night" },
    { name: "Celestial Blue Cube", color: "#4169E1", icon: "ğŸŒŒ", ability: "galactic_event", value: 1, chance: 0.001, description: "Starts Galactic event (5min)" }
  ]
};

const petMutations = {
  "Wet": { color: "#4da6ff", emoji: "ğŸ’§", incomeBoost: 1.05, event: "Rain" },
  "Shocked": { color: "#ffff00", emoji: "âš¡", incomeBoost: 1.10, event: "Thunder" },
  "Disco": { color: "#ff00ff", emoji: "ğŸª©", incomeBoost: 1.20, event: "Disco" },
  "Ember": { color: "#ff4400", emoji: "ğŸ”¥", incomeBoost: 1.30, event: "Volcano" },
  "Glitched": { color: "#00ff00", emoji: "âšœï¸", incomeBoost: 1.35, event: "Glitched" },
  "Galactic": { color: "#4a0080", emoji: "ğŸš€", incomeBoost: 1.40, event: "Galactic" }
};

let playerPets = []; // Array of pet objects
let equippedPets = []; // Max 3 pets that follow character
let petTimers = {}; // Track ability cooldowns
// Open an egg and get a random pet
function openEgg(eggType) {
  const pets = petDatabase[eggType];
  if (!pets) {
    console.error("Unknown egg type:", eggType);
    return null;
  }
  
  const roll = Math.random();
  let cumulative = 0;
  
  for (const pet of pets) {
    cumulative += pet.chance;
    if (roll <= cumulative) {
      // Create pet instance
      const newPet = {
        id: Date.now() + Math.random(), // unique ID
        name: pet.name,
        color: pet.color,
        icon: pet.icon,
        ability: pet.ability,
        abilityValue: pet.value,
        description: pet.description,
        eggType: eggType,
        mutation: null,
        equipped: false,
        offsetAngle: 0, // for positioning around character
        x: character.x,
        y: character.y
      };
      
      // Check for mutation during active event
      if (Math.random() < 0.10) { // 10% mutation chance during events
        if (currentAdminEvent) {
          const eventName = currentAdminEvent.name;
          for (const [mutName, mutData] of Object.entries(petMutations)) {
            if (mutData.event === eventName) {
              newPet.mutation = mutName;
              console.log(`ğŸ‰ Pet mutated with ${mutName}!`);
              break;
            }
          }
        } else if (currentWeather) {
          for (const [mutName, mutData] of Object.entries(petMutations)) {
            if (mutData.event === currentWeather) {
              newPet.mutation = mutName;
              console.log(`ğŸ‰ Pet mutated with ${mutName}!`);
              break;
            }
          }
        }
      }
      
      playerPets.push(newPet);
      console.log(`ğŸ¥š Hatched: ${pet.name} from ${eggType}!`);
      return newPet;
    }
  }
  
  return null;
}
// Open multiple eggs from inventory
function openEggFromInventory(eggName, count) {
  const eggItem = playerInventory.Eggs.find(i => i.name === eggName);
  if (!eggItem || eggItem.count < count) {
    alert(`Not enough ${eggName}s!`);
    return;
  }
  
  let results = [];
  
  for (let i = 0; i < count; i++) {
    if (eggItem.count > 0) {
      eggItem.count--;
      const pet = openEgg(eggName);
      if (pet) {
        const mutationText = pet.mutation ? ` [${petMutations[pet.mutation].emoji}]` : '';
        results.push(`${pet.icon} ${pet.name}${mutationText}`);
      }
    }
  }
  
  // Remove egg from inventory if count reaches 0
  if (eggItem.count === 0) {
    const index = playerInventory.Eggs.indexOf(eggItem);
    if (index > -1) {
      playerInventory.Eggs.splice(index, 1);
    }
  }
  
  updateInventoryDisplay();
  
  if (results.length > 0) {
    alert(`ğŸ‰ Hatched ${count} ${eggName}(s)!\n\n${results.join('\n')}`);
  }
}

// Make function globally accessible
window.openEggFromInventory = openEggFromInventory;
// Display pet odds for an egg type
function showEggOdds(eggType) {
  const pets = petDatabase[eggType];
  if (!pets) {
    return "Unknown egg type";
  }
  
  let oddsText = `ğŸ¥š ${eggType} Contents:\n\n`;
  
  pets.forEach(pet => {
    const percentage = (pet.chance * 100).toFixed(2);
    oddsText += `${pet.icon} ${pet.name}\n`;
    oddsText += `   ${pet.description}\n`;
    oddsText += `   Chance: ${percentage}%\n\n`;
  });
  
  return oddsText;
}
// Equip/unequip a pet
function togglePetEquip(petId) {
  const pet = playerPets.find(p => p.id === petId);
  if (!pet) return;
  
  if (pet.equipped) {
    // Unequip
    pet.equipped = false;
    equippedPets = equippedPets.filter(p => p.id !== petId);
  } else {
    // Check max equipped limit (now dynamic based on rebirths)
    if (equippedPets.length >= maxPetSlots) {
      alert(`âš ï¸ Maximum ${maxPetSlots} pets can be equipped at once!`);
      return;
    }
    
    // Equip
    pet.equipped = true;
    pet.offsetAngle = equippedPets.length * (Math.PI * 2 / maxPetSlots); // Spread evenly
    equippedPets.push(pet);
  }
  
  recomputeIncome(); // Recalculate with pet bonuses
  updateInventoryDisplay();
}

// Delete a pet
function deletePet(petId) {
  if (!confirm("âš ï¸ Are you sure you want to delete this pet?")) return;
  
  const index = playerPets.findIndex(p => p.id === petId);
  if (index === -1) return;
  
  const pet = playerPets[index];
  
  // Remove from equipped if needed
  if (pet.equipped) {
    equippedPets = equippedPets.filter(p => p.id !== petId);
  }
  
  // Remove from all pets
  playerPets.splice(index, 1);
  
  recomputeIncome();
  updateInventoryDisplay();
}
// Bulk delete all unequipped pets
function bulkDeletePets() {
  const unequippedCount = playerPets.filter(p => !p.equipped).length;
  
  if (unequippedCount === 0) {
    alert("âš ï¸ No unequipped pets to delete!");
    return;
  }
  
  if (!confirm(`âš ï¸ Delete ${unequippedCount} unequipped pet(s)?\n\nThis cannot be undone!`)) {
    return;
  }
  
  // Remove all unequipped pets
  playerPets = playerPets.filter(p => p.equipped);
  
  // Clean up timers
  const validPetIds = new Set(playerPets.map(p => p.id));
  for (let petId in petTimers) {
    if (!validPetIds.has(Number(petId))) {
      delete petTimers[petId];
    }
  }
  
  recomputeIncome();
  updateInventoryDisplay();
  
  alert(`âœ… Deleted ${unequippedCount} unequipped pet(s)!`);
}

// Make function globally accessible
window.bulkDeletePets = bulkDeletePets;
// Initialize pet timers
function initPetTimers() {
  playerPets.forEach(pet => {
    if (!petTimers[pet.id]) {
      petTimers[pet.id] = {
        lastTrigger: Date.now(),
        cooldown: getPetCooldown(pet.ability)
      };
    }
  });
}
// Filter pets by search query
// Advanced filter pets with multiple criteria
function filterPets(searchQuery) {
  const query = searchQuery.toLowerCase().trim();
  const petItems = document.querySelectorAll('.pet-item');
  
  if (!query) {
    // Show all pets if search is empty
    petItems.forEach(item => {
      item.style.display = '';
    });
    return;
  }
  
  let foundCount = 0;
  
  // Check for special filter commands
  const isEquippedFilter = query === 'equipped' || query === 'equip';
  const isUnequippedFilter = query === 'unequipped' || query === 'unequip';
  const isMutatedFilter = query === 'mutated' || query === 'mutation';
  
  petItems.forEach(item => {
    const petName = item.getAttribute('data-pet-name');
    const petAbility = item.getAttribute('data-pet-ability');
    const petMutation = item.getAttribute('data-pet-mutation');
    const isEquipped = item.innerHTML.includes('âœ“ Equipped');
    const hasMutation = petMutation !== '';
    
    let matches = false;
    
    // Special filters
    if (isEquippedFilter) {
      matches = isEquipped;
    } else if (isUnequippedFilter) {
      matches = !isEquipped;
    } else if (isMutatedFilter) {
      matches = hasMutation;
    } else {
      // Normal search: name, ability, or mutation
      matches = petName.includes(query) || 
                petAbility.includes(query) || 
                petMutation.includes(query);
    }
    
    if (matches) {
      item.style.display = '';
      foundCount++;
    } else {
      item.style.display = 'none';
    }
  });
  
  // Show count in console for debugging
  console.log(`Found ${foundCount} pet(s) matching "${searchQuery}"`);
}
// Get cooldown for pet ability (in milliseconds)
function getPetCooldown(ability) {
  const cooldowns = {
    "purple_spawn": 5 * 60 * 1000,
    "cube_grabber": 15 * 60 * 1000,
    "day_trigger": 5 * 60 * 1000,
    "ember_mutator": 30 * 60 * 1000,
    "shooting_star": 15 * 60 * 1000,
    "boss_spawn": 15 * 60 * 1000,
    "glitch_mutator": 10 * 60 * 1000,
    "ability_copy": 20 * 60 * 1000,
    "egg_giver": 70 * 1000,
    "money_doubler": 5 * 60 * 1000,
    "entity_spawner": 15 * 60 * 1000,
    "glitch_event": 5 * 60 * 1000,
    "weather_trigger": 10 * 60 * 1000,
    "bone_giver": 10 * 60 * 1000,
    "blackhole_event": 5 * 60 * 1000,
    "cycle_changer": 3 * 60 * 1000,
    "timer_reducer": 999 * 60 * 1000,
    "rain_event": 5 * 60 * 1000,
    "earthquake_event": 10 * 60 * 1000,
    "random_event": 5 * 60 * 1000,
    "galactic_event": 5 * 60 * 1000,
    // NEW EVENT PET ABILITIES
    "day_income_boost": 999 * 60 * 1000,    // Passive
    "day_speed_boost": 999 * 60 * 1000,     // Passive
    "ember_giver": 10 * 60 * 1000,          // 10 min
    "night_income_boost": 999 * 60 * 1000,  // Passive
    "night_speed_boost": 999 * 60 * 1000,   // Passive
    "cooldown_reducer": 999 * 60 * 1000,    // Passive
    "mutation_giver": 5 * 60 * 1000         // 5 min
  };
  
  return cooldowns[ability] || 60000;
}
// === EVENT SHOP CONFIGURATION ===
const eventShops = {
  "day": {
    displayName: "â˜€ï¸ Sunny Shop",
    activeWhen: () => dayNightCycle.current === "day",
    items: {
      Swords: [
        { icon: "â˜€ï¸ğŸ—¡ï¸", price: 1_000_000_000_000n, name: "Sunny Sword", limit: 1, special: 3, description: "3 damage" }
      ],
      Relics: [
        { icon: "â˜€ï¸ğŸ“¿", price: 50_000_000_000_000n, name: "Sunny Relic", limit: 1, special: 1.18, description: "1.18x money" }
      ],
      Eggs: [
        { icon: "â˜€ï¸ğŸ¥š", price: 1_000_000_000_000_000n, name: "Sunny Egg", limit: 999, special: 1, description: "3 Sunny Pets" }
      ],
      Skins: [
        { icon: "â˜€ï¸ğŸ’", price: 100_000_000_000_000_000n, name: "Sunny Skin", limit: 1, special: 6, description: "#FFF917" }
      ],
      Potions: [
        { icon: "â˜€ï¸ğŸ§ª", price: 10_000_000_000_000_000_000n, name: "Sunny Potion", limit: 999, special: 5.1, description: "5.1x income" }
      ]
    }
  },
  "night": {
    displayName: "ğŸŒ™ Night Shop",
    activeWhen: () => dayNightCycle.current === "night",
    items: {
      Swords: [
        { icon: "ğŸŒ™ğŸ—¡ï¸", price: 1_000_000_000_000_000n, name: "Night Sword", limit: 1, special: 4, description: "4 damage" }
      ],
      Relics: [
        { icon: "ğŸŒ™ğŸ“¿", price: 10_000_000_000_000_000_000_000n, name: "Dark Relic", limit: 1, special: 1.6, description: "1.6x money" }
      ],
      Eggs: [
        { icon: "ğŸŒ™ğŸ¥š", price: 1_000_000_000_000_000_000_000_000n, name: "Night Egg", limit: 999, special: 1, description: "4 Night Pets" }
      ],
      Skins: [
        { icon: "ğŸŒ™ğŸ’", price: 100_000_000_000_000_000_000_000_000_000_000n, name: "Night Skin", limit: 1, special: 7, description: "#312F36" }
      ],
      Potions: [
        { icon: "ğŸŒ™ğŸ§ª", price: 100_000_000_000_000_000_000_000n, name: "Night Potion", limit: 999, special: 7, description: "7x income" }
      ]
    }
  }
};

// Add new pets to database
petDatabase["Sunny Egg"] = [
  { name: "Sunny Yellow Cube", color: "#FFF917", icon: "â˜€ï¸ğŸŸ¨", ability: "day_income_boost", value: 1.20, chance: 0.60, description: "+20% income during day" },
  { name: "Red Orange Cube", color: "#FF6B35", icon: "ğŸŸ§â˜€ï¸", ability: "day_speed_boost", value: 1.30, chance: 0.39, description: "+30% speed during day" },
  { name: "Sunny Red Cube", color: "#FF4500", icon: "ğŸŸ¥â˜€ï¸", ability: "ember_giver", value: 1, chance: 0.01, description: "Gives Ember mutation (10min)" }
];

petDatabase["Night Egg"] = [
  { name: "Onyx Cube", color: "#0a0a0a", icon: "â¬›ğŸŒ™", ability: "night_income_boost", value: 1.30, chance: 0.50, description: "+30% income during night" },
  { name: "Crow Cube", color: "#1c1c1c", icon: "ğŸ¦â€â¬›", ability: "night_speed_boost", value: 1.40, chance: 0.40, description: "+40% speed during night" },
  { name: "Coal Cube", color: "#3d3d3d", icon: "ğŸª¨", ability: "cooldown_reducer", value: 0.10, chance: 0.099, description: "-10% cooldowns for pets" },
  { name: "Obsidian Cube", color: "#000000", icon: "ğŸ’ğŸŒ™", ability: "mutation_giver", value: 1, chance: 0.001, description: "Random mutations (5min)" }
];

// Add new skins
skins[6] = { color: "#FFF917" }; // Sunny
skins[7] = { color: "#312F36" }; // Night
// Make pet functions globally accessible
window.togglePetEquip = togglePetEquip;
window.deletePet = deletePet;
const playerInventory = {
  Swords: [],
  Relics: [],
  Eggs: [],
  Skins: [],
  Potions: []
};

// === ğŸ¦´ DROP LIMITS ===
const dropLimits = {
  bones: 999,
  relic: 1,
  skin: 1,
  cube: 1
};



// Buy items from event shops
function buyEventItem(eventKey, category, item) {
  const limit = (category === "Eggs" || category === "Potions") ? 999n : 1n;
  const inventoryKey = item.name;
  const owned = BigInt(inventory[inventoryKey] || 0n);

  if (owned >= limit) {
    alert(`You already own the maximum number of ${item.name}s!`);
    return;
  }

  if (money < item.price) {
    alert(`Not enough money to buy ${item.name}!`);
    return;
  }

  money -= item.price;
  inventory[inventoryKey] = owned + 1n;

  const existing = playerInventory[category].find(i => i.name === item.name);
  if (existing) {
    existing.count++;
  } else {
    playerInventory[category].push({
      icon: item.icon,
      name: item.name,
      count: 1,
      special: item.special
    });
  }

  // Eggs: Open immediately and hatch a pet
  if (category === "Eggs") {
    const pet = openEgg(item.name);
    if (pet) {
      alert(`ğŸ‰ Hatched ${pet.icon} ${pet.name}!\n${pet.description}`);
    }
  }

  updateDisplays();
  updateInventoryDisplay();
  updateShopDisplay();
}



// --- RENDER LEGEND UI ---
function renderLegendUI() {
  legendContainer.innerHTML = "";

  const itemsToShow = insideHouse ? shopItems : currentCubes();

  itemsToShow.forEach(c => {
    const row = document.createElement("div");
    row.className = "legend-row";
    row.innerHTML = `
      <div class="swatch" style="background:${c.color}"></div>
      <div class="legend-label">${insideHouse ? "SHOP: " : ""}${c.name} (${shortLabel(c.value)})</div>
      <div class="counter" id="cnt-${c.name.replace(/\s+/g, "_")}">${insideHouse ? "" : (legendCounts[c.name] || 0n)}</div>
    `;
    legendContainer.appendChild(row);

    // Click handler for shop
    if (insideHouse) {
      row.style.cursor = "pointer";
      row.addEventListener("click", () => {
        if (money >= c.value) {
          money -= c.value;
          alert(`âœ… Purchased ${c.name} for ${formatBigInt(c.value)} money!`);
          updateDisplays();
        } else {
          alert("âŒ Not enough money for ${c.name}");
        }
      });
    }
  });

  // Hide inventory when in shop
  document.getElementById("inventoryList").style.display = insideHouse ? "none" : "block";
}



// --- UPDATE HOUSE DEPOSIT & SHOP SWITCH ---
function checkHouseDeposit() {
  const nowInside = rectsOverlap(character, house);

  if (nowInside && !insideHouse) {
    insideHouse = true;
    document.getElementById("shopContainer").style.display = "block";
    updateShopDisplay(); // This will now show event shops if active

    if (character.assignedValue && money >= character.assignedValue) {
      money -= character.assignedValue;
      houseValue += character.assignedValue;
      legendCounts[character.assignedName] = (legendCounts[character.assignedName] || 0n) + 1n;
      recomputeIncome();
      updateDisplays();
      character.assignedValue = 0n;
      character.assignedName = null;
    }
  } else if (!nowInside && insideHouse) {
    insideHouse = false;
    document.getElementById("shopContainer").style.display = "none";
    renderLegendUI();
  }
}

/**
 * Recomputes the total income per second based on the current legend counts and income rates.
 * Applies the current weather multiplier to the total income.
 * Updates the income display with the new total income per second.
 * @returns {undefined}
 */
function recomputeIncome() {
  incomePerSec = 0n;

  for (let n in legendCounts) {
    incomePerSec += legendCounts[n] * (incomeRates[n] || 0n);
  }

  // === PET BONUSES ===
  let petIncomeMultiplier = 1.0;
  let petSpeedMultiplier = 1.0;
  let petCooldownReduction = 0;
  
  equippedPets.forEach(pet => {
    // Passive income pets
    if (pet.ability === "passive_income") {
      petIncomeMultiplier *= pet.abilityValue;
    }
    
    // Night bonus pet (only active during night)
    if (pet.ability === "night_bonus" && dayNightCycle.current === "night") {
      petIncomeMultiplier *= pet.abilityValue;
    }
    
    // Day income boost (only during day)
    if (pet.ability === "day_income_boost" && dayNightCycle.current === "day") {
      petIncomeMultiplier *= pet.abilityValue;
    }
    
    // Night income boost (only during night)
    if (pet.ability === "night_income_boost" && dayNightCycle.current === "night") {
      petIncomeMultiplier *= pet.abilityValue;
    }
    
    // Speed boost pet
    if (pet.ability === "speed_boost") {
      petSpeedMultiplier *= pet.abilityValue;
    }
    
    // Day speed boost (only during day)
    if (pet.ability === "day_speed_boost" && dayNightCycle.current === "day") {
      petSpeedMultiplier *= pet.abilityValue;
    }
    
    // Night speed boost (only during night)
    if (pet.ability === "night_speed_boost" && dayNightCycle.current === "night") {
      petSpeedMultiplier *= pet.abilityValue;
    }
    
    // Cooldown reducer
    if (pet.ability === "cooldown_reducer") {
      petCooldownReduction += pet.abilityValue; // 10% reduction
    }
    
    // Apply mutation bonuses
    if (pet.mutation) {
      const mut = petMutations[pet.mutation];
      petIncomeMultiplier *= mut.incomeBoost;
    }
  });
  
  // Update character speed with pet bonuses
  character.speed = 250 * petSpeedMultiplier;

  const adminMultiplier = currentAdminEvent ? currentAdminEvent.incomeBoost : 1;
  const totalMultiplier = weatherMultiplier * equippedRelicSpecial * petIncomeMultiplier * (potionActive ? potionMultiplier : 1) * adminMultiplier * rebirthMultiplier;

  const adjustedIncome = BigInt(Math.floor(Number(incomePerSec) * totalMultiplier));
  
  incomePerSec = adjustedIncome;
  
  const shortText = formatBigInt(adjustedIncome);
  const fullText = formatBigInt2(adjustedIncome);

  incomeDisplay.textContent = "Income/sec: " + shortText;
  incomeDisplay.title = fullText;

  if (potionActive) {
    const timeLeft = Math.ceil((potionEndTime - Date.now()) / 1000);
    incomeDisplay.textContent += ` ğŸ§ª(${timeLeft}s)`;
  }
}


/**
 * Triggers a random weather event which affects income and speed.
 * Prevents overlap of weather events by checking if there is a current event.
 * Logs the name of the weather event to the console.
 * Sets the background color of the document body to the weather event's background color.
 * Sets the alpha value of the weather overlay to 0.3.
 * Ends the weather event after its specified duration using setTimeout.
 * @returns {undefined}
 */
function triggerWeatherEvent() {
  if (currentWeather) return;
  const w = weatherEvents[Math.floor(Math.random() * weatherEvents.length)];
  currentWeather = w.name;
  weatherMultiplier = w.incomeBoost;
  speedMultiplier = w.speedBoost;
  document.body.style.background = w.bg;
  weatherOverlayAlpha = 0.3;
  console.log(`ğŸŒ¦ Weather started: ${w.name}`);

  weatherTimer = setTimeout(endWeatherEvent, w.duration);
  startWeatherAnimation(currentWeather);
  updateEventIndicator(); // â† ADD THIS
}

/**
 * Ends the current weather event by resetting its associated multipliers and
 * background style, and logging a message to the console.
 * This function is called automatically after the duration of the weather event.
 * @returns {undefined}
 */
function endWeatherEvent() {
  console.log(`ğŸŒ¤ Weather ended: ${currentWeather}`);
  currentWeather = null;
  weatherMultiplier = 1;
  speedMultiplier = 1;
  document.body.style.background = "linear-gradient(#111,#07101a)";
  weatherOverlayAlpha = 0;

  stopWeatherAnimation();
  updateEventIndicator(); // â† ADD THIS
}


function updateEventIndicator() {
  const indicator = document.getElementById('eventIndicator');
  if (!indicator) return;
  
  // Check for admin event first (higher priority)
  if (currentAdminEvent) {
    const emoji = eventEmojis[currentAdminEvent.name] || "ğŸ®";
    indicator.textContent = emoji;
    indicator.title = `Active: ${currentAdminEvent.name} (+${(currentAdminEvent.incomeBoost - 1) * 100}% income)`;
    return;
  }
  
  // Check for weather event
  if (currentWeather) {
    const emoji = eventEmojis[currentWeather] || "ğŸŒ¤ï¸";
    indicator.textContent = emoji;
    indicator.title = `Active: ${currentWeather} (+${(weatherMultiplier - 1) * 100}% income)`;
    return;
  }
  
  // Show day/night cycle
  const cycle = dayNightCycle[dayNightCycle.current];
  indicator.textContent = cycle.emoji;
  indicator.title = `Current: ${cycle.name}`;
}



function activatePotionEvent(multiplier) {
  potionActive = true;
  potionMultiplier = multiplier;
  potionEndTime = Date.now() + 60000; // 1 minute from now
  
  console.log(`ğŸ§ª Potion activated! ${multiplier}x income for 60 seconds`);
  
  // Find and consume the equipped potion
  const equippedPotion = playerInventory.Potions.find(i => i.equipped);
  if (equippedPotion && equippedPotion.count > 0) {
    equippedPotion.count--;
    
    // If count reaches 0, remove the potion from inventory
    if (equippedPotion.count === 0) {
      const index = playerInventory.Potions.indexOf(equippedPotion);
      if (index > -1) {
        playerInventory.Potions.splice(index, 1);
      }
    }
  }
  
  // Recalculate income with new multiplier
  recomputeIncome();
  
  // Set timeout to end potion effect after 60 seconds
  setTimeout(() => {
    potionActive = false;
    potionMultiplier = 1;
    console.log(`ğŸ§ª Potion effect ended`);
    
    // Unequip the potion - reset button to "Equip" status
    if (playerInventory.Potions) {
      playerInventory.Potions.forEach(i => i.equipped = false);
    }
    equippedPotionSpecial = 1;
    
    // Recalculate income back to normal
    recomputeIncome();
    // Update the UI to show "Equip" button again
    updateInventoryDisplay();
  }, 60000);
  
  // Update inventory display immediately to show reduced count
  updateInventoryDisplay();
}


/**
 * Starts a weather animation based on the given type.
 * The type can be one of "Rain", "Wind", or "Thunder".
 * For "Rain", generates 150 particles with random positions and lengths/speeds.
 * For "Wind", generates 80 particles with random positions and lengths/speeds.
 * For "Thunder", generates a single particle with a flashing effect.
 * @param {string} type - The type of the weather animation to start.
 * @returns {undefined}
 */
function startWeatherAnimation(type) {
  weatherParticles = [];

  if (type === "Rain") {
    for (let i = 0; i < 150; i++) {
      weatherParticles.push({
        x: Math.random() * W,
        y: Math.random() * H,
        len: 10 + Math.random() * 10,
        speed: 300 + Math.random() * 200
      });
    }
  }

  if (type === "Wind") {
    for (let i = 0; i < 80; i++) {
      weatherParticles.push({
        x: Math.random() * W,
        y: Math.random() * H,
        len: 20 + Math.random() * 10,
        speed: 100 + Math.random() * 150
      });
    }
  }

  if (type === "Thunder") {
    weatherParticles.push({ flash: true, alpha: 0 });
  }
}

/**
 * Stops the current weather animation by resetting the weatherParticles array.
 * This function is called automatically after the duration of the weather event.
 * @returns {undefined}
 */
function stopWeatherAnimation() {
  weatherParticles = [];
}

/**
 * Updates the weather animation by moving and/or flashing the weather particles.
 * This function is called continuously by the requestAnimationFrame loop.
 * @param {number} dt - The time elapsed since the last frame in milliseconds.
 * @returns {undefined}
 */
function updateWeatherAnimation(dt) {
  if (!currentWeather) return;

  if (currentWeather === "Rain") {
    for (const p of weatherParticles) {
      p.y += p.speed * dt;
      if (p.y > H) {
        p.y = -p.len;
        p.x = Math.random() * W;
      }
    }
  }

  if (currentWeather === "Wind") {
    for (const p of weatherParticles) {
      p.x += p.speed * dt;
      if (p.x > W) {
        p.x = -p.len;
        p.y = Math.random() * H;
      }
    }
  }

  if (currentWeather === "Thunder") {
    // Random flash effect
    if (Math.random() < 0.005) {
      weatherParticles[0].alpha = 1;
    }
    if (weatherParticles[0].alpha > 0) {
      weatherParticles[0].alpha -= dt * 2;
    }
  }
}
// Update day/night stars
// Update day/night stars and clouds
function updateDayNightAnimation(dt) {
  // Update stars for night and sunrise
  if (dayNightCycle.current === "night" || dayNightCycle.current === "sunrise") {
    dayNightStars.forEach(star => {
      star.twinkle += dt * star.twinkleSpeed;
      if (star.twinkle > 1) star.twinkle = 0;
    });
  }
  
  // Update clouds for sunset and sunrise
  if (dayNightCycle.current === "sunset" || dayNightCycle.current === "sunrise") {
    sunsetClouds.forEach(cloud => {
      cloud.x += cloud.speed * dt;
      if (cloud.x > W + cloud.width) {
        cloud.x = -cloud.width;
        cloud.y = 100 + Math.random() * 150;
      }
    });
  }
}

// === ADMIN ABUSE EVENT FUNCTIONS ===
function triggerAdminEvent(event) {
  if (currentAdminEvent) {
    console.log(`âš ï¸ Admin event ${currentAdminEvent.name} already active, skipping ${event.name}`);
    return;
  }
  
  currentAdminEvent = event;
  document.body.style.background = event.bg;
  adminEventOverlayAlpha = 0.3;
  
  console.log(`ğŸ® Admin Abuse: ${event.name} started! +${(event.incomeBoost - 1) * 100}% income for ${event.duration/1000}s`);
  
  recomputeIncome();
  startAdminAnimation(event.animation);
  updateEventIndicator(); // â† ADD THIS
  
  adminEventTimer = setTimeout(() => endAdminEvent(), event.duration);
}

function endAdminEvent() {
  if (!currentAdminEvent) return;
  
  console.log(`âœ… Admin event ${currentAdminEvent.name} ended`);
  currentAdminEvent = null;
  document.body.style.background = "linear-gradient(#111,#07101a)";
  adminEventOverlayAlpha = 0;
  adminEventShakeX = 0;
  adminEventShakeY = 0;
  
  recomputeIncome();
  stopAdminAnimation();
  updateEventIndicator(); // â† ADD THIS
}

function startAdminAnimation(type) {
  adminEventParticles = [];
  
  switch(type) {
    case "blackhole":
      for (let i = 0; i < 100; i++) {
        adminEventParticles.push({
          angle: Math.random() * Math.PI * 2,
          distance: 200 + Math.random() * 300,
          speed: 50 + Math.random() * 100,
          size: 1 + Math.random() * 2
        });
      }
      break;
      
    case "hurricane":
      for (let i = 0; i < 150; i++) {
        adminEventParticles.push({
          angle: Math.random() * Math.PI * 2,
          distance: Math.random() * Math.max(W, H),
          speed: 100 + Math.random() * 200,
          size: 2 + Math.random() * 3,
          isRain: Math.random() > 0.7
        });
      }
      break;
      
    case "disco":
      for (let i = 0; i < 50; i++) {
        adminEventParticles.push({
          x: Math.random() * W,
          y: Math.random() * H,
          size: 10 + Math.random() * 20,
          hue: Math.random() * 360,
          alpha: 0.5 + Math.random() * 0.5
        });
      }
      break;
      
    case "volcano":
      for (let i = 0; i < 80; i++) {
        adminEventParticles.push({
          x: W / 2 + (Math.random() - 0.5) * 100,
          y: H,
          vx: (Math.random() - 0.5) * 200,
          vy: -300 - Math.random() * 200,
          size: 3 + Math.random() * 5,
          life: 1
        });
      }
      break;
      
    case "glitched":
      // Glitch blocks
      for (let i = 0; i < 30; i++) {
        adminEventParticles.push({
          x: Math.random() * W,
          y: Math.random() * H,
          w: 20 + Math.random() * 100,
          h: 5 + Math.random() * 30
        });
      }
      break;
      
    case "galactic":
      // Stars and planets
      for (let i = 0; i < 100; i++) {
        adminEventParticles.push({
          x: Math.random() * W,
          y: Math.random() * H,
          size: 1 + Math.random() * 3,
          twinkle: Math.random()
        });
      }
      // Add some planets
      for (let i = 0; i < 5; i++) {
        adminEventParticles.push({
          x: Math.random() * W,
          y: Math.random() * H,
          size: 20 + Math.random() * 40,
          isPlanet: true,
          hue: Math.random() * 360
        });
      }
      break;
  }
}

function stopAdminAnimation() {
  adminEventParticles = [];
}

function updateAdminAnimation(dt) {
  if (!currentAdminEvent) return;
  
  const type = currentAdminEvent.animation;
  
  switch(type) {
    case "blackhole":
      adminEventParticles.forEach(p => {
        p.distance -= p.speed * dt;
        if (p.distance < 10) p.distance = 500;
      });
      break;
      
    case "hurricane":
      adminEventParticles.forEach(p => {
        p.angle += p.speed * dt * 0.01;
        if (p.isRain) {
          p.distance += 50 * dt;
          if (p.distance > Math.max(W, H)) p.distance = 0;
        }
      });
      break;
      
    case "disco":
      adminEventParticles.forEach(p => {
        p.hue = (p.hue + 100 * dt) % 360;
      });
      break;
      
    case "volcano":
      adminEventParticles.forEach(p => {
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += 400 * dt; // gravity
        p.life -= dt * 0.5;
        
        if (p.life <= 0) {
          p.x = W / 2 + (Math.random() - 0.5) * 100;
          p.y = H;
          p.vx = (Math.random() - 0.5) * 200;
          p.vy = -300 - Math.random() * 200;
          p.life = 1;
        }
      });
      break;
      
    case "earthquake":
      adminEventShakeX = (Math.random() - 0.5) * 10;
      adminEventShakeY = (Math.random() - 0.5) * 10;
      break;
      
    case "glitched":
      if (Math.random() < 0.1) {
        adminEventParticles.forEach(p => {
          p.x = Math.random() * W;
          p.y = Math.random() * H;
        });
      }
      break;
      
    case "galactic":
      adminEventParticles.forEach(p => {
        if (!p.isPlanet) {
          p.twinkle = (p.twinkle + dt) % 1;
        }
      });
      break;
  }
}

function drawAdminAnimation(ctx) {
  if (!currentAdminEvent) return;
  
  ctx.save();
  
  const type = currentAdminEvent.animation;
  const centerX = W / 2;
  const centerY = H / 2;
  
  switch(type) {
    case "blackhole":
      ctx.fillStyle = "rgba(138,43,226,0.3)";
      ctx.beginPath();
      ctx.arc(centerX, centerY, 50, 0, Math.PI * 2);
      ctx.fill();
      
      adminEventParticles.forEach(p => {
        const x = centerX + Math.cos(p.angle) * p.distance;
        const y = centerY + Math.sin(p.angle) * p.distance;
        ctx.fillStyle = `rgba(200,150,255,${1 - p.distance/500})`;
        ctx.fillRect(x, y, p.size, p.size);
      });
      break;
      
    case "hurricane":
      adminEventParticles.forEach(p => {
        if (p.isRain) {
          const x = centerX + Math.cos(p.angle) * p.distance;
          const y = centerY + Math.sin(p.angle) * p.distance;
          ctx.strokeStyle = "rgba(150,200,255,0.4)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x, y + 10);
          ctx.stroke();
        } else {
          const x = centerX + Math.cos(p.angle) * p.distance;
          const y = centerY + Math.sin(p.angle) * p.distance;
          ctx.strokeStyle = "rgba(255,255,255,0.2)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + Math.cos(p.angle) * 20, y + Math.sin(p.angle) * 20);
          ctx.stroke();
        }
      });
      break;
      
    case "disco":
      adminEventParticles.forEach(p => {
        ctx.fillStyle = `hsla(${p.hue}, 100%, 50%, ${p.alpha})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      });
      break;
      
    case "volcano":
      adminEventParticles.forEach(p => {
        if (p.life > 0) {
          ctx.fillStyle = `rgba(255,${100 + p.life * 150},0,${p.life})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
        }
      });
      break;
      
    case "glitched":
      adminEventParticles.forEach(p => {
        const colors = ['#ff0000', '#00ff00', '#0000ff', '#ff00ff', '#00ffff'];
        ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
        ctx.globalAlpha = 0.3;
        ctx.fillRect(p.x, p.y, p.w, p.h);
      });
      ctx.globalAlpha = 1;
      break;
      
    case "galactic":
      adminEventParticles.forEach(p => {
        if (p.isPlanet) {
          ctx.fillStyle = `hsl(${p.hue}, 70%, 50%)`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
        } else {
          ctx.fillStyle = `rgba(255,255,255,${0.3 + p.twinkle * 0.7})`;
          ctx.fillRect(p.x, p.y, p.size, p.size);
        }
      });
      break;
  }
  
  ctx.restore();
}

// Check for scheduled admin events
function checkScheduledAdminEvents() {
  const now = new Date();
  
  adminAbuseEvents.forEach(event => {
    event.triggers.forEach(trigger => {
      if (!trigger.triggered && trigger.date <= now) {
        trigger.triggered = true;
        triggerAdminEvent(event);
      }
    });
  });
}

// Check every second for scheduled events
setInterval(checkScheduledAdminEvents, 1000);

/**
 * Draws the weather animation based on the current weather type.
 * This function is called continuously by the requestAnimationFrame loop.
 * @param {CanvasRenderingContext2D} ctx - The canvas context to draw on.
 * @returns {undefined}
 */
function drawWeatherAnimation(ctx) {
  if (!currentWeather) return;

  ctx.save();
  if (currentWeather === "Rain") {
    ctx.strokeStyle = "rgba(150,200,255,0.5)";
    ctx.lineWidth = 1.5;
    for (const p of weatherParticles) {
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(p.x, p.y + p.len);
      ctx.stroke();
    }
  }

  if (currentWeather === "Wind") {
    ctx.strokeStyle = "rgba(255,255,255,0.2)";
    ctx.lineWidth = 2;
    for (const p of weatherParticles) {
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(p.x + p.len, p.y);
      ctx.stroke();
    }
  }

  if (currentWeather === "Thunder") {
    const a = weatherParticles[0].alpha;
    if (a > 0) {
      ctx.fillStyle = `rgba(255,255,200,${a})`;
      ctx.fillRect(0, 0, W, H);
    }
  }
  ctx.restore();
}

// Auto every 5 minutes
setInterval(() => {
  if (!currentWeather) triggerWeatherEvent();
}, 300_000);

// Manual trigger with ']'
document.addEventListener("keydown", e => {
  if (e.key === "]") triggerWeatherEvent();
});
// Focus search box with Ctrl+F or Cmd+F
document.addEventListener('keydown', (e) => {
  if ((e.ctrlKey || e.metaKey) && e.key === 'f' && !insideHouse) {
    e.preventDefault(); // Prevent browser search
    const searchInput = document.getElementById('petSearchInput');
    if (searchInput) {
      searchInput.focus();
    }
  }
  
  // Clear search with ESC key
  if (e.key === 'Escape') {
    const searchInput = document.getElementById('petSearchInput');
    if (searchInput && document.activeElement === searchInput) {
      clearPetSearch();
      searchInput.blur();
    }
  }
});
//setInterval(() => { money += incomePerSec; updateDisplays(); }, 1000);
setInterval(() => { 
  money += incomePerSec; 
  updateDisplays(); 
  
  if (potionActive) {
    recomputeIncome(); // Updates the countdown timer every second
  }
}, 1000);

function updateDisplays() {
  moneyDisplay.textContent = "Money: " + formatBigInt(money);  
  moneyDisplay.title = formatBigInt2(money);

  incomeDisplay.textContent = "Income/sec: " + formatBigInt(incomePerSec);
  incomeDisplay.title = formatBigInt2(incomePerSec);
  console.log("Income/Sec-2 " + incomeDisplay.title);

  houseDisplay.textContent = "House value: " + formatBigInt(houseValue);
  houseDisplay.title = formatBigInt2(houseValue);

  if (!insideHouse) { // only update legend counts if NOT inside house
    for (let c of currentCubes()) {
      const el = document.getElementById("cnt-" + c.name.replace(/\s+/g, "_"));
      if (el) el.textContent = legendCounts[c.name].toString();
    }
  }
}

function rectsOverlap(a, b) { return !(a.x + a.w <= b.x || b.x + b.w <= a.x || a.y + a.h <= b.y || b.y + b.h <= a.y); }

function checkCubeCollisions() {
  for (let c of cubes) {
    if (rectsOverlap(character, c.pos)) {
      character.assignedName = c.name;
      character.assignedValue = BigInt(c.value);
      resolveSolidCollision(character, c.pos);
    }
  }
}

function resolveSolidCollision(a, b) {
  const overlapX = Math.min(a.x + a.w - b.x, b.x + b.w - a.x);
  const overlapY = Math.min(a.y + a.h - b.y, b.y + b.h - a.y);
  if (overlapX < overlapY) a.x += (a.x < b.x) ? -overlapX : overlapX;
  else a.y += (a.y < b.y) ? -overlapY : overlapY;
}

function handleSlash() {
  specials.forEach(s => {
    if (s.visible && rectsOverlap({x: character.x-10, y: character.y-10, w: character.w+20, h: character.h+20}, s)) {
      s.visible = false;
      // maybe apply some effect
    }
  });
}

/// WINDOW EVENT LISTENERS
const keys = {};
//window.addEventListener("keydown", e => { if ("wasd".includes(e.key.toLowerCase())) keys[e.key.toLowerCase()] = true; });
window.addEventListener("keydown", e => {
  const key = e.key.toLowerCase();
  if (["w","a","s","d","arrowup","arrowdown","arrowleft","arrowright"].includes(key)) {
    keys[key] = true;
  }

  // Existing code
  if (key === "q") character.hasSword = !character.hasSword;
  if (key === "z" && character.hasSword && !character.slashing) {
    character.slashing = true;
    setTimeout(() => { character.slashing = false; }, character.slashDuration);
  }

  if (e.key === "'") spawnBoss();
  
  // Day/Night cycle controls
  if (e.key === "(") changeDayNightCycle("day", true);
  if (e.key === ")") changeDayNightCycle("night", true);
  
  // DEBUG: Money cheat (backtick key)
  if (e.key === "`") {
    money += 100_000_000_000_000_000_000_000_000_000_000n; // 100DC
    updateDisplays();
    console.log("ğŸ’° DEBUG: Added 100DC money!");
  }

  // === ADMIN ABUSE EVENT TRIGGERS ===
  const adminEvent = adminAbuseEvents.find(evt => evt.key === e.key);
  if (adminEvent) {
    triggerAdminEvent(adminEvent);
  }
});

window.addEventListener("keyup", e => {
  const key = e.key.toLowerCase();
  if (["w","a","s","d","arrowup","arrowdown","arrowleft","arrowright"].includes(key)) {
    keys[key] = false;
  }
});

window.addEventListener("keyup", e => {
  const key = e.key.toLowerCase();
  if ("wasd".includes(key)) keys[key] = false;
});

window.addEventListener("keyup", e => { if ("wasd".includes(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false; });
canvas.addEventListener("mousedown", e => {
  const r = canvas.getBoundingClientRect();
  character.target = { x: e.clientX - r.left - character.w / 2, y: e.clientY - r.top - character.h / 2 };
});
// === TIER SYSTEM BUTTONS ===
function updateTierButtons() {
  upgradeBtn.disabled = (cubeTier >= 3);
  downgradeBtn.disabled = (cubeTier <= 0);
  tierHint.textContent = `Current Tier: ${cubeTier + 1}`;
}
function performRebirth() {
  if (rebirthCount >= rebirthLevels.length) {
    alert("ğŸ‰ You've reached the maximum rebirth level!");
    return;
  }

  const nextRebirth = rebirthLevels[rebirthCount];
  
  // Check if player has enough money
  if (money < nextRebirth.cost) {
    alert(`âŒ Not enough money! Need ${formatBigInt(nextRebirth.cost)}`);
    return;
  }

  // Check if player has enough cubes
  const cubeCount = legendCounts[nextRebirth.requiredCube] || 0n;
  
  if (cubeCount < BigInt(nextRebirth.requiredCount)) {
    // Show all available cubes for debugging
    let availableCubes = "";
    for (let key in legendCounts) {
      if (legendCounts[key] > 0n) {
        availableCubes += `\n${key}: ${legendCounts[key]}`;
      }
    }
    
    alert(`âŒ Need ${nextRebirth.requiredCount} ${nextRebirth.requiredCube} cubes!\nYou have: ${cubeCount}\n\nYour cubes:${availableCubes}`);
    return;
  }

  // Build rewards message
  let rewardsMsg = `ğŸ”„ REBIRTH ${nextRebirth.level}\n\n`;
  rewardsMsg += `Cost: ${formatBigInt(nextRebirth.cost)}\n`;
  rewardsMsg += `Required: ${nextRebirth.requiredCount}x ${nextRebirth.requiredCube}\n\n`;
  rewardsMsg += `Rewards:\n`;
  rewardsMsg += `â€¢ +0.5x Income Multiplier\n`;
  
  if (nextRebirth.petSlotReward) {
    rewardsMsg += `â€¢ +${nextRebirth.petSlotReward} Pet Slot(s)\n`;
  }
  
  if (nextRebirth.goldenSwordReward) {
    rewardsMsg += `â€¢ ğŸ† Golden Sword (6 damage)\n`;
  }
  
  rewardsMsg += `\nâš ï¸ This will reset:\n`;
  rewardsMsg += `- Money â†’ 1K\n`;
  rewardsMsg += `- Income/sec â†’ 0\n`;
  rewardsMsg += `- House Value â†’ 0\n`;
  rewardsMsg += `- All Legend Counts â†’ 0\n\n`;
  rewardsMsg += `Continue?`;

  if (!confirm(rewardsMsg)) {
    return;
  }

  // Perform rebirth
  rebirthCount++;
  rebirthMultiplier += nextRebirth.incomeMultiplier;
  
  // Apply pet slot rewards
  if (nextRebirth.petSlotReward) {
    maxPetSlots += nextRebirth.petSlotReward;
  }
  
  // Give Golden Sword
  if (nextRebirth.goldenSwordReward) {
    const existing = playerInventory.Swords.find(i => i.name === "Golden Sword");
    if (!existing) {
      playerInventory.Swords.push({
        icon: "ğŸ†",
        name: "Golden Sword",
        count: 1,
        special: 6
      });
    }
  }
  
  // Reset everything
  money = 1000n;
  incomePerSec = 0n;
  houseValue = 0n;
  
  // Reset all legend counts
  for (let key in legendCounts) {
    legendCounts[key] = 0n;
  }
  
  // Reset character
  character.assignedValue = 0n;
  character.assignedName = null;
  
  // Recalculate income
  recomputeIncome();
  updateDisplays();
  updateInventoryDisplay();
  updateRebirthUI();
  
  // Auto-save
  saveBtn.click();
  
  // Build completion message
  let completionMsg = `âœ… Rebirth ${rebirthCount} Complete!\n\n`;
  completionMsg += `Income Multiplier: ${rebirthMultiplier}x\n`;
  completionMsg += `Max Pet Slots: ${maxPetSlots}\n`;
  
  if (nextRebirth.goldenSwordReward) {
    completionMsg += `\nğŸ† Golden Sword unlocked in inventory!`;
  }
  
  alert(completionMsg);
}

function updateRebirthUI() {
  rebirthHint.textContent = `Rebirths: ${rebirthCount} (${rebirthMultiplier}x) | Pets: ${maxPetSlots}`;
  
  if (rebirthCount >= rebirthLevels.length) {
    rebirthBtn.textContent = "ğŸ”„ Rebirth (MAX)";
    rebirthBtn.disabled = true;
  } else {
    const nextRebirth = rebirthLevels[rebirthCount];
    rebirthBtn.textContent = `ğŸ”„ Rebirth ${nextRebirth.level}`;
    rebirthBtn.disabled = false;
  }
}
function initializeGame() {
  cubes = buildCubes();
  renderLegendUI();
  updateInventoryDisplay();
  updateDisplays();
  updateTierButtons();
  updateRebirthUI();
  updateEventIndicator(); // â† ADD THIS
  initPetTimers(); // â† ADD THIS LINE
  setTimeout(spawnBoss, 600000);
  specials.forEach(s => setTimeout(() => spawnSpecial(s), randomSpawnInterval(s.respawn)));
}
upgradeBtn.addEventListener("click", () => {
  if (cubeTier < 3) {
    cubeTier++;
    cubes = buildCubes();
    renderLegendUI();
    updateDisplays();
    updateTierButtons();
  }
});

downgradeBtn.addEventListener("click", () => {
  if (cubeTier > 0) {
    cubeTier--;
    cubes = buildCubes();
    renderLegendUI();
    updateDisplays();
    updateTierButtons();
  }
});
rebirthBtn.addEventListener("click", () => {
  performRebirth();
});
// --- SAVE & LOAD PROGRESS ---
const saveBtn = document.getElementById("saveBtn");
const loadBtn = document.getElementById("loadBtn");

saveBtn.addEventListener("click", () => {
  const data = {
    money: money.toString(),
    incomePerSec: incomePerSec.toString(),
    houseValue: houseValue.toString(),
    legendCounts: Object.fromEntries(
      Object.entries(legendCounts).map(([k, v]) => [k, v.toString()])
    ),
    dropCounters,
    playerInventory,
    cubeTier,
    bossDrops,
    rebirthCount,
    rebirthMultiplier,
    maxPetSlots // NEW
  };

  data.equipped = {
    swords: equippedSwordSpecial,
    relics: equippedRelicSpecial,
    eggs: equippedEggSpecial,
    skins: equippedSkinSpecial,
    potions: equippedPotionSpecial
  };
  
  // Save pets and timers
  data.playerPets = JSON.parse(JSON.stringify(playerPets));
  data.petTimers = {};
  for (let petId in petTimers) {
    data.petTimers[petId] = {
      lastTrigger: petTimers[petId].lastTrigger,
      cooldown: petTimers[petId].cooldown
    };
  }
  
  localStorage.setItem("cubeGameSave", JSON.stringify(data));
  alert("âœ… Progress Saved!");
});


loadBtn.addEventListener("click", () => {
  const raw = localStorage.getItem("cubeGameSave");
  if (!raw) return alert("âš ï¸ No saved game found.");

  if (!confirm("âš ï¸ Are you sure you want to load your previous save? All unsaved progress will be lost.")) {
    return;
  }

  try {
    const data = JSON.parse(raw);
    money = BigInt(data.money);
    incomePerSec = BigInt(data.incomePerSec);
    houseValue = BigInt(data.houseValue);
    for (let k in data.legendCounts) legendCounts[k] = BigInt(data.legendCounts[k]);
    cubeTier = data.cubeTier || 0;
    
    rebirthCount = data.rebirthCount || 0;
    rebirthMultiplier = data.rebirthMultiplier || 1.0;
    maxPetSlots = data.maxPetSlots || 3; // NEW

    if (data.dropCounters) Object.assign(dropCounters, data.dropCounters);
    if (data.playerInventory) {
      for (let cat in data.playerInventory) {
        playerInventory[cat] = data.playerInventory[cat];
      }
    }

    if (data.equipped) {
      equippedSwordSpecial = data.equipped.swords || 0;
      equippedRelicSpecial = data.equipped.relics || 1;
      equippedEggSpecial = data.equipped.eggs || 0;
      equippedSkinSpecial = data.equipped.skins || 1;
      equippedPotionSpecial = data.equipped.potions || 1;
    }

    if (data.bossDrops) bossDrops = data.bossDrops;
    
    // Load pets properly
    playerPets = [];
    equippedPets = [];
    
    if (data.playerPets && Array.isArray(data.playerPets)) {
      playerPets = data.playerPets;
      equippedPets = playerPets.filter(p => p.equipped);
      console.log(`âœ… Loaded ${playerPets.length} pets (${equippedPets.length} equipped)`);
    }
    
    if (data.petTimers) {
      petTimers = data.petTimers;
    } else {
      petTimers = {};
    }

    cubes = buildCubes();
    renderLegendUI();
    updateDisplays();
    updateInventoryDisplay();
    updateTierButtons();
    updateRebirthUI();
    initPetTimers();
    recomputeIncome();

    alert("âœ… Progress Loaded!");
  } catch (err) {
    console.error(err);
    alert("âŒ Failed to load save data!");
  }
});



// ---- Special Cubes ----
const specials = [
  { name: "teal", color: "teal", emoji: "ğŸ’", duration: 2000, respawn: 15000, effect: c => money += money / 10n },
  { name: "brown", color: "brown", emoji: "ğŸ’€", duration: 5000, respawn: 60000, chase: true, speed: 120, effect: c => money -= money / 10n },
  { name: "yellow", color: "yellow", emoji: "â­", duration: 1000, respawn: 300000, effect: c => money += money * 30n / 100n },
  { name: "scarlet", color: "crimson", emoji: "ğŸ”¥", duration: 15000, respawn: 300000, chase: true, speed: 180, effect: c => money -= money * 30n / 100n },
  { name: "pink", color: "pink", emoji: "ğŸ’–", duration: 1000, respawn: 390000, effect: c => money += money * 50n / 100n },
  { name: "magenta", color: "magenta", emoji: "ğŸ’”", duration: 30000, respawn: 420000, chase: true, speed: 240, effect: c => money -= money * 50n / 100n },
];

const boss = {
  x: 0, y: 0, w: character.w * 1.5, h: character.h * 1.5,
  color: "#3b1f00",
  emoji: "â˜ ï¸",
  visible: false,
  hitsToDie: 10,
  hitsRemaining: 10,
  playerHits: 0,
  speed: character.speed * 1.3,
  aoeRadius: 80,
  spawnX: 0,
  spawnY: 0,
};

// âš¡ Slash effects list
const slashes = [];

function spawnSlash(x, y, angle) {
  slashes.push({
    x, y,
    angle,
    life: 0,          // starts fresh
    maxLife: 15,      // frames before fade out
  });
}

// helper: generate random spawn interval (1Ã— to 1.3Ã— respawn)
function randomSpawnInterval(respawn) {
  return respawn + Math.random() * respawn * 0.3;
}

// spawn special cube at random position avoiding character and cubes
function spawnSpecial(s) {
  // position randomly, avoiding character and cubes
  do {
    s.x = Math.random() * (W - CUBE_SIZE);
    s.y = Math.random() * (H - CUBE_SIZE);
  } while (cubes.some(c => rectsOverlap({ x: s.x, y: s.y, w: CUBE_SIZE, h: CUBE_SIZE }, c.pos)) ||
           rectsOverlap({ x: s.x, y: s.y, w: CUBE_SIZE, h: CUBE_SIZE }, character));

  s.visible = true;

  // hide after duration
  setTimeout(() => {
    s.visible = false;
    // schedule next spawn strictly based on respawn timer
    setTimeout(() => spawnSpecial(s), randomSpawnInterval(s.respawn));
  }, s.duration);
}

// initialize special cubes with first spawn delayed by respawn time
//specials.forEach(s => setTimeout(() => spawnSpecial(s), randomSpawnInterval(s.respawn)));

function spawnBoss() {
  boss.x = Math.random() * (W - boss.w);
  boss.y = Math.random() * (H - boss.h);
  boss.spawnX = boss.x; // save spawn position
  boss.spawnY = boss.y;
  boss.visible = true;
  boss.hitsRemaining = 10;
  boss.playerHits = 0;

  nextBossSpawn = Date.now() + bossSpawnInterval; // reset timer

  // hide boss if not defeated in 30 seconds
  setTimeout(() => {
    if (boss.visible) boss.visible = false;
  }, 60000);
}


// initial spawn timer (10 min after game starts)
//setTimeout(spawnBoss, 600000);


// ---- Update loop handling specials ----
function update(dt) {
  let mx = 0, my = 0;
if (keys.w || keys.arrowup) my -= 1;
if (keys.s || keys.arrowdown) my += 1;
if (keys.a || keys.arrowleft) mx -= 1;
if (keys.d || keys.arrowright) mx += 1;
 updatePets(dt); // â† ADD THIS LINE
  if (mx || my) {
    const len = Math.hypot(mx, my);
    character.x += (mx / len) * character.speed * dt * speedMultiplier;
    character.y += (my / len) * character.speed * dt * speedMultiplier;
  } else if (character.target) {
    const dx = character.target.x - character.x, dy = character.target.y - character.y, dist = Math.hypot(dx, dy);
    if (dist > 2) { 
      character.x += (dx / dist) * character.speed * dt * speedMultiplier; 
      character.y += (dy / dist) * character.speed * dt * speedMultiplier; }
    else character.target = null;
  }

  character.x = Math.max(0, Math.min(W - character.w, character.x));
  character.y = Math.max(0, Math.min(H - character.h, character.y));
updatePets(dt); // â† ADD THIS LINE HERE
  specials.forEach(s => {
    if (s.visible && s.chase) {
      const dx = character.x - s.x, dy = character.y - s.y, dist = Math.hypot(dx, dy);
      if (dist > 1) { s.x += (dx / dist) * (s.speed * dt); s.y += (dy / dist) * (s.speed * dt); 
          if (boss.pauseUntil && Date.now() < boss.pauseUntil) return;        
      }
    }
    if (s.visible && rectsOverlap(s, character)) {
      s.visible = false;
      s.effect();
      updateDisplays();
      // next spawn is already scheduled independently, no need to trigger here
    }
  });

// ğŸ§© Boss movement and attack logic
if (boss.visible) {
  const dx = character.x - boss.x;
  const dy = character.y - boss.y;
  const distance = Math.hypot(dx, dy);

  if (boss.retreating) {
    // Move back to original spawn
    const rx = boss.spawnX - boss.x;
    const ry = boss.spawnY - boss.y;
    const rDist = Math.hypot(rx, ry);
    if (rDist > 2) {
      boss.x += (rx / rDist) * boss.speed * dt * 0.5;
      boss.y += (ry / rDist) * boss.speed * dt * 0.5;
    } else {
      boss.retreating = false; // stop retreating
      boss.pauseUntil = Date.now() + 800; // pause 0.8s before resuming chase

    }
  } else {
    // Normal chasing behavior
    if (distance > 2) {
      boss.x += (dx / distance) * boss.speed * dt * 0.5;
      boss.y += (dy / distance) * boss.speed * dt * 0.5;
    }

    // Attack range check
    if (distance < boss.w * 1.2 && !boss.attackCooldown) {
      boss.attackCooldown = true;
      boss.playerHits++;

      if (boss.playerHits < 3) {
        // First two hits â€” retreat
        boss.retreating = true;
      } else {
        // 3rd hit â€” money penalty and reset
        money = money / 2n;
        boss.visible = false;
        boss.playerHits = 0;
        nextBossSpawn = Date.now() + bossSpawnInterval; // reset timer
      }

      // small cooldown between attacks
      setTimeout(() => (boss.attackCooldown = false), 2000);
    }
  }
}
// ğŸ—¡ï¸ Sword vs Boss collision check
if (boss.visible && character.slashing && !boss.retreating) {
if (boss.hitsRemaining <= 0) {
  boss.visible = false;
  boss.hitsRemaining = boss.hitsToDie;
  boss.playerHits = 0;
  nextBossSpawn = Date.now() + bossSpawnInterval;

  const drops = [];
  if (Math.random() <= 1.0) drops.push("ğŸ¦´ Skeleton Bones");
  if (Math.random() <= 0.30) drops.push("ğŸ“¿ Crossbones Relic");
  if (Math.random() <= 0.05) drops.push("â¬œğŸ’€ Skeleton Skin");
  if (Math.random() <= 0.01) drops.push("â¬œâ˜ ï¸ Crossbones Cube");

  // Store drops visually
  bossDrops.push({ x: boss.x + boss.w/2, y: boss.y, items: drops, timer: 3000, opacity: 1 });

  // Update inventory and drop counters
  drops.forEach(item => {
    if (inventory[item] !== undefined) inventory[item]++;
    if (dropCounters[item] !== undefined) dropCounters[item]++;
    if (!playerInventory["Drops"]) playerInventory["Drops"] = [];
    const existing = playerInventory["Drops"].find(i => i.name === item);
    if (existing) existing.count++;
    else playerInventory["Drops"].push({ icon: "ğŸ“¦", name: item, count: 1 });
  });

  updateInventoryDisplay();
}


  // Define sword attack range in front of the player based on direction of movement
  const swordRange = 40;
  let swordBox = { x: character.x, y: character.y, w: character.w, h: character.h };

  // Check movement keys to infer facing direction
  if (keys.w) swordBox.y -= swordRange;
  else if (keys.s) swordBox.y += swordRange;
  else if (keys.a) swordBox.x -= swordRange;
  else swordBox.x += swordRange;

  swordBox.w += swordRange / 2;
  swordBox.h += swordRange / 2;

  // For debugging (optional)
  // ctx.strokeStyle = "yellow";
  // ctx.strokeRect(swordBox.x, swordBox.y, swordBox.w, swordBox.h);

if (rectsOverlap(swordBox, boss) && !boss.hitCooldown && !boss.retreating) {
  // Calculate pet damage multiplier
  let petDamageMultiplier = 1;
  equippedPets.forEach(pet => {
    if (pet.ability === "double_damage") {
      petDamageMultiplier *= pet.abilityValue;
    }
  });

  // Apply sword special multiplier + pet damage
  const dmg = Math.max(1, Math.floor(equippedSwordSpecial * petDamageMultiplier));
  boss.hitsRemaining -= dmg;

  boss.flash = true;
  spawnSlash(boss.x + boss.w / 2, boss.y + boss.h / 2, Math.random() * Math.PI * 2);

  // Rest of your existing boss retreat code...
  boss.retreating = true;
  boss.invulnerable = true;

  const angle = Math.random() * 2 * Math.PI;
  const distance = 30 + Math.random() * 20;
  const newX = boss.x + Math.cos(angle) * distance;
  const newY = boss.y + Math.sin(angle) * distance;

  const startX = boss.x;
  const startY = boss.y;
  const startTime = performance.now();
  const retreatDuration = 400;

  function retreatAnimation(now) {
    const progress = Math.min((now - startTime) / retreatDuration, 1);
    boss.x = startX + (newX - startX) * progress;
    boss.y = startY + (newY - startY) * progress;

    if (progress < 1) {
      requestAnimationFrame(retreatAnimation);
    } else {
      boss.retreating = false;
      boss.invulnerable = false;
    }
  }
  requestAnimationFrame(retreatAnimation);

  setTimeout(() => (boss.flash = false), 150);
  boss.hitCooldown = true;
  setTimeout(() => (boss.hitCooldown = false), 300);

  // Check if boss is defeated
  if (boss.hitsRemaining <= 0) {
    boss.visible = false;
    boss.hitsRemaining = boss.hitsToDie;
    boss.playerHits = 0;
    nextBossSpawn = Date.now() + bossSpawnInterval;

    const drops = [];
    if (Math.random() <= 1.0) drops.push("ğŸ¦´ Skeleton Bones");
    if (Math.random() <= 0.30) drops.push("ğŸ“¿ Crossbones Relic");
    if (Math.random() <= 0.05) drops.push("â¬œğŸ’€ Skeleton Skin");
    if (Math.random() <= 0.01) drops.push("â¬œâ˜ ï¸ Crossbones Cube");

    bossDrops.push({
      x: boss.x + boss.w / 2,
      y: boss.y,
      items: drops,
      timer: 3000,
      opacity: 1
    });

    drops.forEach(item => {
      if (inventory[item] !== undefined) {
        inventory[item]++;
        dropCounters[item]++;
      }
    });
    updateInventoryDisplay();
  }
}
}


// ğŸ” Update slash effects
for (let i = slashes.length - 1; i >= 0; i--) {
  const s = slashes[i];
  s.life++;
  if (s.life > s.maxLife) slashes.splice(i, 1);
}
// ğŸ”„ Update boss loot fade timers
for (let i = bossDrops.length - 1; i >= 0; i--) {
  const drop = bossDrops[i];
  drop.timer -= dt * 1000; // convert dt seconds â†’ ms
  drop.opacity = Math.max(0, drop.timer / 3000); // fade out over 3s
  if (drop.timer <= 0) bossDrops.splice(i, 1);
}

  checkCubeCollisions();
  checkHouseDeposit();
}


function render() {
  
  
  // Apply earthquake shake
  if (currentAdminEvent && currentAdminEvent.animation === "earthquake") {
    ctx.save();
    ctx.translate(adminEventShakeX, adminEventShakeY);
  }

  ctx.clearRect(0, 0, W, H);
 
  const cycle = dayNightCycle[dayNightCycle.current];
  const gradient = ctx.createLinearGradient(0, 0, 0, H);
  
  const colors = cycle.canvasGradient;
  gradient.addColorStop(0, colors[0]);
  gradient.addColorStop(0.5, colors[1]);
  gradient.addColorStop(1, colors[2]);
  
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, W, H);
  
  // Draw stars at night and during sunrise (fading)
  if (dayNightCycle.current === "night" || dayNightCycle.current === "sunrise") {
    ctx.fillStyle = "white";
    dayNightStars.forEach(star => {
      let alpha = 0.3 + star.twinkle * 0.7;
      
      // Fade out stars during sunrise
      if (dayNightCycle.current === "sunrise") {
        alpha *= 0.4;
      }
      
      ctx.globalAlpha = alpha;
      ctx.fillRect(star.x, star.y, star.size, star.size);
    });
    ctx.globalAlpha = 1;
  }
  
  // Draw clouds during sunset and sunrise
  if (dayNightCycle.current === "sunset" || dayNightCycle.current === "sunrise") {
    sunsetClouds.forEach(cloud => {
      ctx.save();
      ctx.globalAlpha = cloud.opacity;
      
      // Cloud color varies by time
      if (dayNightCycle.current === "sunset") {
        ctx.fillStyle = "#FF6B6B";
      } else {
        ctx.fillStyle = "#FFB347";
      }
      
      // Draw simple cloud shape
      ctx.beginPath();
      ctx.ellipse(cloud.x, cloud.y, cloud.width / 2, cloud.height / 2, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(cloud.x + cloud.width / 3, cloud.y - cloud.height / 3, cloud.width / 3, cloud.height / 3, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(cloud.x - cloud.width / 3, cloud.y - cloud.height / 4, cloud.width / 3, cloud.height / 3, 0, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    });
  }
  
  // Draw celestial body (sun/moon) with appropriate position
  ctx.font = "48px sans-serif";
  ctx.textAlign = "right";
  ctx.textBaseline = "top";
  ctx.fillText(cycle.celestialBody, W - 20, cycle.celestialY);

  ctx.fillStyle = 'rgba(255,255,255,0.02)';
  ctx.fillRect(12, 8, W - 24, 110);

// ... existing rendering code for cubes, house, character ...

renderPets(ctx); // â† ADD THIS LINE

// ... boss rendering and rest of code ...
// ğŸ•’ Boss Timer Display
const now = Date.now();
ctx.fillStyle = 'white';
ctx.font = '16px Arial';
ctx.textAlign = 'left';
ctx.textBaseline = 'top';

if (!boss.visible) {
  const timeLeft = Math.max(0, nextBossSpawn - now);
  const minutes = Math.floor(timeLeft / 60000);
  const seconds = Math.floor((timeLeft % 60000) / 1000);
  ctx.fillText(`Boss in: ${minutes}:${seconds.toString().padStart(2, '0')}`, 20, 20);
} else {
  ctx.fillText(`Boss HP: ${boss.hitsRemaining}/${boss.hitsToDie}`, 20, 20);
  ctx.fillText(`Your HP: ${3 - boss.playerHits}/3`, 20, 40);
}

// Display day/night cycle timer
const timeUntilChange = Math.max(0, dayNightCycle.nextChange - now);
const minutes = Math.floor(timeUntilChange / 60000);
const seconds = Math.floor((timeUntilChange % 60000) / 1000);
const cycleName = dayNightCycle[dayNightCycle.current].name;

ctx.fillStyle = 'white';
ctx.font = '14px Arial';
ctx.textAlign = 'left';
ctx.fillText(`${cycleName} - Next: ${minutes}:${seconds.toString().padStart(2, '0')}`, 20, 60);

cubes.forEach(c => {
  const p = c.pos;
  ctx.fillStyle = c.color;
  ctx.fillRect(p.x, p.y, p.w, p.h);
  ctx.strokeStyle = 'rgba(0,0,0,0.6)';
  ctx.lineWidth = 2;
  ctx.strokeRect(p.x + 0.5, p.y + 0.5, p.w - 1, p.h - 1);
  ctx.fillStyle = (c.color === '#e9ecef' || c.color === '#fff1a8' || c.color === '#ffc89b' || c.color === '#7fffd4' || c.color === '#ffcc33') ? '#111' : '#fff';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  // Custom labels for tier 3 and 4 cubes
  let displayLabel = shortLabel(c.value);
  if (c.name === "Dark Red") displayLabel = "1SP";
  else if (c.name === "Neon Green") displayLabel = "10SP";
  else if (c.name === "Leafy Green") displayLabel = "100SP";
  else if (c.name === "Aquamarine") displayLabel = "1OC";
  else if (c.name === "Noir") displayLabel = "10OC";
  else if (c.name === "Bright Orange") displayLabel = "100OC";
  else if (c.name === "Sunny Orange") displayLabel = "1NO";
  else if (c.name === "Pink") displayLabel = "10NO";
  else if (c.name === "Dark Brown") displayLabel = "100NO";
  else if (c.name === "Neon Blue") displayLabel = "1DC";
  
  ctx.fillText(displayLabel, p.x + p.w / 2, p.y + p.h / 2);


  if (character.hasSword) {
    const swordEmoji =  swordicon ;  //'ğŸ—¡ï¸';
    const centerX = character.x + character.w + 12; // sword center x
    const centerY = character.y + character.h / 2;  // sword center y
    ctx.save();              // save current canvas state
    ctx.translate(centerX, centerY);   // move origin to sword center
    ctx.rotate(Math.PI);     // rotate 180 degrees (Ï€ radians)
    ctx.font = '24px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(swordEmoji, 0, 0);    // draw at new origin
    
          // if slashing, move it slightly forward or up for effect
        if (character.slashing) {
          //ctx.fillText(swordEmoji, character.x + character.w + 24, character.y + character.h/2 - 6);
              ctx.fillText(swordEmoji, -6, 7); // adjust these numbers as needed

        }
        ctx.restore();           // restore canvas state

  }

  });

  ctx.lineWidth = 3;
  ctx.strokeStyle = house.border;
  ctx.setLineDash([6, 6]);
  ctx.strokeRect(house.x + 1, house.y + 1, house.w - 2, house.h - 2);
  ctx.setLineDash([]);
  ctx.fillStyle = 'rgba(255,255,255,0.75)';
  ctx.font = '13px sans-serif';
  ctx.textAlign = 'right';
  ctx.fillText('HOUSE', house.x + house.w - 8, house.y - 6);

  ctx.fillStyle = character.color;
  ctx.fillRect(character.x, character.y, character.w, character.h);
  ctx.strokeStyle = 'rgba(0,0,0,0.6)';
  ctx.strokeRect(character.x + 0.5, character.y + 0.5, character.w - 1, character.h - 1);
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 12px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(character.assignedValue ? shortLabel(character.assignedValue) : 'â€”', character.x + character.w / 2, character.y + character.h / 2);

renderPets(ctx); // â† ADD THIS LINE HERE
  // âš¡ Draw slash effects
slashes.forEach(s => {
  const alpha = 1 - s.life / s.maxLife;
  ctx.save();
  ctx.translate(s.x, s.y);
  ctx.rotate(s.angle);
  ctx.globalAlpha = alpha;
  ctx.strokeStyle = 'white';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(0, 0, 30, 0, Math.PI / 2);
  ctx.stroke();
  ctx.restore();
});
ctx.globalAlpha = 1;


  if (character.assignedName) {
    ctx.font = '11px sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.fillText(character.assignedName, character.x + character.w / 2, character.y - 10);
  }


if (boss.visible) {
  // draw boss
  //ctx.fillStyle = boss.color;
  ctx.fillStyle = boss.flash ? "#a00" : boss.color;
  ctx.fillRect(boss.x, boss.y, boss.w, boss.h);
  ctx.strokeStyle = 'rgba(0,0,0,0.6)';
  ctx.strokeRect(boss.x + 0.5, boss.y + 0.5, boss.w - 1, boss.h - 1);
  ctx.font = '24px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(boss.emoji, boss.x + boss.w / 2, boss.y + boss.h / 2);

  // draw HP bars
  const barWidth = 200;
  ctx.fillStyle = '#222';
  ctx.fillRect(W/2 - barWidth/2, 20, barWidth, 10);
  ctx.fillStyle = '#f33';
  ctx.fillRect(W/2 - barWidth/2, 20, barWidth * (boss.hitsRemaining / boss.hitsToDie), 10);

  ctx.fillStyle = '#fff';
  ctx.font = '12px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(`Boss HP: ${boss.hitsRemaining}/${boss.hitsToDie}`, W/2, 15);

  // player HP bar
  ctx.fillStyle = '#222';
  ctx.fillRect(W/2 - barWidth/2, H - 30, barWidth, 10);
  ctx.fillStyle = '#0f0';
  ctx.fillRect(W/2 - barWidth/2, H - 30, barWidth * ((3 - boss.playerHits)/3), 10);
  ctx.fillStyle = '#fff';
  ctx.fillText(`Player HP: ${3 - boss.playerHits}/3`, W/2, H - 35);
}



  specials.forEach(s => {
    if (!s.visible) return;
    ctx.fillStyle = s.color;
    ctx.fillRect(s.x, s.y, CUBE_SIZE, CUBE_SIZE);
    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
    ctx.strokeRect(s.x + 0.5, s.y + 0.5, CUBE_SIZE - 1, CUBE_SIZE - 1);
    ctx.fillStyle = '#fff';
    ctx.font = '20px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(s.emoji, s.x + CUBE_SIZE / 2, s.y + CUBE_SIZE / 2);
  });
  
  // ğŸ’° Draw Boss Loot Drops
bossDrops.forEach(drop => {
  ctx.save();
  ctx.globalAlpha = drop.opacity;
  ctx.font = '20px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';
  ctx.fillStyle = '#fff';
  drop.items.forEach((item, i) => {
    ctx.fillText(item, drop.x, drop.y - i * 22);
  });  
  ctx.restore();
  });
  
  drawAdminAnimation(ctx);

  // Reset earthquake shake
  if (currentAdminEvent && currentAdminEvent.animation === "earthquake") {
    ctx.restore();
  }
};


let lastTime = performance.now();

function initializeGame() {
  // Build cubes, legend, and UI
  cubes = buildCubes();
  renderLegendUI();
  updateInventoryDisplay();
  updateDisplays();
  updateTierButtons();
  // Schedule boss spawn
  setTimeout(spawnBoss, 600000);

  // Initialize slash list & specials
  specials.forEach(s => setTimeout(() => spawnSpecial(s), randomSpawnInterval(s.respawn)));
}

// Call it once after defining everything
initializeGame();


// Update pet positions and trigger abilities
function updatePets(dt) {
  const radius = 60;
  const rotationSpeed = 1;
  
  // Calculate total cooldown reduction
  let cooldownReduction = 0;
  equippedPets.forEach(pet => {
    if (pet.ability === "cooldown_reducer") {
      cooldownReduction += pet.abilityValue;
    }
  });
  
  equippedPets.forEach((pet, index) => {
    pet.offsetAngle += rotationSpeed * dt;
    pet.x = character.x + character.w/2 + Math.cos(pet.offsetAngle) * radius - 16;
    pet.y = character.y + character.h/2 + Math.sin(pet.offsetAngle) * radius - 16;
    
    if (!petTimers[pet.id]) {
      petTimers[pet.id] = { lastTrigger: Date.now(), cooldown: getPetCooldown(pet.ability) };
    }
    
    const timer = petTimers[pet.id];
    const now = Date.now();
    
    // Apply cooldown reduction
    const effectiveCooldown = timer.cooldown * (1 - cooldownReduction);
    
    if (now - timer.lastTrigger >= effectiveCooldown) {
      triggerPetAbility(pet);
      timer.lastTrigger = now;
    }
  });
}

// Trigger a pet's special ability
function triggerPetAbility(pet) {
  const roll = Math.random();
  
  switch(pet.ability) {
case "purple_spawn":
  if (roll < 0.20) { // 20% chance
    console.log(`${pet.name} spawned a purple cube!`);
    
    // Spawn a temporary purple cube
    const purpleCube = {
      x: Math.random() * (W - CUBE_SIZE),
      y: Math.random() * (H - CUBE_SIZE),
      w: CUBE_SIZE,
      h: CUBE_SIZE,
      color: "#8b3bff",
      value: money * 20n / 100n, // 20% of current money
      visible: true,
      isPurpleSpawn: true
    };
    
    specials.push(purpleCube);
    
    // Remove after 3 seconds
    setTimeout(() => {
      const index = specials.indexOf(purpleCube);
      if (index > -1) specials.splice(index, 1);
    }, 3000);
  }
  break;
      
    case "cube_grabber":
      const randomCube = cubes[Math.floor(Math.random() * cubes.length)];
      legendCounts[randomCube.name] = (legendCounts[randomCube.name] || 0n) + 1n;
      houseValue += randomCube.value;
      console.log(`${pet.name} grabbed a ${randomCube.name}!`);
      recomputeIncome();
      updateDisplays();
      break;
      
    case "day_trigger":
      if (roll < pet.abilityValue) {
        changeDayNightCycle("day", true);
        console.log(`${pet.name} triggered day time!`);
      }
      break;
      
    case "ember_mutator":
      if (roll < pet.abilityValue) {
        const randomPet = playerPets[Math.floor(Math.random() * playerPets.length)];
        if (randomPet && !randomPet.mutation) {
          randomPet.mutation = "Ember";
          console.log(`${pet.name} mutated ${randomPet.name} with Ember!`);
          updateInventoryDisplay();
        }
      }
      break;
      
    case "shooting_star":
      if (roll < pet.abilityValue) {
        const bonus = money * 40n / 100n;
        money += bonus;
        console.log(`${pet.name} spawned a shooting star! +${formatBigInt(bonus)}`);
        updateDisplays();
      }
      break;
      
    case "boss_spawn":
      if (roll < pet.abilityValue) {
        spawnBoss();
        console.log(`${pet.name} spawned the boss!`);
      }
      break;
      
    case "glitch_mutator":
      if (roll < pet.abilityValue) {
        const randomPet = playerPets[Math.floor(Math.random() * playerPets.length)];
        if (randomPet && !randomPet.mutation) {
          randomPet.mutation = "Glitched";
          console.log(`${pet.name} mutated ${randomPet.name} with Glitched!`);
          updateInventoryDisplay();
        }
      }
      break;
      
    case "ability_copy":
      const nearbyPet = equippedPets.find(p => p.id !== pet.id);
      if (nearbyPet) {
        console.log(`${pet.name} copied ${nearbyPet.name}'s ability!`);
        triggerPetAbility(nearbyPet);
      }
      break;
      
    case "egg_giver":
      if (roll < pet.abilityValue) {
        const eggTypes = ["Basic Egg", "Rare Egg", "Dragon Egg", "Mythic Egg", "Celestial Egg"];
        const randomEgg = eggTypes[Math.floor(Math.random() * eggTypes.length)];
        console.log(`${pet.name} gave you a ${randomEgg}!`);
        
        const existing = playerInventory.Eggs.find(i => i.name === randomEgg);
        if (existing) existing.count++;
        else playerInventory.Eggs.push({ icon: "ğŸ¥š", name: randomEgg, count: 1 });
        
        updateInventoryDisplay();
      }
      break;
      
    case "money_doubler":
      if (roll < pet.abilityValue) {
        money = money * 2n;
        console.log(`${pet.name} doubled your money!`);
        updateDisplays();
      }
      break;
      
    case "entity_spawner":
      const randomSpecial = specials[Math.floor(Math.random() * specials.length)];
      spawnSpecial(randomSpecial);
      console.log(`${pet.name} spawned ${randomSpecial.name}!`);
      break;
      
    case "glitch_event":
      if (roll < pet.abilityValue) {
        const glitchEvent = adminAbuseEvents.find(e => e.name === "Glitched");
        if (glitchEvent) triggerAdminEvent(glitchEvent);
        console.log(`${pet.name} started Glitch event!`);
      }
      break;
      
    case "weather_trigger":
      if (roll < pet.abilityValue) {
        triggerWeatherEvent();
        console.log(`${pet.name} triggered weather!`);
      }
      break;
      
    case "bone_giver":
      dropCounters["ğŸ¦´ Skeleton Bones"]++;
      console.log(`${pet.name} gave you a skeleton bone!`);
      updateInventoryDisplay();
      break;
      
    case "blackhole_event":
      if (roll < pet.abilityValue) {
        const blackholeEvent = adminAbuseEvents.find(e => e.name === "Blackhole");
        if (blackholeEvent) triggerAdminEvent(blackholeEvent);
        console.log(`${pet.name} started Blackhole event!`);
      }
      break;
      
    case "cycle_changer":
      if (roll < pet.abilityValue) {
        checkDayNightCycle(); // Force next cycle
        console.log(`${pet.name} changed the day/night cycle!`);
      }
      break;
      
    case "rain_event":
      const rainEvent = weatherEvents.find(e => e.name === "Rain");
      if (rainEvent && !currentWeather) {
        currentWeather = rainEvent.name;
        weatherMultiplier = rainEvent.incomeBoost;
        console.log(`${pet.name} started Rain!`);
        setTimeout(endWeatherEvent, rainEvent.duration);
      }
      break;
      
    case "earthquake_event":
      if (roll < pet.abilityValue) {
        const earthquakeEvent = adminAbuseEvents.find(e => e.name === "Earthquake");
        if (earthquakeEvent) triggerAdminEvent(earthquakeEvent);
        console.log(`${pet.name} started Earthquake!`);
      }
      break;
      
    case "random_event":
      const randomWeatherEvent = weatherEvents[Math.floor(Math.random() * weatherEvents.length)];
      if (!currentWeather) {
        currentWeather = randomWeatherEvent.name;
        weatherMultiplier = randomWeatherEvent.incomeBoost;
        console.log(`${pet.name} started ${randomWeatherEvent.name}!`);
        setTimeout(endWeatherEvent, randomWeatherEvent.duration);
      }
      break;
      
    case "galactic_event":
      const galacticEvent = adminAbuseEvents.find(e => e.name === "Galactic");
      if (galacticEvent) triggerAdminEvent(galacticEvent);
      console.log(`${pet.name} started Galactic event!`);
      break;

      case "ember_giver":
      const targetPet = equippedPets[Math.floor(Math.random() * equippedPets.length)];
      if (targetPet && !targetPet.mutation) {
        targetPet.mutation = "Ember";
        console.log(`${pet.name} gave ${targetPet.name} Ember mutation!`);
        updateInventoryDisplay();
      }
      break;
      
    case "mutation_giver":
      const mutationTypes = Object.keys(petMutations);
      equippedPets.forEach(p => {
        if (!p.mutation && Math.random() < 0.5) {
          const randomMutation = mutationTypes[Math.floor(Math.random() * mutationTypes.length)];
          p.mutation = randomMutation;
          console.log(`${pet.name} gave ${p.name} ${randomMutation} mutation!`);
        }
      });
      updateInventoryDisplay();
      break;
  }
}
/**
 * The main game loop. Called repeatedly by requestAnimationFrame.
 * Updates the game state (e.g. character movement, animations) and renders the game.
 * @param {number} t - The current time in milliseconds.
 */
function loop(t) {
  const dt = (t - lastTime) / 1000;
  lastTime = t;
  update(dt);
  updateWeatherAnimation(dt);
  updateAdminAnimation(dt);
    updateDayNightAnimation(dt); // â† ADD THIS LINE
  render();
  drawWeatherAnimation(ctx);
  drawAdminAnimation(ctx);  
  requestAnimationFrame(loop);
}

function init() {
  cubes = buildCubes();
  renderLegendUI();
  recomputeIncome();
  updateDisplays();
    generateStars(); // â† ADD THIS LINE
      generateClouds(); // â† ADD THIS LINE

  requestAnimationFrame(loop);
}
init();
</script>

</body>
</html>
