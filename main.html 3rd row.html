<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Cubes Game ‚Äî Specials</title>
<style>
  :root{
    --bg:#111;
    --panel:#0f1720;
    --text:#e6eef6;
    --muted:#9aa8b7;
    --accent:#ff3b3b;
  }
  html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,system-ui,-apple-system,Arial}
  body{background:linear-gradient(180deg,#07101a,#051017);color:var(--text);display:flex;align-items:center;justify-content:center;padding:20px}
  .wrap{width:1000px;max-width:98vw}
  .hud{display:flex;gap:16px;align-items:center;margin-bottom:8px}
  .stat{background:rgba(255,255,255,0.03);padding:8px 12px;border-radius:8px;font-weight:600;color:var(--text)}
  .muted{color:var(--muted);font-weight:400}
  .game{background:var(--panel);padding:12px;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,0.6)}
  canvas{background:linear-gradient(180deg,#0b2330,#08202a);display:block;border-radius:12px;cursor:crosshair}
  .bottom-row{display:flex;align-items:flex-start;gap:24px;margin-top:12px}
  .legend{display:flex;flex-direction:column;gap:8px}
  .legend-row{display:flex;align-items:center;gap:8px}
  .swatch{width:20px;height:20px;border-radius:4px;border:1px solid rgba(0,0,0,0.4)}
  .legend-label{min-width:150px;color:var(--muted);font-size:13px}
  .counter{background:rgba(255,255,255,0.03);padding:4px 8px;border-radius:6px;min-width:40px;text-align:center;font-weight:700}
  .controls{display:flex;flex-direction:column;gap:8px}
  button{background:#123;color:var(--text);padding:6px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);cursor:pointer;font-size:14px}
  button:active{transform:translateY(1px)}
  button:disabled{opacity:0.5;cursor:not-allowed}
  .hint{font-size:12px;color:var(--muted)}
  .topline{display:flex;gap:10px;align-items:center;margin-bottom:10px}
  .small{font-size:12px;color:var(--muted)}

  #bossDropsContainer {
    position: fixed;
    top: 20px;
    right: 20px;     /* move anywhere you want */
    z-index: 10000;

    background: rgba(15, 15, 20, 0.85);
    padding: 10px 12px;
    border-radius: 10px;
    box-shadow: 0 0 12px rgba(0,0,0,0.5);
    backdrop-filter: blur(4px);
    color: #cdeaff;
    font-family: sans-serif;
    min-width: 220px;
  }

  #bossDropsContainer summary {
  cursor: pointer;
  font-weight: bold;
  font-size: 16px;
  color: #00ccff;
  }

  #bossDropsContainer details[open] summary {
  color: #00ffff;
  }


#shopPurchasesContainer {
  position: fixed;
  top: 20px;
  left: 20px;      /* Put shop on left, boss on right */
  z-index: 10000;

  background: rgba(20, 15, 0, 0.85);
  padding: 10px 12px;
  border-radius: 10px;
  box-shadow: 0 0 12px rgba(0,0,0,0.5);
  backdrop-filter: blur(4px);
  color: #ffe9a3;
  font-family: sans-serif;
  min-width: 220px;
}

#shopPurchasesContainer summary {
  cursor: pointer;
  font-weight: bold;
  font-size: 16px;
  color: #ffcc00;
}

#shopPurchasesContainer details[open] summary {
  color: #ffe066;
}


</style>
</head>
<body>
<div class="wrap">
  <div class="hud topline">
    <div class="stat" id="moneyDisplay">Money: 0</div>
    <div class="stat" id="incomeDisplay">Income/sec: 0</div>
    <div class="stat" id="houseDisplay">House value: 0</div>
    <div style="flex:1"></div>
    <div class="small muted">Move: WASD or click to set target</div>
  </div>

  <div class="game">
    <canvas id="gameCanvas" width="960" height="540"></canvas>

    <div class="bottom-row">
      <div class="legend" id="legendContainer"></div>

     <div class="controls">
  <button id="upgradeBtn">‚¨ÜÔ∏è Upgrade Cubes</button>
  <button id="downgradeBtn">‚¨áÔ∏è Downgrade Cubes</button>
  <button id="saveBtn">üíæ Save</button>
  <button id="loadBtn">üìÇ Load</button>
  <div class="hint" id="tierHint">Current Tier: 1</div>
</div>

      <!-- üß≠ Inventory / Drop Counter -->
    <div id="inventoryContainer" style="color:white;">
      <div class="legend-label"></div>
      <div id="inventoryList" style="margin-top:6px; line-height:1.5;"></div>
    </div>

    <!-- üè™ SHOP AREA (hidden until inside house) -->
    <div id="shopContainer" style="display:none; color:white;">
      <div class="legend-label">üè™ SHOP</div>
      <div id="shopItems" style="margin-top:6px; line-height:1.5;"></div>
    </div>

 </div>
 </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');


// === ADMIN ABUSE EVENTS CONFIGURATION ===
const adminAbuseEvents = [
  {
    name: "Blackhole",
    triggers: [
      { date: new Date('2025-11-21T11:00:00-05:00') } // 11am CDT
    ],
    key: "!",
    duration: 120000, // 2 minutes in ms
    incomeBoost: 1.30, // 30% boost
    bg: "radial-gradient(circle at center, #000000 0%, #1a0033 30%, #330066 60%, #000000 100%)",
    overlay: "rgba(0,0,0,0.3)",
    animation: "blackhole"
  },
  {
    name: "Hurricane",
    triggers: [
      { date: new Date('2025-11-21T11:40:00-05:00') },
      { date: new Date('2025-11-21T11:44:40-05:00') }
    ],
    key: "@",
    duration: 60000, // 1 minute
    incomeBoost: 1.15,
    bg: "radial-gradient(circle, #334455 0%, #1a2a3a 50%, #0d1520 100%)",
    overlay: "rgba(100,120,150,0.25)",
    animation: "hurricane"
  },
  {
    name: "Disco",
    triggers: [
      { date: new Date('2025-11-21T11:41:15-05:00') },
      { date: new Date('2025-11-21T11:46:00-05:00') }
    ],
    key: "#",
    duration: 95000, // 1 min 35 sec
    incomeBoost: 1.25,
    bg: "linear-gradient(45deg, #ff00ff 0%, #00ffff 25%, #ffff00 50%, #ff00ff 75%, #00ffff 100%)",
    overlay: "rgba(255,255,255,0.1)",
    animation: "disco"
  },
  {
    name: "Volcano",
    triggers: [
      { date: new Date('2025-11-21T11:43:05-05:00') },
      { date: new Date('2025-11-21T11:49:00-05:00') }
    ],
    key: "$",
    duration: 45000, // 45 seconds
    incomeBoost: 1.35,
    bg: "linear-gradient(180deg, #330000 0%, #660000 30%, #ff4400 60%, #ff8800 100%)",
    overlay: "rgba(255,100,0,0.3)",
    animation: "volcano"
  },
  {
    name: "Earthquake",
    triggers: [
      { date: new Date('2025-11-21T11:44:10-05:00') }
    ],
    key: "%",
    duration: 15000, // 15 seconds
    incomeBoost: 1.50,
    bg: "linear-gradient(180deg, #2a2520 0%, #3a2a20 50%, #2a2520 100%)",
    overlay: "rgba(100,80,60,0.2)",
    animation: "earthquake"
  },
  {
    name: "Glitched",
    triggers: [
      { date: new Date('2025-11-21T11:47:50-05:00') }
    ],
    key: "^",
    duration: 60000, // 1 minute
    incomeBoost: 1.35,
    bg: "linear-gradient(90deg, #000 0%, #0f0 2%, #000 4%, #f0f 6%, #000 8%, #0ff 10%, #000 100%)",
    overlay: "rgba(0,255,0,0.15)",
    animation: "glitched"
  },
  {
    name: "Galactic",
    triggers: [
      { date: new Date('2025-11-21T11:50:00-05:00') }
    ],
    key: "&",
    duration: 180000, // 3 minutes
    incomeBoost: 1.20,
    bg: "radial-gradient(circle at 20% 30%, #4a0080 0%, #000033 40%, #000000 100%)",
    overlay: "rgba(80,60,150,0.2)",
    animation: "galactic"
  }
];

// Admin Abuse event state
let currentAdminEvent = null;
let adminEventTimer = null;
let adminEventParticles = [];
let adminEventOverlayAlpha = 0;
let adminEventShakeX = 0;
let adminEventShakeY = 0;

const ctx = canvas.getContext('2d');

const W = canvas.width, H = canvas.height;
const CUBE_SIZE = 48;
const CUBE_SPACING = 18;
const CUBE_COUNT = 8;
const TOP_Y = 30;

const moneyDisplay = document.getElementById('moneyDisplay');
const incomeDisplay = document.getElementById('incomeDisplay');
const houseDisplay = document.getElementById('houseDisplay');
const legendContainer = document.getElementById('legendContainer');
const upgradeBtn = document.getElementById('upgradeBtn');
const downgradeBtn = document.getElementById('downgradeBtn');
const tierHint = document.getElementById('tierHint');

let cubeTier = 0; // 0 = base, 1 = tier 2, 2 = tier 3

let currentWeather = null;
let weatherTimer = null;
let weatherMultiplier = 1; // affects income
let speedMultiplier = 1;   // affects movement
let weatherOverlayAlpha = 0;

let weatherParticles = [];

// put this at top-level, once
let equippedCategory = null;

// make equipCategory callable from inline onclick in the generated HTML
window.equipCategory = function(cat) {
  // toggle: equip if different, unequip if same
  equippedCategory = (equippedCategory === cat) ? null : cat;
  // refresh inventory UI
  updateInventoryDisplay();
};

let equippedItems = {}; // e.g. { Swords: "Iron Sword", Relics: "Magic Relic" }


let equippedSwordSpecial = 0;
let equippedRelicSpecial = 1;
let equippedEggSpecial = 0;
let equippedSkinSpecial = 1;
let equippedPotionSpecial = 1;

// Potion event state
let potionActive = false;
let potionMultiplier = 1;
let potionEndTime = 0;

let swordicon ="";

const skins = {
  1:   { color: "#ff2b2b" },
  2:  { color: "#4d7cff" },
  3: { color: "#a45ee5" },
  4:  { color: "#ffd700" },
  5:  { color: "#e9ecef" }
};


window.equipItem = function equipItem(category, itemName) {
  const item = shopItems[category].find(i => i.name === itemName);
  if (!item) return;

  // Assign special values to corresponding global variable
  switch (category) {
    case "Swords":
      equippedSwordSpecial = item.special;
      swordicon = item.icon;
      break;
    case "Relics":
      equippedRelicSpecial = item.special;
      break;
    case "Eggs":
      equippedEggSpecial = item.special;
      break;
    case "Skins":
      equippedSkinSpecial = item.special;
       character.color = skins[equippedSkinSpecial].color;
      break;
    case "Potions":
      equippedPotionSpecial = item.special;
      activatePotionEvent(item.special);  // ‚Üê NEW: Activates the potion

      break;
  }

  // Optionally store the name as well, if needed later
  playerInventory[category].forEach(i => i.equipped = (i.name === itemName));

  console.log(`‚úÖ Equipped ${item.name} (${category}) ‚Äî special: ${item.special}`);
  updateInventoryDisplay();
}




// === WEATHER LIST ===
const weatherEvents = [
  {
    name: "Rain",
    duration: 60_000, // lasts 1 min
    incomeBoost: 1.05,
    speedBoost: 1.0,
    bg: "linear-gradient(#445, #223)",
    overlay: "rgba(100,150,255,0.2)"
  },
  {
    name: "Wind",
    duration: 60_000,
    incomeBoost: 1.0,
    speedBoost: 1.05,
    bg: "linear-gradient(#ccd, #889)",
    overlay: "rgba(200,200,255,0.15)"
  },
  {
    name: "Thunder",
    duration: 60_000,
    incomeBoost: 1.10,
    speedBoost: 1.0,
    bg: "linear-gradient(#222, #000)",
    overlay: "rgba(255,255,150,0.25)"
  }
];

function nvl(value, defaultValue) {
return value == null ? defaultValue : value;
}




/**
Purpose:
Updates the HTML inventory UI (#inventoryList) to show:
Player‚Äôs current drops (bones, relics, skins, cubes).
All purchased shop items by category.
Key Behavior:

Builds HTML dynamically with item icons and current counts.
Pulls data from dropCounters, dropLimits, and playerInventory.
 * @returns {void}
 */
function updateInventoryDisplay() {
  //const inv = document.getElementById('inventoryDisplay');
  const inv = document.getElementById("inventoryList");

  const bossOpen = document.getElementById("detailsBossDrops")?.open ?? true;
  const shopOpen = document.getElementById("detailsShopPurchases")?.open ?? true;

  if (!inv) return;

  
  // --- Existing inventory (drops) ---
let html = `
   <div id="bossDropsContainer">
  <details id="detailsBossDrops" open style="margin-top:8px;">
    <summary style="cursor:pointer; font-weight:bold; color:#00ccff;">üì¶ Boss Drops</summary>
    <div style="margin-left:10px; margin-top:5px;">
      ü¶¥ Skeleton Bones: ${nvl(dropCounters["ü¶¥ Skeleton Bones"],0)}/${dropLimits.bones}<br>
      üìø Crossbones Relic: ${nvl(dropCounters["üìø Crossbones Relic"],0)}/${dropLimits.relic}<br>
      ‚¨úüíÄ Skeleton Skin: ${nvl(dropCounters["‚¨úüíÄ Skeleton Skin"],0)}/${dropLimits.skin}<br>
      ‚¨ú‚ò†Ô∏è Crossbones Cube: ${nvl(dropCounters["‚¨ú‚ò†Ô∏è Crossbones Cube"],0)}/${dropLimits.cube}<br>
    </div>
  </details>
   </div>
`;


  // --- Shop Inventory ---
  //html += `<b>Shop Purchases</b><br>`;
  html += '<div id="shopPurchasesContainer"><details id="detailsShopPurchases" open style="margin-top:8px;"><summary style="cursor:pointer; font-weight:bold; color:#ffcc00;">üõí Shop Purchases</summary><div style="margin-left:10px; margin-top:5px;"><div>';
  
  const categories = ["Swords", "Relics", "Eggs", "Skins", "Potions"];

  categories.forEach(cat => {
    const items = playerInventory[cat];
    if (!items || items.length === 0) return;

    html += `<u>${cat}</u><br>`;

    playerInventory[cat].forEach(item => {
      const limit = (cat === "Eggs" || cat === "Potions") ? 999 : 1;
      const isEquipped = !!item.equipped;

      // Get the correct special value for this category
      let equippedSpecial = 0;
      switch (cat) {
        case "Swords":   equippedSpecial = equippedSwordSpecial; break;
        case "Relics":   equippedSpecial = equippedRelicSpecial; break;
        case "Eggs":     equippedSpecial = equippedEggSpecial; break;
        case "Skins":    equippedSpecial = equippedSkinSpecial; break;
        case "Potions":  equippedSpecial = equippedPotionSpecial; break;
      }

      // Build the button label safely
      const btnLabel = isEquipped ? `Equipped (‚≠ê${equippedSpecial})` : 'Equip';

      // Append to HTML string (all quotes/backticks properly closed)
      html += `
        ${item.icon} ${item.name}: ${item.count}/${limit}
        <button
          onclick="equipItem('${cat}', '${item.name}')"
          style="
            margin-left:5px; 
            padding:2px 6px; 
            border-radius:5px; 
            background:${isEquipped ? '#28a745' : '#333'}; 
            color:white; 
            border:none; 
            cursor:pointer;
          ">
          ${btnLabel}
        </button><br>
      `;
    });



    html += `<br>`;
  });

  html += '</div></details>';
  inv.innerHTML = html;
  document.getElementById("detailsBossDrops").open = bossOpen;
  document.getElementById("detailsShopPurchases").open = shopOpen;


}

// --- Equip logic ---
function equipCategory(cat) {
  equippedCategory = (equippedCategory === cat) ? null : cat;
  updateInventoryDisplay();
}

/**
 * Adds one item of the specified type to the player's inventory.
 * If the item does not already exist in the player's inventory, it will be added with a count of 1.
 * If the item already exists, its count will be incremented by 1.
 * The function will also update the inventory display in the game UI after adding the item.
 * @param {string} itemName - The name of the item to add to the player's inventory.
 * @returns {void}
 */
function addToInventory(itemName) {
  if (!drops[itemName]) drops[itemName] = 0; // ensure item exists
  const limits = {
    "üó°Ô∏è Sword I": 999n,
    "üó°Ô∏è Sword II": 999n,
    "üó°Ô∏è Sword III": 999n,
    "üó°Ô∏è Sword IV": 999n,
    "üó°Ô∏è Sword V": 999n,
    "üìø Relic I": 1n,
    "üìø Relic II": 1n,
    "üìø Relic III": 1n,
    "üìø Relic IV": 1n,
    "üìø Relic V": 1n,
    "ü•ö Egg I": 999n,
    "ü•ö Egg II": 999n,
    "ü•ö Egg III": 999n,
    "ü•ö Egg IV": 999n,
    "ü•ö Egg V": 999n,
    "üíé Skin I": 1n,
    "üíé Skin II": 1n,
    "üíé Skin III": 1n,
    "üíé Skin IV": 1n,
    "üíé Skin V": 1n,
    "üß™ Potion I": 999n,
    "üß™ Potion II": 999n,
    "üß™ Potion III": 999n,
    "üß™ Potion IV": 999n,
    "üß™ Potion V": 999n,
  };
  
  const limit = limits[itemName] ?? 999n;
  if (BigInt(drops[itemName]) < limit) {
    drops[itemName] = BigInt(drops[itemName]) + 1n;
    updateInventoryDisplay();
  }
}

function updateShopDisplay() {
  const shopContainer = document.getElementById('shopContainer');
  if (!shopContainer) return;
  shopContainer.innerHTML = "<div class='legend-label'>üè™ SHOP</div>";

  const purchaseLimits = {
    Swords: 1,
    Relics: 1,
    Eggs: 999,
    Skins: 1,
    Potions: 999
  };

  for (const [category, items] of Object.entries(shopItems)) {
    const row = document.createElement('div');
    row.style.display = "flex";
    row.style.gap = "10px";
    row.style.marginTop = "8px";
    row.innerHTML = `<strong style='min-width:70px'>${category}:</strong>`;

    items.forEach((item, i) => {
      const btn = document.createElement('button');
      btn.innerText = `${item.icon} ${item.name}\nüí∞${shortLabel(item.price)}`;
      btn.style.display = "flex";
      btn.style.flexDirection = "column";
      btn.style.alignItems = "center";
      btn.style.justifyContent = "center";
      btn.style.fontSize = "10px";
      btn.style.padding = "4px 6px";

btn.onclick = () => buyItem(category, i);


      row.appendChild(btn);
    });

    shopContainer.appendChild(row);
  }
}





/**
 * Format a BigInt as a string with commas for readability.
 * @param {BigInt} b - The BigInt to format.
 * @returns {string} The formatted string.
 */

 function formatBigInt2(b) {
  if (typeof b === 'number') b = BigInt(Math.floor(b));
  const s = b.toString();
  return s.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}


function formatBigInt(b) {
  if (typeof b === 'number') b = BigInt(Math.floor(b));
  if (typeof b !== 'bigint') return b;

  const isNegative = b < 0n;
  b = isNegative ? -b : b;

  const UNITS = [
  { value: 1_000_000_000_000_000_000_000_000_000_000_000n, symbol: "DC" }, // decilion (10^24)
  { value: 1_000_000_000_000_000_000_000_000_000_000n, symbol: "NO" }, // nonnilion (10^24) 
  { value: 1_000_000_000_000_000_000_000_000_000n, symbol: "OC" }, // octilion (10^24)  
  { value: 1_000_000_000_000_000_000_000_000n, symbol: "SP" }, // septilion (10^24)
    { value: 1_000_000_000_000_000_000_000n, symbol: "SX" }, // sextilion (10^21)
    { value: 1_000_000_000_000_000_000n, symbol: "QI" }, // quintilion (10^18)
    { value: 1_000_000_000_000_000n, symbol: "QA" }, // quadrilion (10^15)
    { value: 1_000_000_000_000n, symbol: "T" }, // trillion (10^12)
    { value: 1_000_000_000n, symbol: "B" }, // billion (10^9)
    { value: 1_000_000n, symbol: "M" }, // million (10^6)
    { value: 1_000n, symbol: "K" } // thousand (10^3)
  ];

  for (const unit of UNITS) {
    if (b >= unit.value) {
      // Compute with BigInt precision safely
      const whole = Number(b / unit.value);
      const frac = Number(b % unit.value) / Number(unit.value);
      const formatted = (whole + frac).toFixed(1).replace(/\.0$/, "");
      return (isNegative ? "-" : "") + formatted + unit.symbol;
    }
  }

  // Fallback for small numbers
  return (isNegative ? "-" : "") + b.toString();
}



/**
 * Format a BigInt as a string with commas for readability and
 * optionally display a unit at the end (e.g. "K" for thousands, "M" for millions, etc.)
 * @param {BigInt} n - The number to format
 * @returns {string} The formatted string
 */
function shortLabel(n) {
  const num = BigInt(n);
  const abs = num < 0n ? -num : num;
  const units = [
                 [1_000_000_000_000_000_000_000n, "SX"], 
                 [1_000_000_000_000_000_000n, "QI"], 
                 [1_000_000_000_000_000n, "QA"], 
                 [1_000_000_000_000n, "T"], 
                 [1_000_000_000n, "B"], 
                 [1_000_000n, "M"], 
                 [1_000n, "K"]
                ];

  for (let [v, l] of units) if (abs >= v) return (num < 0n ? "-" : "") + Number(abs / v) + l;
  return num.toString();
}

const tier1Cubes = [
  { name: "Green", color: "#3bbf6e", value: 100n },
  { name: "Blue", color: "#3b8ebf", value: 1000n },
  { name: "Black", color: "#222222", value: 10000n },
  { name: "Yellow", color: "#e6d44a", value: 100000n },
  { name: "Orange", color: "#ff8a2b", value: 1000000n },
  { name: "Purple", color: "#8b3bff", value: 10000000n },
  { name: "Red", color: "#c53030", value: 100000000n },
  { name: "White", color: "#e9ecef", value: 1000000000n },
];
const tier2Cubes = [
  { name: "Light Green", color: "#9be6b8", value: 10000000000n },
  { name: "Light Blue", color: "#9bd3e6", value: 100000000000n },
  { name: "Dark Grey", color: "#6b6b6b", value: 1000000000000n },
  { name: "Light Yellow", color: "#fff1a8", value: 10000000000000n },
  { name: "Light Orange", color: "#ffc89b", value: 100000000000000n },
  { name: "Light Purple", color: "#d8b8ff", value: 1000000000000000n },
  { name: "Light Red", color: "#ffb8b8", value: 10000000000000000n },
  { name: "Light Gray", color: "#d0d0d0", value: 100000000000000000n },
];
const tier3Cubes = [
  { name: "Dark Green", color: "#0a5f38", value: 1000000000000000000n }, // 1QI
  { name: "Dark Blue", color: "#1a4d7a", value: 10000000000000000000n }, // 10QI
  { name: "Indigo", color: "#4b0082", value: 100000000000000000000n }, // 100QI
  { name: "Dark Yellow", color: "#9b870c", value: 1000000000000000000000n }, // 1SX
  { name: "Dark Orange", color: "#cc5500", value: 10000000000000000000000n }, // 10SX
  { name: "Dark Purple", color: "#5a1d5a", value: 100000000000000000000000n }, // 100SX
  { name: "Dark Red", color: "#8b0000", value: 1000000000000000000000000n }, // 1SP ‚úÖ
  { name: "Neon Green", color: "#39ff14", value: 10000000000000000000000000n }, // 10SP ‚úÖ
];


const incomeRates = {
  // Tier 1
  "Green": 2n, "Blue": 20n, "Black": 200n, "Yellow": 2000n, 
  "Orange": 20000n, "Purple": 200000n, "Red": 2000000n, "White": 20000000n,
  // Tier 2
  "Light Green": 200000000n, "Light Blue": 2000000000n, "Dark Grey": 20000000000n,
  "Light Yellow": 200000000000n, "Light Orange": 2000000000000n, "Light Purple": 20000000000000n,
  "Light Red": 200000000000000n, "Light Gray": 2000000000000000n,
  // Tier 3
  "Dark Green": 20000000000000000n, "Dark Blue": 200000000000000000n, "Indigo": 2000000000000000000n,
  "Dark Yellow": 20000000000000000000n, "Dark Orange": 200000000000000000000n, 
  "Dark Purple": 2000000000000000000000n, "Dark Red": 20000000000000000000000n, // 1SP ‚úÖ
  "Neon Green": 200000000000000000000000n, // 10SP ‚úÖ
};

function computeCubePositions() {
  const totalWidth = (CUBE_COUNT * CUBE_SIZE) + ((CUBE_COUNT - 1) * CUBE_SPACING);
  const startX = Math.round((W - totalWidth) / 2);
  const arr = [];
  for (let i = 0; i < CUBE_COUNT; i++) {
    arr.push({ x: startX + i * (CUBE_SIZE + CUBE_SPACING), y: TOP_Y, w: CUBE_SIZE, h: CUBE_SIZE });
  }
  return arr;
}
const cubePositions = computeCubePositions();
function currentCubes() {
  if (cubeTier === 0) return tier1Cubes;
  if (cubeTier === 1) return tier2Cubes;
  return tier3Cubes;
}
function buildCubes() { return currentCubes().map((c, i) => ({ ...c, pos: cubePositions[i], visible: true })); }

let cubes = buildCubes();

// const character = { x: W / 2 - CUBE_SIZE / 2, y: H / 2 - CUBE_SIZE / 2, w: CUBE_SIZE, h: CUBE_SIZE, color: "#ff2b2b", speed: 250, target: null, assignedName: null, assignedValue: 0n };
const character = {
  x: W / 2 - CUBE_SIZE / 2,
  y: H / 2 - CUBE_SIZE / 2,
  w: CUBE_SIZE,
  h: CUBE_SIZE,
  color: skins[equippedSkinSpecial].color,
  speed: 250,
  target: null,
  assignedName: null,
  assignedValue: 0n,
  hasSword: false,       // Q toggles this
  slashing: false,       // true when space pressed
  slashDuration: 200     // ms duration of slash animation
};

const house = { w: 140, h: 140, x: W - 160, y: H - 160, border: "#ff3b3b" };

let bossDrops = [];

const inventory = {
  "ü¶¥ Skeleton Bones": 0,
  "üìø Crossbones Relic": 0,
  "‚¨úüíÄ Skeleton Skin": 0,
  "‚¨ú‚ò†Ô∏è Crossbones Cube": 0
};

// üí∞ Track how many total drops of each type (separate counters)
const dropCounters = {
  "ü¶¥ Skeleton Bones": 0,
  "üìø Crossbones Relic": 0,
  "‚¨úüíÄ Skeleton Skin": 0,
  "‚¨ú‚ò†Ô∏è Crossbones Cube": 0
  //,
  //"bones": 0,
  //"relic": 0,
  //"skin": 0,
  //"cube": 0
};



let money = 1000n, incomePerSec = 0n, houseValue = 0n;

let bossSpawnInterval = 10 * 60 * 1000; // 10 minutes in ms
let nextBossSpawn = Date.now() + bossSpawnInterval;

const legendCounts = {};
[...tier1Cubes, ...tier2Cubes, ...tier3Cubes].forEach(c => legendCounts[c.name] = 0n);
let insideHouse = false;

// === üõí SHOP CONFIGURATION ===
const shopItems = {
  Swords: [
    { icon: "‚öîÔ∏è", price: 100_000_000n, name: "Iron Sword", limit: 1, special: 2 },
    { icon: "üó°Ô∏è", price: 100_000_000_000n, name: "Steel Sword", limit: 1, special: 3 },
    { icon: "üíé", price: 10_000_000_000_000n, name: "Crystal Sword", limit: 1, special: 4 },
    { icon: "üî•", price: 100_000_000_000_000_000n, name: "Flame Blade", limit: 1, special: 3 },
    { icon: "‚ö°", price: 100_000_000_000_000_000_000n, name: "Thunder Edge", limit: 1, special: 5 },
  ],
  Relics: [
    { icon: "üìø", price: 100_000_000n, name: "Relic of Light", limit: 1, special: 1.1 },
    { icon: "ü™∂", price: 100_000_000_000n, name: "Relic of Wind", limit: 1, special: 1.15 },
    { icon: "üíÄ", price: 100_000_000_000_000n, name: "Relic of Death", limit: 1, special: 1.20 },
    { icon: "üåô", price: 1_000_000_000_000_000_000n, name: "Relic of Night", limit: 1, special: 1.25 },
    { icon: "‚òÄÔ∏è", price: 100_000_000_000_000_000_000n, name: "Relic of Sun", limit: 1, special: 1.30 },
  ],
  Eggs: [
    { icon: "ü•ö", price: 100_000_000n, name: "Basic Egg", limit: 999, special: 1 },
    { icon: "üê£", price: 100_000_000_000n, name: "Rare Egg", limit: 999, special: 1 },
    { icon: "üêâ", price: 100_000_000_000_000n, name: "Dragon Egg", limit: 999, special: 1 },
    { icon: "‚ú®", price: 1_000_000_000_000_000_000n, name: "Mythic Egg", limit: 999, special: 1 },
    { icon: "ü™∫", price: 10_000_000_000_000_000_000_000n, name: "Celestial Egg", limit: 999, special: 1 },
  ],
  Skins: [
    { icon: "üü•", price: 1_000_000_000n, name: "Red Skin", limit: 1, special: 1 },
    { icon: "üü¶", price: 1_000_000_000_000n, name: "Blue Skin", limit: 1, special: 2 },
    { icon: "üü™", price: 1_000_000_000_000_000n, name: "Purple Skin", limit: 1, special: 3 },
    { icon: "üü®", price: 10_000_000_000_000_000_000n, name: "Gold Skin", limit: 1, special: 4 },
    { icon: "‚¨ú", price: 1_000_000_000_000_000_000_000n, name: "Diamond Skin", limit: 1, special: 5 },
  ],
  Potions: [
    { icon: "üß™", price: 1_000_000n, name: "Health Potion", limit: 999, special: 2 },
    { icon: "üíä", price: 10_000_000_000n, name: "Energy Potion", limit: 999, special: 3 },
    { icon: "‚öóÔ∏è", price: 100_000_000_000_000n, name: "Alchemy Potion", limit: 999, special: 4 },
    { icon: "üßâ", price: 1_000_000_000_000_000_000n, name: "Mystic Potion", limit: 999, special: 5 },
    { icon: "ü•§", price: 10_000_000_000_000_000_000_000n, name: "Divine Potion", limit: 999, special: 6 },
  ]
};


const playerInventory = {
  Swords: [],
  Relics: [],
  Eggs: [],
  Skins: [],
  Potions: []
};

// === ü¶¥ DROP LIMITS ===
const dropLimits = {
  bones: 999,
  relic: 1,
  skin: 1,
  cube: 1
};



function buyItem(category, index) {
  const item = shopItems[category][index];

  // --- Determine item limit by category ---
  const limit = (category === "Eggs" || category === "Potions") ? 999n : 1n;

  // --- Check current amount owned ---
  const owned = BigInt(inventory[item.name] || 0n);

  // --- Check purchase limit ---
  if (owned >= limit) {
    alert(`You already own the maximum number of ${item.name}s!`);
    return;
  }

  // --- Check money ---
  if (money < item.price) {
    alert(`Not enough money to buy ${item.name}!`);
    return;
  }

  // --- Process purchase ---
  money -= item.price;
  inventory[item.name] = owned + 1n;

  // --- Update player inventory by category ---
  const existing = playerInventory[category].find(i => i.name === item.name);
  if (existing) {
    existing.count++;
  } else {
    playerInventory[category].push({
      icon: item.icon,
      name: item.name,
      count: 1
    });
  }

  // --- Update all UI displays ---
  updateDisplays();
  updateInventoryDisplay();
}



// --- RENDER LEGEND UI ---
function renderLegendUI() {
  legendContainer.innerHTML = "";

  const itemsToShow = insideHouse ? shopItems : currentCubes();

  itemsToShow.forEach(c => {
    const row = document.createElement("div");
    row.className = "legend-row";
    row.innerHTML = `
      <div class="swatch" style="background:${c.color}"></div>
      <div class="legend-label">${insideHouse ? "SHOP: " : ""}${c.name} (${shortLabel(c.value)})</div>
      <div class="counter" id="cnt-${c.name.replace(/\s+/g, "_")}">${insideHouse ? "" : (legendCounts[c.name] || 0n)}</div>
    `;
    legendContainer.appendChild(row);

    // Click handler for shop
    if (insideHouse) {
      row.style.cursor = "pointer";
      row.addEventListener("click", () => {
        if (money >= c.value) {
          money -= c.value;
          alert(`‚úÖ Purchased ${c.name} for ${formatBigInt(c.value)} money!`);
          updateDisplays();
        } else {
          alert("‚ùå Not enough money for ${c.name}");
        }
      });
    }
  });

  // Hide inventory when in shop
  document.getElementById("inventoryList").style.display = insideHouse ? "none" : "block";
}



// --- UPDATE HOUSE DEPOSIT & SHOP SWITCH ---
function checkHouseDeposit() {
  const nowInside = rectsOverlap(character, house);

  if (nowInside && !insideHouse) {
    insideHouse = true;
    document.getElementById("shopContainer").style.display = "block";
    updateShopDisplay();

    //renderLegendUI(); // switch to shop

    // Optional: perform deposit logic 4if desired
    if (character.assignedValue && money >= character.assignedValue) {
      money -= character.assignedValue;
      houseValue += character.assignedValue;
      legendCounts[character.assignedName] = (legendCounts[character.assignedName] || 0n) + 1n;
      recomputeIncome();
      updateDisplays();
      character.assignedValue = 0n;
      character.assignedName = null;
    }
  } else   if (nowInside && !insideHouse) {
    insideHouse = true;
    renderLegendUI();
  } else if (!nowInside && insideHouse) {
    insideHouse = false;
    document.getElementById("shopContainer").style.display = "none";
    renderLegendUI();
  }

}


/**
 * Recomputes the total income per second based on the current legend counts and income rates.
 * Applies the current weather multiplier to the total income.
 * Updates the income display with the new total income per second.
 * @returns {undefined}
 */
function recomputeIncome() {
  // Initialize total income per second to 0
  incomePerSec = 0n;

  // Iterate through all legend counts
  for (let n in legendCounts) {
    // Add the product of the count and income rate to the total income
    incomePerSec += legendCounts[n] * (incomeRates[n] || 0n);
  }
  console.log("Income/Sec-0 " + incomePerSec);

  // Apply the current weather multiplier to the total income
  //const adjustedIncome = BigInt(Math.floor( (Number(incomePerSec) * weatherMultiplier)*equippedRelicSpecial) );
  //const totalMultiplier = weatherMultiplier * equippedRelicSpecial * (potionActive ? potionMultiplier : 1);
  const adminMultiplier = currentAdminEvent ? currentAdminEvent.incomeBoost : 1;
  const totalMultiplier = weatherMultiplier * equippedRelicSpecial * (potionActive ? potionMultiplier : 1) * adminMultiplier;

  console.log("totalMultiplier " + totalMultiplier);
  console.log("adminMultiplier " + adminMultiplier);

  const adjustedIncome = BigInt(Math.floor(Number(incomePerSec) * totalMultiplier));
  
  incomePerSec = adjustedIncome;
  
  // Short version for display
  const shortText = formatBigInt(adjustedIncome);

  // Full version with commas for tooltip
  const fullText = formatBigInt2(adjustedIncome);

  // Update the income display with the new total income per second
  incomeDisplay.textContent = "Income/sec: " + shortText;
  incomeDisplay.title = fullText; // ‚Üê hover tooltip
  console.log("Income/Sec-1 " + shortText);

  if (potionActive) {
    const timeLeft = Math.ceil((potionEndTime - Date.now()) / 1000);
    incomeDisplay.textContent += ` üß™(${timeLeft}s)`;
  }
}


/**
 * Triggers a random weather event which affects income and speed.
 * Prevents overlap of weather events by checking if there is a current event.
 * Logs the name of the weather event to the console.
 * Sets the background color of the document body to the weather event's background color.
 * Sets the alpha value of the weather overlay to 0.3.
 * Ends the weather event after its specified duration using setTimeout.
 * @returns {undefined}
 */
function triggerWeatherEvent() {
  if (currentWeather) return; // prevent overlap
  const w = weatherEvents[Math.floor(Math.random() * weatherEvents.length)];
  currentWeather = w.name;
  weatherMultiplier = w.incomeBoost;
  speedMultiplier = w.speedBoost;
  document.body.style.background = w.bg;
  weatherOverlayAlpha = 0.3;
  console.log(`üå¶ Weather started: ${w.name}`);

  // End after duration
  weatherTimer = setTimeout(endWeatherEvent, w.duration);

  startWeatherAnimation(currentWeather);

}

/**
 * Ends the current weather event by resetting its associated multipliers and
 * background style, and logging a message to the console.
 * This function is called automatically after the duration of the weather event.
 * @returns {undefined}
 */
function endWeatherEvent() {
  console.log(`üå§ Weather ended: ${currentWeather}`);
  currentWeather = null;
  weatherMultiplier = 1;
  speedMultiplier = 1;
  document.body.style.background = "linear-gradient(#111,#07101a)";
  weatherOverlayAlpha = 0;

  stopWeatherAnimation();

}






function activatePotionEvent(multiplier) {

  
  potionActive = true;
  potionMultiplier = multiplier;
  potionEndTime = Date.now() + 60000; // 1 minute from now
  
  console.log(`üß™ Potion activated! ${multiplier}x income for 60 seconds`);
  
  // Recalculate income with new multiplier
  recomputeIncome();
  
  // Set timeout to end potion effect after 60 seconds
  setTimeout(() => {
    potionActive = false;
    potionMultiplier = 1;
    console.log(`üß™ Potion effect ended`);
    
    // Unequip the potion - reset button to "Equip" status
    if (playerInventory.Potions) {
      playerInventory.Potions.forEach(i => i.equipped = false);
    }
    equippedPotionSpecial = 1;
    
    // Recalculate income back to normal
    recomputeIncome();
    // Update the UI to show "Equip" button again
    updateInventoryDisplay();
  }, 60000);
}

/**
 * Starts a weather animation based on the given type.
 * The type can be one of "Rain", "Wind", or "Thunder".
 * For "Rain", generates 150 particles with random positions and lengths/speeds.
 * For "Wind", generates 80 particles with random positions and lengths/speeds.
 * For "Thunder", generates a single particle with a flashing effect.
 * @param {string} type - The type of the weather animation to start.
 * @returns {undefined}
 */
function startWeatherAnimation(type) {
  weatherParticles = [];

  if (type === "Rain") {
    for (let i = 0; i < 150; i++) {
      weatherParticles.push({
        x: Math.random() * W,
        y: Math.random() * H,
        len: 10 + Math.random() * 10,
        speed: 300 + Math.random() * 200
      });
    }
  }

  if (type === "Wind") {
    for (let i = 0; i < 80; i++) {
      weatherParticles.push({
        x: Math.random() * W,
        y: Math.random() * H,
        len: 20 + Math.random() * 10,
        speed: 100 + Math.random() * 150
      });
    }
  }

  if (type === "Thunder") {
    weatherParticles.push({ flash: true, alpha: 0 });
  }
}

/**
 * Stops the current weather animation by resetting the weatherParticles array.
 * This function is called automatically after the duration of the weather event.
 * @returns {undefined}
 */
function stopWeatherAnimation() {
  weatherParticles = [];
}

/**
 * Updates the weather animation by moving and/or flashing the weather particles.
 * This function is called continuously by the requestAnimationFrame loop.
 * @param {number} dt - The time elapsed since the last frame in milliseconds.
 * @returns {undefined}
 */
function updateWeatherAnimation(dt) {
  if (!currentWeather) return;

  if (currentWeather === "Rain") {
    for (const p of weatherParticles) {
      p.y += p.speed * dt;
      if (p.y > H) {
        p.y = -p.len;
        p.x = Math.random() * W;
      }
    }
  }

  if (currentWeather === "Wind") {
    for (const p of weatherParticles) {
      p.x += p.speed * dt;
      if (p.x > W) {
        p.x = -p.len;
        p.y = Math.random() * H;
      }
    }
  }

  if (currentWeather === "Thunder") {
    // Random flash effect
    if (Math.random() < 0.005) {
      weatherParticles[0].alpha = 1;
    }
    if (weatherParticles[0].alpha > 0) {
      weatherParticles[0].alpha -= dt * 2;
    }
  }
}


// === ADMIN ABUSE EVENT FUNCTIONS ===
function triggerAdminEvent(event) {
  if (currentAdminEvent) {
    console.log(`‚ö†Ô∏è Admin event ${currentAdminEvent.name} already active, skipping ${event.name}`);
    return;
  }
  
  currentAdminEvent = event;
  document.body.style.background = event.bg;
  adminEventOverlayAlpha = 0.3;
  
  console.log(`üéÆ Admin Abuse: ${event.name} started! +${(event.incomeBoost - 1) * 100}% income for ${event.duration/1000}s`);
  
  recomputeIncome();
  startAdminAnimation(event.animation);
  
  adminEventTimer = setTimeout(() => endAdminEvent(), event.duration);
}

function endAdminEvent() {
  if (!currentAdminEvent) return;
  
  console.log(`‚úÖ Admin event ${currentAdminEvent.name} ended`);
  currentAdminEvent = null;
  document.body.style.background = "linear-gradient(#111,#07101a)";
  adminEventOverlayAlpha = 0;
  adminEventShakeX = 0;
  adminEventShakeY = 0;
  
  recomputeIncome();
  stopAdminAnimation();
}

function startAdminAnimation(type) {
  adminEventParticles = [];
  
  switch(type) {
    case "blackhole":
      for (let i = 0; i < 100; i++) {
        adminEventParticles.push({
          angle: Math.random() * Math.PI * 2,
          distance: 200 + Math.random() * 300,
          speed: 50 + Math.random() * 100,
          size: 1 + Math.random() * 2
        });
      }
      break;
      
    case "hurricane":
      for (let i = 0; i < 150; i++) {
        adminEventParticles.push({
          angle: Math.random() * Math.PI * 2,
          distance: Math.random() * Math.max(W, H),
          speed: 100 + Math.random() * 200,
          size: 2 + Math.random() * 3,
          isRain: Math.random() > 0.7
        });
      }
      break;
      
    case "disco":
      for (let i = 0; i < 50; i++) {
        adminEventParticles.push({
          x: Math.random() * W,
          y: Math.random() * H,
          size: 10 + Math.random() * 20,
          hue: Math.random() * 360,
          alpha: 0.5 + Math.random() * 0.5
        });
      }
      break;
      
    case "volcano":
      for (let i = 0; i < 80; i++) {
        adminEventParticles.push({
          x: W / 2 + (Math.random() - 0.5) * 100,
          y: H,
          vx: (Math.random() - 0.5) * 200,
          vy: -300 - Math.random() * 200,
          size: 3 + Math.random() * 5,
          life: 1
        });
      }
      break;
      
    case "glitched":
      // Glitch blocks
      for (let i = 0; i < 30; i++) {
        adminEventParticles.push({
          x: Math.random() * W,
          y: Math.random() * H,
          w: 20 + Math.random() * 100,
          h: 5 + Math.random() * 30
        });
      }
      break;
      
    case "galactic":
      // Stars and planets
      for (let i = 0; i < 100; i++) {
        adminEventParticles.push({
          x: Math.random() * W,
          y: Math.random() * H,
          size: 1 + Math.random() * 3,
          twinkle: Math.random()
        });
      }
      // Add some planets
      for (let i = 0; i < 5; i++) {
        adminEventParticles.push({
          x: Math.random() * W,
          y: Math.random() * H,
          size: 20 + Math.random() * 40,
          isPlanet: true,
          hue: Math.random() * 360
        });
      }
      break;
  }
}

function stopAdminAnimation() {
  adminEventParticles = [];
}

function updateAdminAnimation(dt) {
  if (!currentAdminEvent) return;
  
  const type = currentAdminEvent.animation;
  
  switch(type) {
    case "blackhole":
      adminEventParticles.forEach(p => {
        p.distance -= p.speed * dt;
        if (p.distance < 10) p.distance = 500;
      });
      break;
      
    case "hurricane":
      adminEventParticles.forEach(p => {
        p.angle += p.speed * dt * 0.01;
        if (p.isRain) {
          p.distance += 50 * dt;
          if (p.distance > Math.max(W, H)) p.distance = 0;
        }
      });
      break;
      
    case "disco":
      adminEventParticles.forEach(p => {
        p.hue = (p.hue + 100 * dt) % 360;
      });
      break;
      
    case "volcano":
      adminEventParticles.forEach(p => {
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += 400 * dt; // gravity
        p.life -= dt * 0.5;
        
        if (p.life <= 0) {
          p.x = W / 2 + (Math.random() - 0.5) * 100;
          p.y = H;
          p.vx = (Math.random() - 0.5) * 200;
          p.vy = -300 - Math.random() * 200;
          p.life = 1;
        }
      });
      break;
      
    case "earthquake":
      adminEventShakeX = (Math.random() - 0.5) * 10;
      adminEventShakeY = (Math.random() - 0.5) * 10;
      break;
      
    case "glitched":
      if (Math.random() < 0.1) {
        adminEventParticles.forEach(p => {
          p.x = Math.random() * W;
          p.y = Math.random() * H;
        });
      }
      break;
      
    case "galactic":
      adminEventParticles.forEach(p => {
        if (!p.isPlanet) {
          p.twinkle = (p.twinkle + dt) % 1;
        }
      });
      break;
  }
}

function drawAdminAnimation(ctx) {
  if (!currentAdminEvent) return;
  
  ctx.save();
  
  const type = currentAdminEvent.animation;
  const centerX = W / 2;
  const centerY = H / 2;
  
  switch(type) {
    case "blackhole":
      ctx.fillStyle = "rgba(138,43,226,0.3)";
      ctx.beginPath();
      ctx.arc(centerX, centerY, 50, 0, Math.PI * 2);
      ctx.fill();
      
      adminEventParticles.forEach(p => {
        const x = centerX + Math.cos(p.angle) * p.distance;
        const y = centerY + Math.sin(p.angle) * p.distance;
        ctx.fillStyle = `rgba(200,150,255,${1 - p.distance/500})`;
        ctx.fillRect(x, y, p.size, p.size);
      });
      break;
      
    case "hurricane":
      adminEventParticles.forEach(p => {
        if (p.isRain) {
          const x = centerX + Math.cos(p.angle) * p.distance;
          const y = centerY + Math.sin(p.angle) * p.distance;
          ctx.strokeStyle = "rgba(150,200,255,0.4)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x, y + 10);
          ctx.stroke();
        } else {
          const x = centerX + Math.cos(p.angle) * p.distance;
          const y = centerY + Math.sin(p.angle) * p.distance;
          ctx.strokeStyle = "rgba(255,255,255,0.2)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + Math.cos(p.angle) * 20, y + Math.sin(p.angle) * 20);
          ctx.stroke();
        }
      });
      break;
      
    case "disco":
      adminEventParticles.forEach(p => {
        ctx.fillStyle = `hsla(${p.hue}, 100%, 50%, ${p.alpha})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      });
      break;
      
    case "volcano":
      adminEventParticles.forEach(p => {
        if (p.life > 0) {
          ctx.fillStyle = `rgba(255,${100 + p.life * 150},0,${p.life})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
        }
      });
      break;
      
    case "glitched":
      adminEventParticles.forEach(p => {
        const colors = ['#ff0000', '#00ff00', '#0000ff', '#ff00ff', '#00ffff'];
        ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];
        ctx.globalAlpha = 0.3;
        ctx.fillRect(p.x, p.y, p.w, p.h);
      });
      ctx.globalAlpha = 1;
      break;
      
    case "galactic":
      adminEventParticles.forEach(p => {
        if (p.isPlanet) {
          ctx.fillStyle = `hsl(${p.hue}, 70%, 50%)`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
        } else {
          ctx.fillStyle = `rgba(255,255,255,${0.3 + p.twinkle * 0.7})`;
          ctx.fillRect(p.x, p.y, p.size, p.size);
        }
      });
      break;
  }
  
  ctx.restore();
}

// Check for scheduled admin events
function checkScheduledAdminEvents() {
  const now = new Date();
  
  adminAbuseEvents.forEach(event => {
    event.triggers.forEach(trigger => {
      if (!trigger.triggered && trigger.date <= now) {
        trigger.triggered = true;
        triggerAdminEvent(event);
      }
    });
  });
}

// Check every second for scheduled events
setInterval(checkScheduledAdminEvents, 1000);

/**
 * Draws the weather animation based on the current weather type.
 * This function is called continuously by the requestAnimationFrame loop.
 * @param {CanvasRenderingContext2D} ctx - The canvas context to draw on.
 * @returns {undefined}
 */
function drawWeatherAnimation(ctx) {
  if (!currentWeather) return;

  ctx.save();
  if (currentWeather === "Rain") {
    ctx.strokeStyle = "rgba(150,200,255,0.5)";
    ctx.lineWidth = 1.5;
    for (const p of weatherParticles) {
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(p.x, p.y + p.len);
      ctx.stroke();
    }
  }

  if (currentWeather === "Wind") {
    ctx.strokeStyle = "rgba(255,255,255,0.2)";
    ctx.lineWidth = 2;
    for (const p of weatherParticles) {
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(p.x + p.len, p.y);
      ctx.stroke();
    }
  }

  if (currentWeather === "Thunder") {
    const a = weatherParticles[0].alpha;
    if (a > 0) {
      ctx.fillStyle = `rgba(255,255,200,${a})`;
      ctx.fillRect(0, 0, W, H);
    }
  }
  ctx.restore();
}

// Auto every 5 minutes
setInterval(() => {
  if (!currentWeather) triggerWeatherEvent();
}, 300_000);

// Manual trigger with ']'
document.addEventListener("keydown", e => {
  if (e.key === "]") triggerWeatherEvent();
});

//setInterval(() => { money += incomePerSec; updateDisplays(); }, 1000);
setInterval(() => { 
  money += incomePerSec; 
  updateDisplays(); 
  
  if (potionActive) {
    recomputeIncome(); // Updates the countdown timer every second
  }
}, 1000);

function updateDisplays() {
  moneyDisplay.textContent = "Money: " + formatBigInt(money);  
  moneyDisplay.title = formatBigInt2(money);

  incomeDisplay.textContent = "Income/sec: " + formatBigInt(incomePerSec);
  incomeDisplay.title = formatBigInt2(incomePerSec);
  console.log("Income/Sec-2 " + incomeDisplay.title);

  houseDisplay.textContent = "House value: " + formatBigInt(houseValue);
  houseDisplay.title = formatBigInt2(houseValue);

  if (!insideHouse) { // only update legend counts if NOT inside house
    for (let c of currentCubes()) {
      const el = document.getElementById("cnt-" + c.name.replace(/\s+/g, "_"));
      if (el) el.textContent = legendCounts[c.name].toString();
    }
  }
}

function rectsOverlap(a, b) { return !(a.x + a.w <= b.x || b.x + b.w <= a.x || a.y + a.h <= b.y || b.y + b.h <= a.y); }

function checkCubeCollisions() {
  for (let c of cubes) {
    if (rectsOverlap(character, c.pos)) {
      character.assignedName = c.name;
      character.assignedValue = BigInt(c.value);
      resolveSolidCollision(character, c.pos);
    }
  }
}

function resolveSolidCollision(a, b) {
  const overlapX = Math.min(a.x + a.w - b.x, b.x + b.w - a.x);
  const overlapY = Math.min(a.y + a.h - b.y, b.y + b.h - a.y);
  if (overlapX < overlapY) a.x += (a.x < b.x) ? -overlapX : overlapX;
  else a.y += (a.y < b.y) ? -overlapY : overlapY;
}

function handleSlash() {
  specials.forEach(s => {
    if (s.visible && rectsOverlap({x: character.x-10, y: character.y-10, w: character.w+20, h: character.h+20}, s)) {
      s.visible = false;
      // maybe apply some effect
    }
  });
}

/// WINDOW EVENT LISTENERS
const keys = {};
//window.addEventListener("keydown", e => { if ("wasd".includes(e.key.toLowerCase())) keys[e.key.toLowerCase()] = true; });
window.addEventListener("keydown", e => {
  const key = e.key.toLowerCase();
  if (["w","a","s","d","arrowup","arrowdown","arrowleft","arrowright"].includes(key)) {
    keys[key] = true;
  }

  // Existing code
  if (key === "q") character.hasSword = !character.hasSword;
  if (key === "z" && character.hasSword && !character.slashing) {
  character.slashing = true;
  setTimeout(() => { character.slashing = false; }, character.slashDuration);
}

  if (e.key === "'") spawnBoss();

  // === ADMIN ABUSE EVENT TRIGGERS ===
  const adminEvent = adminAbuseEvents.find(evt => evt.key === e.key);
  if (adminEvent) {
    triggerAdminEvent(adminEvent);
  }

});

window.addEventListener("keyup", e => {
  const key = e.key.toLowerCase();
  if (["w","a","s","d","arrowup","arrowdown","arrowleft","arrowright"].includes(key)) {
    keys[key] = false;
  }
});

window.addEventListener("keyup", e => {
  const key = e.key.toLowerCase();
  if ("wasd".includes(key)) keys[key] = false;
});

window.addEventListener("keyup", e => { if ("wasd".includes(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false; });
canvas.addEventListener("mousedown", e => {
  const r = canvas.getBoundingClientRect();
  character.target = { x: e.clientX - r.left - character.w / 2, y: e.clientY - r.top - character.h / 2 };
});
// === TIER SYSTEM BUTTONS ===
function updateTierButtons() {
  upgradeBtn.disabled = (cubeTier >= 2);
  downgradeBtn.disabled = (cubeTier <= 0);
  tierHint.textContent = `Current Tier: ${cubeTier + 1}`;
}

upgradeBtn.addEventListener("click", () => {
  if (cubeTier < 2) {
    cubeTier++;
    cubes = buildCubes();
    renderLegendUI();
    updateDisplays();
    updateTierButtons();
  }
});

downgradeBtn.addEventListener("click", () => {
  if (cubeTier > 0) {
    cubeTier--;
    cubes = buildCubes();
    renderLegendUI();
    updateDisplays();
    updateTierButtons();
  }
});

// --- SAVE & LOAD PROGRESS ---
const saveBtn = document.getElementById("saveBtn");
const loadBtn = document.getElementById("loadBtn");

saveBtn.addEventListener("click", () => {
const data = {
  money: money.toString(),
  incomePerSec: incomePerSec.toString(),
  houseValue: houseValue.toString(),
  legendCounts: Object.fromEntries(
    Object.entries(legendCounts).map(([k, v]) => [k, v.toString()])
  ),
  dropCounters,
  playerInventory,
  cubeTier,
  bossDrops
};

  data.equipped = {
      swords: equippedSwordSpecial,
      relics: equippedRelicSpecial,
      eggs: equippedEggSpecial,
      skins: equippedSkinSpecial,
      potions: equippedPotionSpecial
    };
  localStorage.setItem("cubeGameSave", JSON.stringify(data));
  

  alert("‚úÖ Progress Saved!");
});



loadBtn.addEventListener("click", () => {
  const raw = localStorage.getItem("cubeGameSave");
  if (!raw) return alert("‚ö†Ô∏è No saved game found.");

  if (!confirm("‚ö†Ô∏è Are you sure you want to load your previous save? All unsaved progress will be lost.")) {
    return;
  }

  try {
    const data = JSON.parse(raw);
    money = BigInt(data.money);
    incomePerSec = BigInt(data.incomePerSec);
    houseValue = BigInt(data.houseValue);
    for (let k in data.legendCounts) legendCounts[k] = BigInt(data.legendCounts[k]);
    cubeTier = data.cubeTier || 0;

    // üß∫ Restore drop counters and player inventory
    if (data.dropCounters) Object.assign(dropCounters, data.dropCounters);
    if (data.playerInventory) {
      for (let cat in data.playerInventory) {
        playerInventory[cat] = data.playerInventory[cat];
      }
    }


    if (data.equipped) {
      equippedSwordSpecial = data.equipped.swords || 0;
      equippedRelicSpecial = data.equipped.relics || 0;
      equippedEggSpecial = data.equipped.eggs || 0;
      equippedSkinSpecial = data.equipped.skins || 0;
      equippedPotionSpecial = data.equipped.potions || 0;
    }

    if (data.bossDrops) bossDrops = data.bossDrops;

cubes = buildCubes();
renderLegendUI();
updateDisplays();
updateInventoryDisplay();
updateTierButtons();


    alert("‚úÖ Progress Loaded!");
  } catch (err) {
    console.error(err);
    alert("‚ùå Failed to load save data!");
  }
});



// ---- Special Cubes ----
const specials = [
  { name: "teal", color: "teal", emoji: "üíé", duration: 2000, respawn: 15000, effect: c => money += money / 10n },
  { name: "brown", color: "brown", emoji: "üíÄ", duration: 5000, respawn: 60000, chase: true, speed: 120, effect: c => money -= money / 10n },
  { name: "yellow", color: "yellow", emoji: "‚≠ê", duration: 1000, respawn: 300000, effect: c => money += money * 30n / 100n },
  { name: "scarlet", color: "crimson", emoji: "üî•", duration: 15000, respawn: 300000, chase: true, speed: 180, effect: c => money -= money * 30n / 100n },
  { name: "pink", color: "pink", emoji: "üíñ", duration: 1000, respawn: 390000, effect: c => money += money * 50n / 100n },
  { name: "magenta", color: "magenta", emoji: "üíî", duration: 30000, respawn: 420000, chase: true, speed: 240, effect: c => money -= money * 50n / 100n },
];

const boss = {
  x: 0, y: 0, w: character.w * 1.5, h: character.h * 1.5,
  color: "#3b1f00",
  emoji: "‚ò†Ô∏è",
  visible: false,
  hitsToDie: 10,
  hitsRemaining: 10,
  playerHits: 0,
  speed: character.speed * 1.3,
  aoeRadius: 80,
  spawnX: 0,
  spawnY: 0,
};

// ‚ö° Slash effects list
const slashes = [];

function spawnSlash(x, y, angle) {
  slashes.push({
    x, y,
    angle,
    life: 0,          // starts fresh
    maxLife: 15,      // frames before fade out
  });
}

// helper: generate random spawn interval (1√ó to 1.3√ó respawn)
function randomSpawnInterval(respawn) {
  return respawn + Math.random() * respawn * 0.3;
}

// spawn special cube at random position avoiding character and cubes
function spawnSpecial(s) {
  // position randomly, avoiding character and cubes
  do {
    s.x = Math.random() * (W - CUBE_SIZE);
    s.y = Math.random() * (H - CUBE_SIZE);
  } while (cubes.some(c => rectsOverlap({ x: s.x, y: s.y, w: CUBE_SIZE, h: CUBE_SIZE }, c.pos)) ||
           rectsOverlap({ x: s.x, y: s.y, w: CUBE_SIZE, h: CUBE_SIZE }, character));

  s.visible = true;

  // hide after duration
  setTimeout(() => {
    s.visible = false;
    // schedule next spawn strictly based on respawn timer
    setTimeout(() => spawnSpecial(s), randomSpawnInterval(s.respawn));
  }, s.duration);
}

// initialize special cubes with first spawn delayed by respawn time
//specials.forEach(s => setTimeout(() => spawnSpecial(s), randomSpawnInterval(s.respawn)));

function spawnBoss() {
  boss.x = Math.random() * (W - boss.w);
  boss.y = Math.random() * (H - boss.h);
  boss.spawnX = boss.x; // save spawn position
  boss.spawnY = boss.y;
  boss.visible = true;
  boss.hitsRemaining = 10;
  boss.playerHits = 0;

  nextBossSpawn = Date.now() + bossSpawnInterval; // reset timer

  // hide boss if not defeated in 30 seconds
  setTimeout(() => {
    if (boss.visible) boss.visible = false;
  }, 60000);
}


// initial spawn timer (10 min after game starts)
//setTimeout(spawnBoss, 600000);


// ---- Update loop handling specials ----
function update(dt) {
  let mx = 0, my = 0;
if (keys.w || keys.arrowup) my -= 1;
if (keys.s || keys.arrowdown) my += 1;
if (keys.a || keys.arrowleft) mx -= 1;
if (keys.d || keys.arrowright) mx += 1;

  if (mx || my) {
    const len = Math.hypot(mx, my);
    character.x += (mx / len) * character.speed * dt * speedMultiplier;
    character.y += (my / len) * character.speed * dt * speedMultiplier;
  } else if (character.target) {
    const dx = character.target.x - character.x, dy = character.target.y - character.y, dist = Math.hypot(dx, dy);
    if (dist > 2) { 
      character.x += (dx / dist) * character.speed * dt * speedMultiplier; 
      character.y += (dy / dist) * character.speed * dt * speedMultiplier; }
    else character.target = null;
  }

  character.x = Math.max(0, Math.min(W - character.w, character.x));
  character.y = Math.max(0, Math.min(H - character.h, character.y));

  specials.forEach(s => {
    if (s.visible && s.chase) {
      const dx = character.x - s.x, dy = character.y - s.y, dist = Math.hypot(dx, dy);
      if (dist > 1) { s.x += (dx / dist) * (s.speed * dt); s.y += (dy / dist) * (s.speed * dt); 
          if (boss.pauseUntil && Date.now() < boss.pauseUntil) return;        
      }
    }
    if (s.visible && rectsOverlap(s, character)) {
      s.visible = false;
      s.effect();
      updateDisplays();
      // next spawn is already scheduled independently, no need to trigger here
    }
  });

// üß© Boss movement and attack logic
if (boss.visible) {
  const dx = character.x - boss.x;
  const dy = character.y - boss.y;
  const distance = Math.hypot(dx, dy);

  if (boss.retreating) {
    // Move back to original spawn
    const rx = boss.spawnX - boss.x;
    const ry = boss.spawnY - boss.y;
    const rDist = Math.hypot(rx, ry);
    if (rDist > 2) {
      boss.x += (rx / rDist) * boss.speed * dt * 0.5;
      boss.y += (ry / rDist) * boss.speed * dt * 0.5;
    } else {
      boss.retreating = false; // stop retreating
      boss.pauseUntil = Date.now() + 800; // pause 0.8s before resuming chase

    }
  } else {
    // Normal chasing behavior
    if (distance > 2) {
      boss.x += (dx / distance) * boss.speed * dt * 0.5;
      boss.y += (dy / distance) * boss.speed * dt * 0.5;
    }

    // Attack range check
    if (distance < boss.w * 1.2 && !boss.attackCooldown) {
      boss.attackCooldown = true;
      boss.playerHits++;

      if (boss.playerHits < 3) {
        // First two hits ‚Äî retreat
        boss.retreating = true;
      } else {
        // 3rd hit ‚Äî money penalty and reset
        money = money / 2n;
        boss.visible = false;
        boss.playerHits = 0;
        nextBossSpawn = Date.now() + bossSpawnInterval; // reset timer
      }

      // small cooldown between attacks
      setTimeout(() => (boss.attackCooldown = false), 2000);
    }
  }
}
// üó°Ô∏è Sword vs Boss collision check
if (boss.visible && character.slashing && !boss.retreating) {
if (boss.hitsRemaining <= 0) {
  boss.visible = false;
  boss.hitsRemaining = boss.hitsToDie;
  boss.playerHits = 0;
  nextBossSpawn = Date.now() + bossSpawnInterval;

  const drops = [];
  if (Math.random() <= 1.0) drops.push("ü¶¥ Skeleton Bones");
  if (Math.random() <= 0.30) drops.push("üìø Crossbones Relic");
  if (Math.random() <= 0.05) drops.push("‚¨úüíÄ Skeleton Skin");
  if (Math.random() <= 0.01) drops.push("‚¨ú‚ò†Ô∏è Crossbones Cube");

  // Store drops visually
  bossDrops.push({ x: boss.x + boss.w/2, y: boss.y, items: drops, timer: 3000, opacity: 1 });

  // Update inventory and drop counters
  drops.forEach(item => {
    if (inventory[item] !== undefined) inventory[item]++;
    if (dropCounters[item] !== undefined) dropCounters[item]++;
    if (!playerInventory["Drops"]) playerInventory["Drops"] = [];
    const existing = playerInventory["Drops"].find(i => i.name === item);
    if (existing) existing.count++;
    else playerInventory["Drops"].push({ icon: "üì¶", name: item, count: 1 });
  });

  updateInventoryDisplay();
}


  // Define sword attack range in front of the player based on direction of movement
  const swordRange = 40;
  let swordBox = { x: character.x, y: character.y, w: character.w, h: character.h };

  // Check movement keys to infer facing direction
  if (keys.w) swordBox.y -= swordRange;
  else if (keys.s) swordBox.y += swordRange;
  else if (keys.a) swordBox.x -= swordRange;
  else swordBox.x += swordRange;

  swordBox.w += swordRange / 2;
  swordBox.h += swordRange / 2;

  // For debugging (optional)
  // ctx.strokeStyle = "yellow";
  // ctx.strokeRect(swordBox.x, swordBox.y, swordBox.w, swordBox.h);

  if (rectsOverlap(swordBox, boss) && !boss.hitCooldown && !boss.retreating) {
    // üî• Apply sword special multiplier damage
    const dmg = Math.max(1, equippedSwordSpecial);
    boss.hitsRemaining -= dmg;

    boss.flash = true;
    spawnSlash(boss.x + boss.w / 2, boss.y + boss.h / 2, Math.random() * Math.PI * 2);

    // Boss retreats randomly around 30‚Äì50px away
    boss.retreating = true;
    boss.invulnerable = true; // can‚Äôt hurt player during retreat

    const angle = Math.random() * 2 * Math.PI;
    const distance = 30 + Math.random() * 20; // 30‚Äì50px random distance
    const newX = boss.x + Math.cos(angle) * distance;
    const newY = boss.y + Math.sin(angle) * distance;

    const startX = boss.x;
    const startY = boss.y;
    const startTime = performance.now();
    const retreatDuration = 400; // 0.4s retreat

    function retreatAnimation(now) {
      const progress = Math.min((now - startTime) / retreatDuration, 1);
      boss.x = startX + (newX - startX) * progress;
      boss.y = startY + (newY - startY) * progress;

      if (progress < 1) {
        requestAnimationFrame(retreatAnimation);
      } else {
        boss.retreating = false;
        boss.invulnerable = false;
      }
    }
    requestAnimationFrame(retreatAnimation);

    setTimeout(() => (boss.flash = false), 150);
    boss.hitCooldown = true;
    setTimeout(() => (boss.hitCooldown = false), 300);

  if (boss.hitsRemaining <= 0) {
    boss.visible = false;
    boss.hitsRemaining = boss.hitsToDie;
    boss.playerHits = 0;
    nextBossSpawn = Date.now() + bossSpawnInterval;

    // üß© Loot drop logic
    const drops = [];

    // Each roll uses Math.random()
    // 100% drop
    if (Math.random() <= 1.0) drops.push("ü¶¥ Skeleton Bones");
    // 30% drop
    if (Math.random() <= 0.30) drops.push("üìø Crossbones Relic");
    // 5% drop
    if (Math.random() <= 0.05) drops.push("‚¨úüíÄ Skeleton Skin");
    // 1% drop
    if (Math.random() <= 0.01) drops.push("‚¨ú‚ò†Ô∏è Crossbones Cube");

    // Store drops to display them visually
    bossDrops.push({
      x: boss.x + boss.w / 2,
      y: boss.y,
      items: drops,
      timer: 3000, // display for 3 seconds
      opacity: 1
    });

  // üßæ Update inventory + drop counters
  drops.forEach(item => {
    if (inventory[item] !== undefined) {
      inventory[item]++;
      dropCounters[item]++; // track total count per item type
    }
  });
  updateInventoryDisplay();

} 
}
}


// üîÅ Update slash effects
for (let i = slashes.length - 1; i >= 0; i--) {
  const s = slashes[i];
  s.life++;
  if (s.life > s.maxLife) slashes.splice(i, 1);
}
// üîÑ Update boss loot fade timers
for (let i = bossDrops.length - 1; i >= 0; i--) {
  const drop = bossDrops[i];
  drop.timer -= dt * 1000; // convert dt seconds ‚Üí ms
  drop.opacity = Math.max(0, drop.timer / 3000); // fade out over 3s
  if (drop.timer <= 0) bossDrops.splice(i, 1);
}

  checkCubeCollisions();
  checkHouseDeposit();
}


function render() {
  
  
  // Apply earthquake shake
  if (currentAdminEvent && currentAdminEvent.animation === "earthquake") {
    ctx.save();
    ctx.translate(adminEventShakeX, adminEventShakeY);
  }

  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = 'rgba(255,255,255,0.02)';
  ctx.fillRect(12, 8, W - 24, 110);


// üïí Boss Timer Display
const now = Date.now();
ctx.fillStyle = 'white';
ctx.font = '16px Arial';
ctx.textAlign = 'left';
ctx.textBaseline = 'top';

if (!boss.visible) {
  const timeLeft = Math.max(0, nextBossSpawn - now);
  const minutes = Math.floor(timeLeft / 60000);
  const seconds = Math.floor((timeLeft % 60000) / 1000);
  ctx.fillText(`Boss in: ${minutes}:${seconds.toString().padStart(2, '0')}`, 20, 20);
} else {
  ctx.fillText(`Boss HP: ${boss.hitsRemaining}/${boss.hitsToDie}`, 20, 20);
  ctx.fillText(`Your HP: ${3 - boss.playerHits}/3`, 20, 40);
}



  cubes.forEach(c => {
    const p = c.pos;
    ctx.fillStyle = c.color;
    ctx.fillRect(p.x, p.y, p.w, p.h);
    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
    ctx.lineWidth = 2;
    ctx.strokeRect(p.x + 0.5, p.y + 0.5, p.w - 1, p.h - 1);
    ctx.fillStyle = (c.color === '#e9ecef' || c.color === '#fff1a8' || c.color === '#ffc89b') ? '#111' : '#fff';
    ctx.font = 'bold 14px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(shortLabel(c.value), p.x + p.w / 2, p.y + p.h / 2);


  if (character.hasSword) {
    const swordEmoji =  swordicon ;  //'üó°Ô∏è';
    const centerX = character.x + character.w + 12; // sword center x
    const centerY = character.y + character.h / 2;  // sword center y
    ctx.save();              // save current canvas state
    ctx.translate(centerX, centerY);   // move origin to sword center
    ctx.rotate(Math.PI);     // rotate 180 degrees (œÄ radians)
    ctx.font = '24px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(swordEmoji, 0, 0);    // draw at new origin
    
          // if slashing, move it slightly forward or up for effect
        if (character.slashing) {
          //ctx.fillText(swordEmoji, character.x + character.w + 24, character.y + character.h/2 - 6);
              ctx.fillText(swordEmoji, -6, 7); // adjust these numbers as needed

        }
        ctx.restore();           // restore canvas state

  }

  });

  ctx.lineWidth = 3;
  ctx.strokeStyle = house.border;
  ctx.setLineDash([6, 6]);
  ctx.strokeRect(house.x + 1, house.y + 1, house.w - 2, house.h - 2);
  ctx.setLineDash([]);
  ctx.fillStyle = 'rgba(255,255,255,0.75)';
  ctx.font = '13px sans-serif';
  ctx.textAlign = 'right';
  ctx.fillText('HOUSE', house.x + house.w - 8, house.y - 6);

  ctx.fillStyle = character.color;
  ctx.fillRect(character.x, character.y, character.w, character.h);
  ctx.strokeStyle = 'rgba(0,0,0,0.6)';
  ctx.strokeRect(character.x + 0.5, character.y + 0.5, character.w - 1, character.h - 1);
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 12px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(character.assignedValue ? shortLabel(character.assignedValue) : '‚Äî', character.x + character.w / 2, character.y + character.h / 2);


  // ‚ö° Draw slash effects
slashes.forEach(s => {
  const alpha = 1 - s.life / s.maxLife;
  ctx.save();
  ctx.translate(s.x, s.y);
  ctx.rotate(s.angle);
  ctx.globalAlpha = alpha;
  ctx.strokeStyle = 'white';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(0, 0, 30, 0, Math.PI / 2);
  ctx.stroke();
  ctx.restore();
});
ctx.globalAlpha = 1;


  if (character.assignedName) {
    ctx.font = '11px sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.fillText(character.assignedName, character.x + character.w / 2, character.y - 10);
  }


if (boss.visible) {
  // draw boss
  //ctx.fillStyle = boss.color;
  ctx.fillStyle = boss.flash ? "#a00" : boss.color;
  ctx.fillRect(boss.x, boss.y, boss.w, boss.h);
  ctx.strokeStyle = 'rgba(0,0,0,0.6)';
  ctx.strokeRect(boss.x + 0.5, boss.y + 0.5, boss.w - 1, boss.h - 1);
  ctx.font = '24px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(boss.emoji, boss.x + boss.w / 2, boss.y + boss.h / 2);

  // draw HP bars
  const barWidth = 200;
  ctx.fillStyle = '#222';
  ctx.fillRect(W/2 - barWidth/2, 20, barWidth, 10);
  ctx.fillStyle = '#f33';
  ctx.fillRect(W/2 - barWidth/2, 20, barWidth * (boss.hitsRemaining / boss.hitsToDie), 10);

  ctx.fillStyle = '#fff';
  ctx.font = '12px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(`Boss HP: ${boss.hitsRemaining}/${boss.hitsToDie}`, W/2, 15);

  // player HP bar
  ctx.fillStyle = '#222';
  ctx.fillRect(W/2 - barWidth/2, H - 30, barWidth, 10);
  ctx.fillStyle = '#0f0';
  ctx.fillRect(W/2 - barWidth/2, H - 30, barWidth * ((3 - boss.playerHits)/3), 10);
  ctx.fillStyle = '#fff';
  ctx.fillText(`Player HP: ${3 - boss.playerHits}/3`, W/2, H - 35);
}



  specials.forEach(s => {
    if (!s.visible) return;
    ctx.fillStyle = s.color;
    ctx.fillRect(s.x, s.y, CUBE_SIZE, CUBE_SIZE);
    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
    ctx.strokeRect(s.x + 0.5, s.y + 0.5, CUBE_SIZE - 1, CUBE_SIZE - 1);
    ctx.fillStyle = '#fff';
    ctx.font = '20px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(s.emoji, s.x + CUBE_SIZE / 2, s.y + CUBE_SIZE / 2);
  });
  
  // üí∞ Draw Boss Loot Drops
bossDrops.forEach(drop => {
  ctx.save();
  ctx.globalAlpha = drop.opacity;
  ctx.font = '20px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';
  ctx.fillStyle = '#fff';
  drop.items.forEach((item, i) => {
    ctx.fillText(item, drop.x, drop.y - i * 22);
  });  
  ctx.restore();
  });
  
  drawAdminAnimation(ctx);

  // Reset earthquake shake
  if (currentAdminEvent && currentAdminEvent.animation === "earthquake") {
    ctx.restore();
  }
};


let lastTime = performance.now();

function initializeGame() {
  // Build cubes, legend, and UI
  cubes = buildCubes();
  renderLegendUI();
  updateInventoryDisplay();
  updateDisplays();
  updateTierButtons();
  // Schedule boss spawn
  setTimeout(spawnBoss, 600000);

  // Initialize slash list & specials
  specials.forEach(s => setTimeout(() => spawnSpecial(s), randomSpawnInterval(s.respawn)));
}

// Call it once after defining everything
initializeGame();

/**
 * The main game loop. Called repeatedly by requestAnimationFrame.
 * Updates the game state (e.g. character movement, animations) and renders the game.
 * @param {number} t - The current time in milliseconds.
 */
function loop(t) {
  const dt = (t - lastTime) / 1000;
  lastTime = t;
  update(dt);
  updateWeatherAnimation(dt);
  updateAdminAnimation(dt);
  render();
  drawWeatherAnimation(ctx);
  drawAdminAnimation(ctx);  
  requestAnimationFrame(loop);
}

function init() {
  cubes = buildCubes();
  renderLegendUI();
  recomputeIncome();
  updateDisplays();
  requestAnimationFrame(loop);
}
init();
</script>

</body>
</html>
